// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GYEOL_ICPDEV_GYEOL_SCHEMA_H_
#define FLATBUFFERS_GENERATED_GYEOL_ICPDEV_GYEOL_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace ICPDev {
namespace Gyeol {
namespace Schema {

struct BoolValue;
struct BoolValueBuilder;
struct BoolValueT;

struct IntValue;
struct IntValueBuilder;
struct IntValueT;

struct FloatValue;
struct FloatValueBuilder;
struct FloatValueT;

struct StringRef;
struct StringRefBuilder;
struct StringRefT;

struct ListValue;
struct ListValueBuilder;
struct ListValueT;

struct Tag;
struct TagBuilder;
struct TagT;

struct Line;
struct LineBuilder;
struct LineT;

struct Choice;
struct ChoiceBuilder;
struct ChoiceT;

struct Jump;
struct JumpBuilder;
struct JumpT;

struct Command;
struct CommandBuilder;
struct CommandT;

struct ExprToken;
struct ExprTokenBuilder;
struct ExprTokenT;

struct Expression;
struct ExpressionBuilder;
struct ExpressionT;

struct SetVar;
struct SetVarBuilder;
struct SetVarT;

struct Condition;
struct ConditionBuilder;
struct ConditionT;

struct RandomBranch;
struct RandomBranchBuilder;
struct RandomBranchT;

struct Random;
struct RandomBuilder;
struct RandomT;

struct Return;
struct ReturnBuilder;
struct ReturnT;

struct CallWithReturn;
struct CallWithReturnBuilder;
struct CallWithReturnT;

struct CharacterDef;
struct CharacterDefBuilder;
struct CharacterDefT;

struct Instruction;
struct InstructionBuilder;
struct InstructionT;

struct Node;
struct NodeBuilder;
struct NodeT;

struct SavedVar;
struct SavedVarBuilder;
struct SavedVarT;

struct SavedShadowedVar;
struct SavedShadowedVarBuilder;
struct SavedShadowedVarT;

struct SavedCallFrame;
struct SavedCallFrameBuilder;
struct SavedCallFrameT;

struct SavedPendingChoice;
struct SavedPendingChoiceBuilder;
struct SavedPendingChoiceT;

struct SavedVisitCount;
struct SavedVisitCountBuilder;
struct SavedVisitCountT;

struct SaveState;
struct SaveStateBuilder;
struct SaveStateT;

struct Story;
struct StoryBuilder;
struct StoryT;

enum class Operator : int8_t {
  Equal = 0,
  NotEqual = 1,
  Greater = 2,
  Less = 3,
  GreaterOrEqual = 4,
  LessOrEqual = 5,
  MIN = Equal,
  MAX = LessOrEqual
};

inline const Operator (&EnumValuesOperator())[6] {
  static const Operator values[] = {
    Operator::Equal,
    Operator::NotEqual,
    Operator::Greater,
    Operator::Less,
    Operator::GreaterOrEqual,
    Operator::LessOrEqual
  };
  return values;
}

inline const char * const *EnumNamesOperator() {
  static const char * const names[7] = {
    "Equal",
    "NotEqual",
    "Greater",
    "Less",
    "GreaterOrEqual",
    "LessOrEqual",
    nullptr
  };
  return names;
}

inline const char *EnumNameOperator(Operator e) {
  if (::flatbuffers::IsOutRange(e, Operator::Equal, Operator::LessOrEqual)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOperator()[index];
}

enum class AssignOp : int8_t {
  Assign = 0,
  Append = 1,
  Remove = 2,
  MIN = Assign,
  MAX = Remove
};

inline const AssignOp (&EnumValuesAssignOp())[3] {
  static const AssignOp values[] = {
    AssignOp::Assign,
    AssignOp::Append,
    AssignOp::Remove
  };
  return values;
}

inline const char * const *EnumNamesAssignOp() {
  static const char * const names[4] = {
    "Assign",
    "Append",
    "Remove",
    nullptr
  };
  return names;
}

inline const char *EnumNameAssignOp(AssignOp e) {
  if (::flatbuffers::IsOutRange(e, AssignOp::Assign, AssignOp::Remove)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAssignOp()[index];
}

enum class ValueData : uint8_t {
  NONE = 0,
  BoolValue = 1,
  IntValue = 2,
  FloatValue = 3,
  StringRef = 4,
  ListValue = 5,
  MIN = NONE,
  MAX = ListValue
};

inline const ValueData (&EnumValuesValueData())[6] {
  static const ValueData values[] = {
    ValueData::NONE,
    ValueData::BoolValue,
    ValueData::IntValue,
    ValueData::FloatValue,
    ValueData::StringRef,
    ValueData::ListValue
  };
  return values;
}

inline const char * const *EnumNamesValueData() {
  static const char * const names[7] = {
    "NONE",
    "BoolValue",
    "IntValue",
    "FloatValue",
    "StringRef",
    "ListValue",
    nullptr
  };
  return names;
}

inline const char *EnumNameValueData(ValueData e) {
  if (::flatbuffers::IsOutRange(e, ValueData::NONE, ValueData::ListValue)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValueData()[index];
}

template<typename T> struct ValueDataTraits {
  static const ValueData enum_value = ValueData::NONE;
};

template<> struct ValueDataTraits<ICPDev::Gyeol::Schema::BoolValue> {
  static const ValueData enum_value = ValueData::BoolValue;
};

template<> struct ValueDataTraits<ICPDev::Gyeol::Schema::IntValue> {
  static const ValueData enum_value = ValueData::IntValue;
};

template<> struct ValueDataTraits<ICPDev::Gyeol::Schema::FloatValue> {
  static const ValueData enum_value = ValueData::FloatValue;
};

template<> struct ValueDataTraits<ICPDev::Gyeol::Schema::StringRef> {
  static const ValueData enum_value = ValueData::StringRef;
};

template<> struct ValueDataTraits<ICPDev::Gyeol::Schema::ListValue> {
  static const ValueData enum_value = ValueData::ListValue;
};

template<typename T> struct ValueDataUnionTraits {
  static const ValueData enum_value = ValueData::NONE;
};

template<> struct ValueDataUnionTraits<ICPDev::Gyeol::Schema::BoolValueT> {
  static const ValueData enum_value = ValueData::BoolValue;
};

template<> struct ValueDataUnionTraits<ICPDev::Gyeol::Schema::IntValueT> {
  static const ValueData enum_value = ValueData::IntValue;
};

template<> struct ValueDataUnionTraits<ICPDev::Gyeol::Schema::FloatValueT> {
  static const ValueData enum_value = ValueData::FloatValue;
};

template<> struct ValueDataUnionTraits<ICPDev::Gyeol::Schema::StringRefT> {
  static const ValueData enum_value = ValueData::StringRef;
};

template<> struct ValueDataUnionTraits<ICPDev::Gyeol::Schema::ListValueT> {
  static const ValueData enum_value = ValueData::ListValue;
};

struct ValueDataUnion {
  ValueData type;
  void *value;

  ValueDataUnion() : type(ValueData::NONE), value(nullptr) {}
  ValueDataUnion(ValueDataUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ValueData::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ValueDataUnion(const ValueDataUnion &);
  ValueDataUnion &operator=(const ValueDataUnion &u)
    { ValueDataUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ValueDataUnion &operator=(ValueDataUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ValueDataUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ValueDataUnionTraits<RT>::enum_value;
    if (type != ValueData::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, ValueData type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  ICPDev::Gyeol::Schema::BoolValueT *AsBoolValue() {
    return type == ValueData::BoolValue ?
      reinterpret_cast<ICPDev::Gyeol::Schema::BoolValueT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::BoolValueT *AsBoolValue() const {
    return type == ValueData::BoolValue ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::BoolValueT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::IntValueT *AsIntValue() {
    return type == ValueData::IntValue ?
      reinterpret_cast<ICPDev::Gyeol::Schema::IntValueT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::IntValueT *AsIntValue() const {
    return type == ValueData::IntValue ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::IntValueT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::FloatValueT *AsFloatValue() {
    return type == ValueData::FloatValue ?
      reinterpret_cast<ICPDev::Gyeol::Schema::FloatValueT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::FloatValueT *AsFloatValue() const {
    return type == ValueData::FloatValue ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::FloatValueT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::StringRefT *AsStringRef() {
    return type == ValueData::StringRef ?
      reinterpret_cast<ICPDev::Gyeol::Schema::StringRefT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::StringRefT *AsStringRef() const {
    return type == ValueData::StringRef ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::StringRefT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::ListValueT *AsListValue() {
    return type == ValueData::ListValue ?
      reinterpret_cast<ICPDev::Gyeol::Schema::ListValueT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::ListValueT *AsListValue() const {
    return type == ValueData::ListValue ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::ListValueT *>(value) : nullptr;
  }
};

bool VerifyValueData(::flatbuffers::Verifier &verifier, const void *obj, ValueData type);
bool VerifyValueDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ValueData> *types);

enum class OpData : uint8_t {
  NONE = 0,
  Line = 1,
  Choice = 2,
  Jump = 3,
  Command = 4,
  SetVar = 5,
  Condition = 6,
  Random = 7,
  Return = 8,
  CallWithReturn = 9,
  MIN = NONE,
  MAX = CallWithReturn
};

inline const OpData (&EnumValuesOpData())[10] {
  static const OpData values[] = {
    OpData::NONE,
    OpData::Line,
    OpData::Choice,
    OpData::Jump,
    OpData::Command,
    OpData::SetVar,
    OpData::Condition,
    OpData::Random,
    OpData::Return,
    OpData::CallWithReturn
  };
  return values;
}

inline const char * const *EnumNamesOpData() {
  static const char * const names[11] = {
    "NONE",
    "Line",
    "Choice",
    "Jump",
    "Command",
    "SetVar",
    "Condition",
    "Random",
    "Return",
    "CallWithReturn",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpData(OpData e) {
  if (::flatbuffers::IsOutRange(e, OpData::NONE, OpData::CallWithReturn)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpData()[index];
}

template<typename T> struct OpDataTraits {
  static const OpData enum_value = OpData::NONE;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Line> {
  static const OpData enum_value = OpData::Line;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Choice> {
  static const OpData enum_value = OpData::Choice;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Jump> {
  static const OpData enum_value = OpData::Jump;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Command> {
  static const OpData enum_value = OpData::Command;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::SetVar> {
  static const OpData enum_value = OpData::SetVar;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Condition> {
  static const OpData enum_value = OpData::Condition;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Random> {
  static const OpData enum_value = OpData::Random;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Return> {
  static const OpData enum_value = OpData::Return;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::CallWithReturn> {
  static const OpData enum_value = OpData::CallWithReturn;
};

template<typename T> struct OpDataUnionTraits {
  static const OpData enum_value = OpData::NONE;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::LineT> {
  static const OpData enum_value = OpData::Line;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::ChoiceT> {
  static const OpData enum_value = OpData::Choice;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::JumpT> {
  static const OpData enum_value = OpData::Jump;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::CommandT> {
  static const OpData enum_value = OpData::Command;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::SetVarT> {
  static const OpData enum_value = OpData::SetVar;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::ConditionT> {
  static const OpData enum_value = OpData::Condition;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::RandomT> {
  static const OpData enum_value = OpData::Random;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::ReturnT> {
  static const OpData enum_value = OpData::Return;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::CallWithReturnT> {
  static const OpData enum_value = OpData::CallWithReturn;
};

struct OpDataUnion {
  OpData type;
  void *value;

  OpDataUnion() : type(OpData::NONE), value(nullptr) {}
  OpDataUnion(OpDataUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(OpData::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  OpDataUnion(const OpDataUnion &);
  OpDataUnion &operator=(const OpDataUnion &u)
    { OpDataUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  OpDataUnion &operator=(OpDataUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~OpDataUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = OpDataUnionTraits<RT>::enum_value;
    if (type != OpData::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, OpData type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  ICPDev::Gyeol::Schema::LineT *AsLine() {
    return type == OpData::Line ?
      reinterpret_cast<ICPDev::Gyeol::Schema::LineT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::LineT *AsLine() const {
    return type == OpData::Line ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::LineT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::ChoiceT *AsChoice() {
    return type == OpData::Choice ?
      reinterpret_cast<ICPDev::Gyeol::Schema::ChoiceT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::ChoiceT *AsChoice() const {
    return type == OpData::Choice ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::ChoiceT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::JumpT *AsJump() {
    return type == OpData::Jump ?
      reinterpret_cast<ICPDev::Gyeol::Schema::JumpT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::JumpT *AsJump() const {
    return type == OpData::Jump ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::JumpT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::CommandT *AsCommand() {
    return type == OpData::Command ?
      reinterpret_cast<ICPDev::Gyeol::Schema::CommandT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::CommandT *AsCommand() const {
    return type == OpData::Command ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::CommandT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::SetVarT *AsSetVar() {
    return type == OpData::SetVar ?
      reinterpret_cast<ICPDev::Gyeol::Schema::SetVarT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::SetVarT *AsSetVar() const {
    return type == OpData::SetVar ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::SetVarT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::ConditionT *AsCondition() {
    return type == OpData::Condition ?
      reinterpret_cast<ICPDev::Gyeol::Schema::ConditionT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::ConditionT *AsCondition() const {
    return type == OpData::Condition ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::ConditionT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::RandomT *AsRandom() {
    return type == OpData::Random ?
      reinterpret_cast<ICPDev::Gyeol::Schema::RandomT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::RandomT *AsRandom() const {
    return type == OpData::Random ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::RandomT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::ReturnT *AsReturn() {
    return type == OpData::Return ?
      reinterpret_cast<ICPDev::Gyeol::Schema::ReturnT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::ReturnT *AsReturn() const {
    return type == OpData::Return ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::ReturnT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::CallWithReturnT *AsCallWithReturn() {
    return type == OpData::CallWithReturn ?
      reinterpret_cast<ICPDev::Gyeol::Schema::CallWithReturnT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::CallWithReturnT *AsCallWithReturn() const {
    return type == OpData::CallWithReturn ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::CallWithReturnT *>(value) : nullptr;
  }
};

bool VerifyOpData(::flatbuffers::Verifier &verifier, const void *obj, OpData type);
bool VerifyOpDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<OpData> *types);

enum class ChoiceModifier : int8_t {
  Default = 0,
  Once = 1,
  Sticky = 2,
  Fallback = 3,
  MIN = Default,
  MAX = Fallback
};

inline const ChoiceModifier (&EnumValuesChoiceModifier())[4] {
  static const ChoiceModifier values[] = {
    ChoiceModifier::Default,
    ChoiceModifier::Once,
    ChoiceModifier::Sticky,
    ChoiceModifier::Fallback
  };
  return values;
}

inline const char * const *EnumNamesChoiceModifier() {
  static const char * const names[5] = {
    "Default",
    "Once",
    "Sticky",
    "Fallback",
    nullptr
  };
  return names;
}

inline const char *EnumNameChoiceModifier(ChoiceModifier e) {
  if (::flatbuffers::IsOutRange(e, ChoiceModifier::Default, ChoiceModifier::Fallback)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesChoiceModifier()[index];
}

enum class ExprOp : int8_t {
  PushLiteral = 0,
  PushVar = 1,
  Add = 2,
  Sub = 3,
  Mul = 4,
  Div = 5,
  Mod = 6,
  Negate = 7,
  CmpEq = 8,
  CmpNe = 9,
  CmpGt = 10,
  CmpLt = 11,
  CmpGe = 12,
  CmpLe = 13,
  And = 14,
  Or = 15,
  Not = 16,
  PushVisitCount = 17,
  PushVisited = 18,
  ListContains = 19,
  ListLength = 20,
  MIN = PushLiteral,
  MAX = ListLength
};

inline const ExprOp (&EnumValuesExprOp())[21] {
  static const ExprOp values[] = {
    ExprOp::PushLiteral,
    ExprOp::PushVar,
    ExprOp::Add,
    ExprOp::Sub,
    ExprOp::Mul,
    ExprOp::Div,
    ExprOp::Mod,
    ExprOp::Negate,
    ExprOp::CmpEq,
    ExprOp::CmpNe,
    ExprOp::CmpGt,
    ExprOp::CmpLt,
    ExprOp::CmpGe,
    ExprOp::CmpLe,
    ExprOp::And,
    ExprOp::Or,
    ExprOp::Not,
    ExprOp::PushVisitCount,
    ExprOp::PushVisited,
    ExprOp::ListContains,
    ExprOp::ListLength
  };
  return values;
}

inline const char * const *EnumNamesExprOp() {
  static const char * const names[22] = {
    "PushLiteral",
    "PushVar",
    "Add",
    "Sub",
    "Mul",
    "Div",
    "Mod",
    "Negate",
    "CmpEq",
    "CmpNe",
    "CmpGt",
    "CmpLt",
    "CmpGe",
    "CmpLe",
    "And",
    "Or",
    "Not",
    "PushVisitCount",
    "PushVisited",
    "ListContains",
    "ListLength",
    nullptr
  };
  return names;
}

inline const char *EnumNameExprOp(ExprOp e) {
  if (::flatbuffers::IsOutRange(e, ExprOp::PushLiteral, ExprOp::ListLength)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExprOp()[index];
}

struct BoolValueT : public ::flatbuffers::NativeTable {
  typedef BoolValue TableType;
  bool val = false;
};

struct BoolValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoolValueT NativeTableType;
  typedef BoolValueBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  bool val() const {
    return GetField<uint8_t>(VT_VAL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VAL, 1) &&
           verifier.EndTable();
  }
  BoolValueT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BoolValueT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BoolValue> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BoolValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BoolValueBuilder {
  typedef BoolValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(bool val) {
    fbb_.AddElement<uint8_t>(BoolValue::VT_VAL, static_cast<uint8_t>(val), 0);
  }
  explicit BoolValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BoolValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BoolValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BoolValue> CreateBoolValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool val = false) {
  BoolValueBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct BoolValue::Traits {
  using type = BoolValue;
  static auto constexpr Create = CreateBoolValue;
};

::flatbuffers::Offset<BoolValue> CreateBoolValue(::flatbuffers::FlatBufferBuilder &_fbb, const BoolValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IntValueT : public ::flatbuffers::NativeTable {
  typedef IntValue TableType;
  int32_t val = 0;
};

struct IntValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntValueT NativeTableType;
  typedef IntValueBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  int32_t val() const {
    return GetField<int32_t>(VT_VAL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VAL, 4) &&
           verifier.EndTable();
  }
  IntValueT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IntValueT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<IntValue> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IntValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IntValueBuilder {
  typedef IntValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(int32_t val) {
    fbb_.AddElement<int32_t>(IntValue::VT_VAL, val, 0);
  }
  explicit IntValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntValue> CreateIntValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t val = 0) {
  IntValueBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct IntValue::Traits {
  using type = IntValue;
  static auto constexpr Create = CreateIntValue;
};

::flatbuffers::Offset<IntValue> CreateIntValue(::flatbuffers::FlatBufferBuilder &_fbb, const IntValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloatValueT : public ::flatbuffers::NativeTable {
  typedef FloatValue TableType;
  float val = 0.0f;
};

struct FloatValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloatValueT NativeTableType;
  typedef FloatValueBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  float val() const {
    return GetField<float>(VT_VAL, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VAL, 4) &&
           verifier.EndTable();
  }
  FloatValueT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloatValueT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FloatValue> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FloatValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloatValueBuilder {
  typedef FloatValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(float val) {
    fbb_.AddElement<float>(FloatValue::VT_VAL, val, 0.0f);
  }
  explicit FloatValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloatValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloatValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloatValue> CreateFloatValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float val = 0.0f) {
  FloatValueBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct FloatValue::Traits {
  using type = FloatValue;
  static auto constexpr Create = CreateFloatValue;
};

::flatbuffers::Offset<FloatValue> CreateFloatValue(::flatbuffers::FlatBufferBuilder &_fbb, const FloatValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StringRefT : public ::flatbuffers::NativeTable {
  typedef StringRef TableType;
  int32_t index = 0;
};

struct StringRef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringRefT NativeTableType;
  typedef StringRefBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4
  };
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           verifier.EndTable();
  }
  StringRefT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StringRefT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StringRef> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StringRefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StringRefBuilder {
  typedef StringRef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(StringRef::VT_INDEX, index, 0);
  }
  explicit StringRefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringRef>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringRef> CreateStringRef(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index = 0) {
  StringRefBuilder builder_(_fbb);
  builder_.add_index(index);
  return builder_.Finish();
}

struct StringRef::Traits {
  using type = StringRef;
  static auto constexpr Create = CreateStringRef;
};

::flatbuffers::Offset<StringRef> CreateStringRef(::flatbuffers::FlatBufferBuilder &_fbb, const StringRefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ListValueT : public ::flatbuffers::NativeTable {
  typedef ListValue TableType;
  std::vector<int32_t> items{};
};

struct ListValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListValueT NativeTableType;
  typedef ListValueBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const ::flatbuffers::Vector<int32_t> *items() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
  ListValueT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ListValueT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ListValue> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ListValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ListValueBuilder {
  typedef ListValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_items(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> items) {
    fbb_.AddOffset(ListValue::VT_ITEMS, items);
  }
  explicit ListValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ListValue> CreateListValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> items = 0) {
  ListValueBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

struct ListValue::Traits {
  using type = ListValue;
  static auto constexpr Create = CreateListValue;
};

inline ::flatbuffers::Offset<ListValue> CreateListValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<int32_t>(*items) : 0;
  return ICPDev::Gyeol::Schema::CreateListValue(
      _fbb,
      items__);
}

::flatbuffers::Offset<ListValue> CreateListValue(::flatbuffers::FlatBufferBuilder &_fbb, const ListValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TagT : public ::flatbuffers::NativeTable {
  typedef Tag TableType;
  int32_t key_id = 0;
  int32_t value_id = 0;
};

struct Tag FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TagT NativeTableType;
  typedef TagBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY_ID = 4,
    VT_VALUE_ID = 6
  };
  int32_t key_id() const {
    return GetField<int32_t>(VT_KEY_ID, 0);
  }
  int32_t value_id() const {
    return GetField<int32_t>(VT_VALUE_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KEY_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_VALUE_ID, 4) &&
           verifier.EndTable();
  }
  TagT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TagT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Tag> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TagT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TagBuilder {
  typedef Tag Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key_id(int32_t key_id) {
    fbb_.AddElement<int32_t>(Tag::VT_KEY_ID, key_id, 0);
  }
  void add_value_id(int32_t value_id) {
    fbb_.AddElement<int32_t>(Tag::VT_VALUE_ID, value_id, 0);
  }
  explicit TagBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tag> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tag>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tag> CreateTag(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t key_id = 0,
    int32_t value_id = 0) {
  TagBuilder builder_(_fbb);
  builder_.add_value_id(value_id);
  builder_.add_key_id(key_id);
  return builder_.Finish();
}

struct Tag::Traits {
  using type = Tag;
  static auto constexpr Create = CreateTag;
};

::flatbuffers::Offset<Tag> CreateTag(::flatbuffers::FlatBufferBuilder &_fbb, const TagT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LineT : public ::flatbuffers::NativeTable {
  typedef Line TableType;
  int32_t character_id = -1;
  int32_t text_id = 0;
  int32_t voice_asset_id = -1;
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::TagT>> tags{};
  LineT() = default;
  LineT(const LineT &o);
  LineT(LineT&&) FLATBUFFERS_NOEXCEPT = default;
  LineT &operator=(LineT o) FLATBUFFERS_NOEXCEPT;
};

struct Line FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LineT NativeTableType;
  typedef LineBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHARACTER_ID = 4,
    VT_TEXT_ID = 6,
    VT_VOICE_ASSET_ID = 8,
    VT_TAGS = 10
  };
  int32_t character_id() const {
    return GetField<int32_t>(VT_CHARACTER_ID, -1);
  }
  int32_t text_id() const {
    return GetField<int32_t>(VT_TEXT_ID, 0);
  }
  int32_t voice_asset_id() const {
    return GetField<int32_t>(VT_VOICE_ASSET_ID, -1);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>> *tags() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>> *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHARACTER_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_TEXT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_VOICE_ASSET_ID, 4) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfTables(tags()) &&
           verifier.EndTable();
  }
  LineT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LineT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Line> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LineT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LineBuilder {
  typedef Line Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_character_id(int32_t character_id) {
    fbb_.AddElement<int32_t>(Line::VT_CHARACTER_ID, character_id, -1);
  }
  void add_text_id(int32_t text_id) {
    fbb_.AddElement<int32_t>(Line::VT_TEXT_ID, text_id, 0);
  }
  void add_voice_asset_id(int32_t voice_asset_id) {
    fbb_.AddElement<int32_t>(Line::VT_VOICE_ASSET_ID, voice_asset_id, -1);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>>> tags) {
    fbb_.AddOffset(Line::VT_TAGS, tags);
  }
  explicit LineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Line> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Line>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Line> CreateLine(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t character_id = -1,
    int32_t text_id = 0,
    int32_t voice_asset_id = -1,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>>> tags = 0) {
  LineBuilder builder_(_fbb);
  builder_.add_tags(tags);
  builder_.add_voice_asset_id(voice_asset_id);
  builder_.add_text_id(text_id);
  builder_.add_character_id(character_id);
  return builder_.Finish();
}

struct Line::Traits {
  using type = Line;
  static auto constexpr Create = CreateLine;
};

inline ::flatbuffers::Offset<Line> CreateLineDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t character_id = -1,
    int32_t text_id = 0,
    int32_t voice_asset_id = -1,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>> *tags = nullptr) {
  auto tags__ = tags ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>>(*tags) : 0;
  return ICPDev::Gyeol::Schema::CreateLine(
      _fbb,
      character_id,
      text_id,
      voice_asset_id,
      tags__);
}

::flatbuffers::Offset<Line> CreateLine(::flatbuffers::FlatBufferBuilder &_fbb, const LineT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ChoiceT : public ::flatbuffers::NativeTable {
  typedef Choice TableType;
  int32_t text_id = 0;
  int32_t target_node_name_id = 0;
  int32_t condition_var_id = -1;
  ICPDev::Gyeol::Schema::ChoiceModifier choice_modifier = ICPDev::Gyeol::Schema::ChoiceModifier::Default;
};

struct Choice FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChoiceT NativeTableType;
  typedef ChoiceBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT_ID = 4,
    VT_TARGET_NODE_NAME_ID = 6,
    VT_CONDITION_VAR_ID = 8,
    VT_CHOICE_MODIFIER = 10
  };
  int32_t text_id() const {
    return GetField<int32_t>(VT_TEXT_ID, 0);
  }
  int32_t target_node_name_id() const {
    return GetField<int32_t>(VT_TARGET_NODE_NAME_ID, 0);
  }
  int32_t condition_var_id() const {
    return GetField<int32_t>(VT_CONDITION_VAR_ID, -1);
  }
  ICPDev::Gyeol::Schema::ChoiceModifier choice_modifier() const {
    return static_cast<ICPDev::Gyeol::Schema::ChoiceModifier>(GetField<int8_t>(VT_CHOICE_MODIFIER, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TEXT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_TARGET_NODE_NAME_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_CONDITION_VAR_ID, 4) &&
           VerifyField<int8_t>(verifier, VT_CHOICE_MODIFIER, 1) &&
           verifier.EndTable();
  }
  ChoiceT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ChoiceT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Choice> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ChoiceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ChoiceBuilder {
  typedef Choice Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text_id(int32_t text_id) {
    fbb_.AddElement<int32_t>(Choice::VT_TEXT_ID, text_id, 0);
  }
  void add_target_node_name_id(int32_t target_node_name_id) {
    fbb_.AddElement<int32_t>(Choice::VT_TARGET_NODE_NAME_ID, target_node_name_id, 0);
  }
  void add_condition_var_id(int32_t condition_var_id) {
    fbb_.AddElement<int32_t>(Choice::VT_CONDITION_VAR_ID, condition_var_id, -1);
  }
  void add_choice_modifier(ICPDev::Gyeol::Schema::ChoiceModifier choice_modifier) {
    fbb_.AddElement<int8_t>(Choice::VT_CHOICE_MODIFIER, static_cast<int8_t>(choice_modifier), 0);
  }
  explicit ChoiceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Choice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Choice>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Choice> CreateChoice(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t text_id = 0,
    int32_t target_node_name_id = 0,
    int32_t condition_var_id = -1,
    ICPDev::Gyeol::Schema::ChoiceModifier choice_modifier = ICPDev::Gyeol::Schema::ChoiceModifier::Default) {
  ChoiceBuilder builder_(_fbb);
  builder_.add_condition_var_id(condition_var_id);
  builder_.add_target_node_name_id(target_node_name_id);
  builder_.add_text_id(text_id);
  builder_.add_choice_modifier(choice_modifier);
  return builder_.Finish();
}

struct Choice::Traits {
  using type = Choice;
  static auto constexpr Create = CreateChoice;
};

::flatbuffers::Offset<Choice> CreateChoice(::flatbuffers::FlatBufferBuilder &_fbb, const ChoiceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JumpT : public ::flatbuffers::NativeTable {
  typedef Jump TableType;
  int32_t target_node_name_id = 0;
  bool is_call = false;
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT>> arg_exprs{};
  JumpT() = default;
  JumpT(const JumpT &o);
  JumpT(JumpT&&) FLATBUFFERS_NOEXCEPT = default;
  JumpT &operator=(JumpT o) FLATBUFFERS_NOEXCEPT;
};

struct Jump FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JumpT NativeTableType;
  typedef JumpBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET_NODE_NAME_ID = 4,
    VT_IS_CALL = 6,
    VT_ARG_EXPRS = 8
  };
  int32_t target_node_name_id() const {
    return GetField<int32_t>(VT_TARGET_NODE_NAME_ID, 0);
  }
  bool is_call() const {
    return GetField<uint8_t>(VT_IS_CALL, 0) != 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression>> *arg_exprs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression>> *>(VT_ARG_EXPRS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TARGET_NODE_NAME_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_CALL, 1) &&
           VerifyOffset(verifier, VT_ARG_EXPRS) &&
           verifier.VerifyVector(arg_exprs()) &&
           verifier.VerifyVectorOfTables(arg_exprs()) &&
           verifier.EndTable();
  }
  JumpT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JumpT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Jump> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JumpT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JumpBuilder {
  typedef Jump Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target_node_name_id(int32_t target_node_name_id) {
    fbb_.AddElement<int32_t>(Jump::VT_TARGET_NODE_NAME_ID, target_node_name_id, 0);
  }
  void add_is_call(bool is_call) {
    fbb_.AddElement<uint8_t>(Jump::VT_IS_CALL, static_cast<uint8_t>(is_call), 0);
  }
  void add_arg_exprs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression>>> arg_exprs) {
    fbb_.AddOffset(Jump::VT_ARG_EXPRS, arg_exprs);
  }
  explicit JumpBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Jump> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Jump>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Jump> CreateJump(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t target_node_name_id = 0,
    bool is_call = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression>>> arg_exprs = 0) {
  JumpBuilder builder_(_fbb);
  builder_.add_arg_exprs(arg_exprs);
  builder_.add_target_node_name_id(target_node_name_id);
  builder_.add_is_call(is_call);
  return builder_.Finish();
}

struct Jump::Traits {
  using type = Jump;
  static auto constexpr Create = CreateJump;
};

inline ::flatbuffers::Offset<Jump> CreateJumpDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t target_node_name_id = 0,
    bool is_call = false,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression>> *arg_exprs = nullptr) {
  auto arg_exprs__ = arg_exprs ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression>>(*arg_exprs) : 0;
  return ICPDev::Gyeol::Schema::CreateJump(
      _fbb,
      target_node_name_id,
      is_call,
      arg_exprs__);
}

::flatbuffers::Offset<Jump> CreateJump(::flatbuffers::FlatBufferBuilder &_fbb, const JumpT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CommandT : public ::flatbuffers::NativeTable {
  typedef Command TableType;
  int32_t type_id = 0;
  std::vector<int32_t> params{};
};

struct Command FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandT NativeTableType;
  typedef CommandBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE_ID = 4,
    VT_PARAMS = 6
  };
  int32_t type_id() const {
    return GetField<int32_t>(VT_TYPE_ID, 0);
  }
  const ::flatbuffers::Vector<int32_t> *params() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PARAMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE_ID, 4) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           verifier.EndTable();
  }
  CommandT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CommandT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Command> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CommandBuilder {
  typedef Command Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type_id(int32_t type_id) {
    fbb_.AddElement<int32_t>(Command::VT_TYPE_ID, type_id, 0);
  }
  void add_params(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> params) {
    fbb_.AddOffset(Command::VT_PARAMS, params);
  }
  explicit CommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Command> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Command>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Command> CreateCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> params = 0) {
  CommandBuilder builder_(_fbb);
  builder_.add_params(params);
  builder_.add_type_id(type_id);
  return builder_.Finish();
}

struct Command::Traits {
  using type = Command;
  static auto constexpr Create = CreateCommand;
};

inline ::flatbuffers::Offset<Command> CreateCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type_id = 0,
    const std::vector<int32_t> *params = nullptr) {
  auto params__ = params ? _fbb.CreateVector<int32_t>(*params) : 0;
  return ICPDev::Gyeol::Schema::CreateCommand(
      _fbb,
      type_id,
      params__);
}

::flatbuffers::Offset<Command> CreateCommand(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExprTokenT : public ::flatbuffers::NativeTable {
  typedef ExprToken TableType;
  ICPDev::Gyeol::Schema::ExprOp op = ICPDev::Gyeol::Schema::ExprOp::PushLiteral;
  ICPDev::Gyeol::Schema::ValueDataUnion literal_value{};
  int32_t var_name_id = -1;
};

struct ExprToken FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExprTokenT NativeTableType;
  typedef ExprTokenBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP = 4,
    VT_LITERAL_VALUE_TYPE = 6,
    VT_LITERAL_VALUE = 8,
    VT_VAR_NAME_ID = 10
  };
  ICPDev::Gyeol::Schema::ExprOp op() const {
    return static_cast<ICPDev::Gyeol::Schema::ExprOp>(GetField<int8_t>(VT_OP, 0));
  }
  ICPDev::Gyeol::Schema::ValueData literal_value_type() const {
    return static_cast<ICPDev::Gyeol::Schema::ValueData>(GetField<uint8_t>(VT_LITERAL_VALUE_TYPE, 0));
  }
  const void *literal_value() const {
    return GetPointer<const void *>(VT_LITERAL_VALUE);
  }
  template<typename T> const T *literal_value_as() const;
  const ICPDev::Gyeol::Schema::BoolValue *literal_value_as_BoolValue() const {
    return literal_value_type() == ICPDev::Gyeol::Schema::ValueData::BoolValue ? static_cast<const ICPDev::Gyeol::Schema::BoolValue *>(literal_value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::IntValue *literal_value_as_IntValue() const {
    return literal_value_type() == ICPDev::Gyeol::Schema::ValueData::IntValue ? static_cast<const ICPDev::Gyeol::Schema::IntValue *>(literal_value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::FloatValue *literal_value_as_FloatValue() const {
    return literal_value_type() == ICPDev::Gyeol::Schema::ValueData::FloatValue ? static_cast<const ICPDev::Gyeol::Schema::FloatValue *>(literal_value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::StringRef *literal_value_as_StringRef() const {
    return literal_value_type() == ICPDev::Gyeol::Schema::ValueData::StringRef ? static_cast<const ICPDev::Gyeol::Schema::StringRef *>(literal_value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::ListValue *literal_value_as_ListValue() const {
    return literal_value_type() == ICPDev::Gyeol::Schema::ValueData::ListValue ? static_cast<const ICPDev::Gyeol::Schema::ListValue *>(literal_value()) : nullptr;
  }
  int32_t var_name_id() const {
    return GetField<int32_t>(VT_VAR_NAME_ID, -1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OP, 1) &&
           VerifyField<uint8_t>(verifier, VT_LITERAL_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_LITERAL_VALUE) &&
           VerifyValueData(verifier, literal_value(), literal_value_type()) &&
           VerifyField<int32_t>(verifier, VT_VAR_NAME_ID, 4) &&
           verifier.EndTable();
  }
  ExprTokenT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExprTokenT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ExprToken> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExprTokenT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ICPDev::Gyeol::Schema::BoolValue *ExprToken::literal_value_as<ICPDev::Gyeol::Schema::BoolValue>() const {
  return literal_value_as_BoolValue();
}

template<> inline const ICPDev::Gyeol::Schema::IntValue *ExprToken::literal_value_as<ICPDev::Gyeol::Schema::IntValue>() const {
  return literal_value_as_IntValue();
}

template<> inline const ICPDev::Gyeol::Schema::FloatValue *ExprToken::literal_value_as<ICPDev::Gyeol::Schema::FloatValue>() const {
  return literal_value_as_FloatValue();
}

template<> inline const ICPDev::Gyeol::Schema::StringRef *ExprToken::literal_value_as<ICPDev::Gyeol::Schema::StringRef>() const {
  return literal_value_as_StringRef();
}

template<> inline const ICPDev::Gyeol::Schema::ListValue *ExprToken::literal_value_as<ICPDev::Gyeol::Schema::ListValue>() const {
  return literal_value_as_ListValue();
}

struct ExprTokenBuilder {
  typedef ExprToken Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op(ICPDev::Gyeol::Schema::ExprOp op) {
    fbb_.AddElement<int8_t>(ExprToken::VT_OP, static_cast<int8_t>(op), 0);
  }
  void add_literal_value_type(ICPDev::Gyeol::Schema::ValueData literal_value_type) {
    fbb_.AddElement<uint8_t>(ExprToken::VT_LITERAL_VALUE_TYPE, static_cast<uint8_t>(literal_value_type), 0);
  }
  void add_literal_value(::flatbuffers::Offset<void> literal_value) {
    fbb_.AddOffset(ExprToken::VT_LITERAL_VALUE, literal_value);
  }
  void add_var_name_id(int32_t var_name_id) {
    fbb_.AddElement<int32_t>(ExprToken::VT_VAR_NAME_ID, var_name_id, -1);
  }
  explicit ExprTokenBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExprToken> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExprToken>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ExprToken> CreateExprToken(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ICPDev::Gyeol::Schema::ExprOp op = ICPDev::Gyeol::Schema::ExprOp::PushLiteral,
    ICPDev::Gyeol::Schema::ValueData literal_value_type = ICPDev::Gyeol::Schema::ValueData::NONE,
    ::flatbuffers::Offset<void> literal_value = 0,
    int32_t var_name_id = -1) {
  ExprTokenBuilder builder_(_fbb);
  builder_.add_var_name_id(var_name_id);
  builder_.add_literal_value(literal_value);
  builder_.add_literal_value_type(literal_value_type);
  builder_.add_op(op);
  return builder_.Finish();
}

struct ExprToken::Traits {
  using type = ExprToken;
  static auto constexpr Create = CreateExprToken;
};

::flatbuffers::Offset<ExprToken> CreateExprToken(::flatbuffers::FlatBufferBuilder &_fbb, const ExprTokenT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpressionT : public ::flatbuffers::NativeTable {
  typedef Expression TableType;
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::ExprTokenT>> tokens{};
  ExpressionT() = default;
  ExpressionT(const ExpressionT &o);
  ExpressionT(ExpressionT&&) FLATBUFFERS_NOEXCEPT = default;
  ExpressionT &operator=(ExpressionT o) FLATBUFFERS_NOEXCEPT;
};

struct Expression FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExpressionT NativeTableType;
  typedef ExpressionBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKENS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::ExprToken>> *tokens() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::ExprToken>> *>(VT_TOKENS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOKENS) &&
           verifier.VerifyVector(tokens()) &&
           verifier.VerifyVectorOfTables(tokens()) &&
           verifier.EndTable();
  }
  ExpressionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpressionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Expression> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExpressionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpressionBuilder {
  typedef Expression Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tokens(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::ExprToken>>> tokens) {
    fbb_.AddOffset(Expression::VT_TOKENS, tokens);
  }
  explicit ExpressionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Expression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Expression>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Expression> CreateExpression(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::ExprToken>>> tokens = 0) {
  ExpressionBuilder builder_(_fbb);
  builder_.add_tokens(tokens);
  return builder_.Finish();
}

struct Expression::Traits {
  using type = Expression;
  static auto constexpr Create = CreateExpression;
};

inline ::flatbuffers::Offset<Expression> CreateExpressionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::ExprToken>> *tokens = nullptr) {
  auto tokens__ = tokens ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::ExprToken>>(*tokens) : 0;
  return ICPDev::Gyeol::Schema::CreateExpression(
      _fbb,
      tokens__);
}

::flatbuffers::Offset<Expression> CreateExpression(::flatbuffers::FlatBufferBuilder &_fbb, const ExpressionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetVarT : public ::flatbuffers::NativeTable {
  typedef SetVar TableType;
  int32_t var_name_id = 0;
  ICPDev::Gyeol::Schema::ValueDataUnion value{};
  std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT> expr{};
  ICPDev::Gyeol::Schema::AssignOp assign_op = ICPDev::Gyeol::Schema::AssignOp::Assign;
  SetVarT() = default;
  SetVarT(const SetVarT &o);
  SetVarT(SetVarT&&) FLATBUFFERS_NOEXCEPT = default;
  SetVarT &operator=(SetVarT o) FLATBUFFERS_NOEXCEPT;
};

struct SetVar FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetVarT NativeTableType;
  typedef SetVarBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAR_NAME_ID = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8,
    VT_EXPR = 10,
    VT_ASSIGN_OP = 12
  };
  int32_t var_name_id() const {
    return GetField<int32_t>(VT_VAR_NAME_ID, 0);
  }
  ICPDev::Gyeol::Schema::ValueData value_type() const {
    return static_cast<ICPDev::Gyeol::Schema::ValueData>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const ICPDev::Gyeol::Schema::BoolValue *value_as_BoolValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::BoolValue ? static_cast<const ICPDev::Gyeol::Schema::BoolValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::IntValue *value_as_IntValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::IntValue ? static_cast<const ICPDev::Gyeol::Schema::IntValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::FloatValue *value_as_FloatValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::FloatValue ? static_cast<const ICPDev::Gyeol::Schema::FloatValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::StringRef *value_as_StringRef() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::StringRef ? static_cast<const ICPDev::Gyeol::Schema::StringRef *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::ListValue *value_as_ListValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::ListValue ? static_cast<const ICPDev::Gyeol::Schema::ListValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::Expression *expr() const {
    return GetPointer<const ICPDev::Gyeol::Schema::Expression *>(VT_EXPR);
  }
  ICPDev::Gyeol::Schema::AssignOp assign_op() const {
    return static_cast<ICPDev::Gyeol::Schema::AssignOp>(GetField<int8_t>(VT_ASSIGN_OP, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VAR_NAME_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValueData(verifier, value(), value_type()) &&
           VerifyOffset(verifier, VT_EXPR) &&
           verifier.VerifyTable(expr()) &&
           VerifyField<int8_t>(verifier, VT_ASSIGN_OP, 1) &&
           verifier.EndTable();
  }
  SetVarT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetVarT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetVar> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetVarT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ICPDev::Gyeol::Schema::BoolValue *SetVar::value_as<ICPDev::Gyeol::Schema::BoolValue>() const {
  return value_as_BoolValue();
}

template<> inline const ICPDev::Gyeol::Schema::IntValue *SetVar::value_as<ICPDev::Gyeol::Schema::IntValue>() const {
  return value_as_IntValue();
}

template<> inline const ICPDev::Gyeol::Schema::FloatValue *SetVar::value_as<ICPDev::Gyeol::Schema::FloatValue>() const {
  return value_as_FloatValue();
}

template<> inline const ICPDev::Gyeol::Schema::StringRef *SetVar::value_as<ICPDev::Gyeol::Schema::StringRef>() const {
  return value_as_StringRef();
}

template<> inline const ICPDev::Gyeol::Schema::ListValue *SetVar::value_as<ICPDev::Gyeol::Schema::ListValue>() const {
  return value_as_ListValue();
}

struct SetVarBuilder {
  typedef SetVar Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_var_name_id(int32_t var_name_id) {
    fbb_.AddElement<int32_t>(SetVar::VT_VAR_NAME_ID, var_name_id, 0);
  }
  void add_value_type(ICPDev::Gyeol::Schema::ValueData value_type) {
    fbb_.AddElement<uint8_t>(SetVar::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(SetVar::VT_VALUE, value);
  }
  void add_expr(::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> expr) {
    fbb_.AddOffset(SetVar::VT_EXPR, expr);
  }
  void add_assign_op(ICPDev::Gyeol::Schema::AssignOp assign_op) {
    fbb_.AddElement<int8_t>(SetVar::VT_ASSIGN_OP, static_cast<int8_t>(assign_op), 0);
  }
  explicit SetVarBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetVar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetVar>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetVar> CreateSetVar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t var_name_id = 0,
    ICPDev::Gyeol::Schema::ValueData value_type = ICPDev::Gyeol::Schema::ValueData::NONE,
    ::flatbuffers::Offset<void> value = 0,
    ::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> expr = 0,
    ICPDev::Gyeol::Schema::AssignOp assign_op = ICPDev::Gyeol::Schema::AssignOp::Assign) {
  SetVarBuilder builder_(_fbb);
  builder_.add_expr(expr);
  builder_.add_value(value);
  builder_.add_var_name_id(var_name_id);
  builder_.add_assign_op(assign_op);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct SetVar::Traits {
  using type = SetVar;
  static auto constexpr Create = CreateSetVar;
};

::flatbuffers::Offset<SetVar> CreateSetVar(::flatbuffers::FlatBufferBuilder &_fbb, const SetVarT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConditionT : public ::flatbuffers::NativeTable {
  typedef Condition TableType;
  int32_t var_name_id = 0;
  ICPDev::Gyeol::Schema::Operator op = ICPDev::Gyeol::Schema::Operator::Equal;
  ICPDev::Gyeol::Schema::ValueDataUnion compare_value{};
  int32_t true_jump_node_id = 0;
  int32_t false_jump_node_id = 0;
  std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT> lhs_expr{};
  std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT> rhs_expr{};
  std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT> cond_expr{};
  ConditionT() = default;
  ConditionT(const ConditionT &o);
  ConditionT(ConditionT&&) FLATBUFFERS_NOEXCEPT = default;
  ConditionT &operator=(ConditionT o) FLATBUFFERS_NOEXCEPT;
};

struct Condition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConditionT NativeTableType;
  typedef ConditionBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAR_NAME_ID = 4,
    VT_OP = 6,
    VT_COMPARE_VALUE_TYPE = 8,
    VT_COMPARE_VALUE = 10,
    VT_TRUE_JUMP_NODE_ID = 12,
    VT_FALSE_JUMP_NODE_ID = 14,
    VT_LHS_EXPR = 16,
    VT_RHS_EXPR = 18,
    VT_COND_EXPR = 20
  };
  int32_t var_name_id() const {
    return GetField<int32_t>(VT_VAR_NAME_ID, 0);
  }
  ICPDev::Gyeol::Schema::Operator op() const {
    return static_cast<ICPDev::Gyeol::Schema::Operator>(GetField<int8_t>(VT_OP, 0));
  }
  ICPDev::Gyeol::Schema::ValueData compare_value_type() const {
    return static_cast<ICPDev::Gyeol::Schema::ValueData>(GetField<uint8_t>(VT_COMPARE_VALUE_TYPE, 0));
  }
  const void *compare_value() const {
    return GetPointer<const void *>(VT_COMPARE_VALUE);
  }
  template<typename T> const T *compare_value_as() const;
  const ICPDev::Gyeol::Schema::BoolValue *compare_value_as_BoolValue() const {
    return compare_value_type() == ICPDev::Gyeol::Schema::ValueData::BoolValue ? static_cast<const ICPDev::Gyeol::Schema::BoolValue *>(compare_value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::IntValue *compare_value_as_IntValue() const {
    return compare_value_type() == ICPDev::Gyeol::Schema::ValueData::IntValue ? static_cast<const ICPDev::Gyeol::Schema::IntValue *>(compare_value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::FloatValue *compare_value_as_FloatValue() const {
    return compare_value_type() == ICPDev::Gyeol::Schema::ValueData::FloatValue ? static_cast<const ICPDev::Gyeol::Schema::FloatValue *>(compare_value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::StringRef *compare_value_as_StringRef() const {
    return compare_value_type() == ICPDev::Gyeol::Schema::ValueData::StringRef ? static_cast<const ICPDev::Gyeol::Schema::StringRef *>(compare_value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::ListValue *compare_value_as_ListValue() const {
    return compare_value_type() == ICPDev::Gyeol::Schema::ValueData::ListValue ? static_cast<const ICPDev::Gyeol::Schema::ListValue *>(compare_value()) : nullptr;
  }
  int32_t true_jump_node_id() const {
    return GetField<int32_t>(VT_TRUE_JUMP_NODE_ID, 0);
  }
  int32_t false_jump_node_id() const {
    return GetField<int32_t>(VT_FALSE_JUMP_NODE_ID, 0);
  }
  const ICPDev::Gyeol::Schema::Expression *lhs_expr() const {
    return GetPointer<const ICPDev::Gyeol::Schema::Expression *>(VT_LHS_EXPR);
  }
  const ICPDev::Gyeol::Schema::Expression *rhs_expr() const {
    return GetPointer<const ICPDev::Gyeol::Schema::Expression *>(VT_RHS_EXPR);
  }
  const ICPDev::Gyeol::Schema::Expression *cond_expr() const {
    return GetPointer<const ICPDev::Gyeol::Schema::Expression *>(VT_COND_EXPR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VAR_NAME_ID, 4) &&
           VerifyField<int8_t>(verifier, VT_OP, 1) &&
           VerifyField<uint8_t>(verifier, VT_COMPARE_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPARE_VALUE) &&
           VerifyValueData(verifier, compare_value(), compare_value_type()) &&
           VerifyField<int32_t>(verifier, VT_TRUE_JUMP_NODE_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_FALSE_JUMP_NODE_ID, 4) &&
           VerifyOffset(verifier, VT_LHS_EXPR) &&
           verifier.VerifyTable(lhs_expr()) &&
           VerifyOffset(verifier, VT_RHS_EXPR) &&
           verifier.VerifyTable(rhs_expr()) &&
           VerifyOffset(verifier, VT_COND_EXPR) &&
           verifier.VerifyTable(cond_expr()) &&
           verifier.EndTable();
  }
  ConditionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConditionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Condition> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConditionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ICPDev::Gyeol::Schema::BoolValue *Condition::compare_value_as<ICPDev::Gyeol::Schema::BoolValue>() const {
  return compare_value_as_BoolValue();
}

template<> inline const ICPDev::Gyeol::Schema::IntValue *Condition::compare_value_as<ICPDev::Gyeol::Schema::IntValue>() const {
  return compare_value_as_IntValue();
}

template<> inline const ICPDev::Gyeol::Schema::FloatValue *Condition::compare_value_as<ICPDev::Gyeol::Schema::FloatValue>() const {
  return compare_value_as_FloatValue();
}

template<> inline const ICPDev::Gyeol::Schema::StringRef *Condition::compare_value_as<ICPDev::Gyeol::Schema::StringRef>() const {
  return compare_value_as_StringRef();
}

template<> inline const ICPDev::Gyeol::Schema::ListValue *Condition::compare_value_as<ICPDev::Gyeol::Schema::ListValue>() const {
  return compare_value_as_ListValue();
}

struct ConditionBuilder {
  typedef Condition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_var_name_id(int32_t var_name_id) {
    fbb_.AddElement<int32_t>(Condition::VT_VAR_NAME_ID, var_name_id, 0);
  }
  void add_op(ICPDev::Gyeol::Schema::Operator op) {
    fbb_.AddElement<int8_t>(Condition::VT_OP, static_cast<int8_t>(op), 0);
  }
  void add_compare_value_type(ICPDev::Gyeol::Schema::ValueData compare_value_type) {
    fbb_.AddElement<uint8_t>(Condition::VT_COMPARE_VALUE_TYPE, static_cast<uint8_t>(compare_value_type), 0);
  }
  void add_compare_value(::flatbuffers::Offset<void> compare_value) {
    fbb_.AddOffset(Condition::VT_COMPARE_VALUE, compare_value);
  }
  void add_true_jump_node_id(int32_t true_jump_node_id) {
    fbb_.AddElement<int32_t>(Condition::VT_TRUE_JUMP_NODE_ID, true_jump_node_id, 0);
  }
  void add_false_jump_node_id(int32_t false_jump_node_id) {
    fbb_.AddElement<int32_t>(Condition::VT_FALSE_JUMP_NODE_ID, false_jump_node_id, 0);
  }
  void add_lhs_expr(::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> lhs_expr) {
    fbb_.AddOffset(Condition::VT_LHS_EXPR, lhs_expr);
  }
  void add_rhs_expr(::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> rhs_expr) {
    fbb_.AddOffset(Condition::VT_RHS_EXPR, rhs_expr);
  }
  void add_cond_expr(::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> cond_expr) {
    fbb_.AddOffset(Condition::VT_COND_EXPR, cond_expr);
  }
  explicit ConditionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Condition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Condition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Condition> CreateCondition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t var_name_id = 0,
    ICPDev::Gyeol::Schema::Operator op = ICPDev::Gyeol::Schema::Operator::Equal,
    ICPDev::Gyeol::Schema::ValueData compare_value_type = ICPDev::Gyeol::Schema::ValueData::NONE,
    ::flatbuffers::Offset<void> compare_value = 0,
    int32_t true_jump_node_id = 0,
    int32_t false_jump_node_id = 0,
    ::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> lhs_expr = 0,
    ::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> rhs_expr = 0,
    ::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> cond_expr = 0) {
  ConditionBuilder builder_(_fbb);
  builder_.add_cond_expr(cond_expr);
  builder_.add_rhs_expr(rhs_expr);
  builder_.add_lhs_expr(lhs_expr);
  builder_.add_false_jump_node_id(false_jump_node_id);
  builder_.add_true_jump_node_id(true_jump_node_id);
  builder_.add_compare_value(compare_value);
  builder_.add_var_name_id(var_name_id);
  builder_.add_compare_value_type(compare_value_type);
  builder_.add_op(op);
  return builder_.Finish();
}

struct Condition::Traits {
  using type = Condition;
  static auto constexpr Create = CreateCondition;
};

::flatbuffers::Offset<Condition> CreateCondition(::flatbuffers::FlatBufferBuilder &_fbb, const ConditionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RandomBranchT : public ::flatbuffers::NativeTable {
  typedef RandomBranch TableType;
  int32_t target_node_name_id = 0;
  int32_t weight = 1;
};

struct RandomBranch FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RandomBranchT NativeTableType;
  typedef RandomBranchBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET_NODE_NAME_ID = 4,
    VT_WEIGHT = 6
  };
  int32_t target_node_name_id() const {
    return GetField<int32_t>(VT_TARGET_NODE_NAME_ID, 0);
  }
  int32_t weight() const {
    return GetField<int32_t>(VT_WEIGHT, 1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TARGET_NODE_NAME_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_WEIGHT, 4) &&
           verifier.EndTable();
  }
  RandomBranchT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RandomBranchT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RandomBranch> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RandomBranchT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RandomBranchBuilder {
  typedef RandomBranch Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target_node_name_id(int32_t target_node_name_id) {
    fbb_.AddElement<int32_t>(RandomBranch::VT_TARGET_NODE_NAME_ID, target_node_name_id, 0);
  }
  void add_weight(int32_t weight) {
    fbb_.AddElement<int32_t>(RandomBranch::VT_WEIGHT, weight, 1);
  }
  explicit RandomBranchBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RandomBranch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RandomBranch>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RandomBranch> CreateRandomBranch(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t target_node_name_id = 0,
    int32_t weight = 1) {
  RandomBranchBuilder builder_(_fbb);
  builder_.add_weight(weight);
  builder_.add_target_node_name_id(target_node_name_id);
  return builder_.Finish();
}

struct RandomBranch::Traits {
  using type = RandomBranch;
  static auto constexpr Create = CreateRandomBranch;
};

::flatbuffers::Offset<RandomBranch> CreateRandomBranch(::flatbuffers::FlatBufferBuilder &_fbb, const RandomBranchT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RandomT : public ::flatbuffers::NativeTable {
  typedef Random TableType;
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::RandomBranchT>> branches{};
  RandomT() = default;
  RandomT(const RandomT &o);
  RandomT(RandomT&&) FLATBUFFERS_NOEXCEPT = default;
  RandomT &operator=(RandomT o) FLATBUFFERS_NOEXCEPT;
};

struct Random FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RandomT NativeTableType;
  typedef RandomBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BRANCHES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::RandomBranch>> *branches() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::RandomBranch>> *>(VT_BRANCHES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BRANCHES) &&
           verifier.VerifyVector(branches()) &&
           verifier.VerifyVectorOfTables(branches()) &&
           verifier.EndTable();
  }
  RandomT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RandomT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Random> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RandomT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RandomBuilder {
  typedef Random Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_branches(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::RandomBranch>>> branches) {
    fbb_.AddOffset(Random::VT_BRANCHES, branches);
  }
  explicit RandomBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Random> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Random>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Random> CreateRandom(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::RandomBranch>>> branches = 0) {
  RandomBuilder builder_(_fbb);
  builder_.add_branches(branches);
  return builder_.Finish();
}

struct Random::Traits {
  using type = Random;
  static auto constexpr Create = CreateRandom;
};

inline ::flatbuffers::Offset<Random> CreateRandomDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::RandomBranch>> *branches = nullptr) {
  auto branches__ = branches ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::RandomBranch>>(*branches) : 0;
  return ICPDev::Gyeol::Schema::CreateRandom(
      _fbb,
      branches__);
}

::flatbuffers::Offset<Random> CreateRandom(::flatbuffers::FlatBufferBuilder &_fbb, const RandomT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReturnT : public ::flatbuffers::NativeTable {
  typedef Return TableType;
  std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT> expr{};
  ICPDev::Gyeol::Schema::ValueDataUnion value{};
  ReturnT() = default;
  ReturnT(const ReturnT &o);
  ReturnT(ReturnT&&) FLATBUFFERS_NOEXCEPT = default;
  ReturnT &operator=(ReturnT o) FLATBUFFERS_NOEXCEPT;
};

struct Return FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReturnT NativeTableType;
  typedef ReturnBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXPR = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const ICPDev::Gyeol::Schema::Expression *expr() const {
    return GetPointer<const ICPDev::Gyeol::Schema::Expression *>(VT_EXPR);
  }
  ICPDev::Gyeol::Schema::ValueData value_type() const {
    return static_cast<ICPDev::Gyeol::Schema::ValueData>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const ICPDev::Gyeol::Schema::BoolValue *value_as_BoolValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::BoolValue ? static_cast<const ICPDev::Gyeol::Schema::BoolValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::IntValue *value_as_IntValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::IntValue ? static_cast<const ICPDev::Gyeol::Schema::IntValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::FloatValue *value_as_FloatValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::FloatValue ? static_cast<const ICPDev::Gyeol::Schema::FloatValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::StringRef *value_as_StringRef() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::StringRef ? static_cast<const ICPDev::Gyeol::Schema::StringRef *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::ListValue *value_as_ListValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::ListValue ? static_cast<const ICPDev::Gyeol::Schema::ListValue *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EXPR) &&
           verifier.VerifyTable(expr()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValueData(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
  ReturnT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReturnT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Return> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReturnT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ICPDev::Gyeol::Schema::BoolValue *Return::value_as<ICPDev::Gyeol::Schema::BoolValue>() const {
  return value_as_BoolValue();
}

template<> inline const ICPDev::Gyeol::Schema::IntValue *Return::value_as<ICPDev::Gyeol::Schema::IntValue>() const {
  return value_as_IntValue();
}

template<> inline const ICPDev::Gyeol::Schema::FloatValue *Return::value_as<ICPDev::Gyeol::Schema::FloatValue>() const {
  return value_as_FloatValue();
}

template<> inline const ICPDev::Gyeol::Schema::StringRef *Return::value_as<ICPDev::Gyeol::Schema::StringRef>() const {
  return value_as_StringRef();
}

template<> inline const ICPDev::Gyeol::Schema::ListValue *Return::value_as<ICPDev::Gyeol::Schema::ListValue>() const {
  return value_as_ListValue();
}

struct ReturnBuilder {
  typedef Return Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_expr(::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> expr) {
    fbb_.AddOffset(Return::VT_EXPR, expr);
  }
  void add_value_type(ICPDev::Gyeol::Schema::ValueData value_type) {
    fbb_.AddElement<uint8_t>(Return::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Return::VT_VALUE, value);
  }
  explicit ReturnBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Return> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Return>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Return> CreateReturn(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> expr = 0,
    ICPDev::Gyeol::Schema::ValueData value_type = ICPDev::Gyeol::Schema::ValueData::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  ReturnBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_expr(expr);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct Return::Traits {
  using type = Return;
  static auto constexpr Create = CreateReturn;
};

::flatbuffers::Offset<Return> CreateReturn(::flatbuffers::FlatBufferBuilder &_fbb, const ReturnT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CallWithReturnT : public ::flatbuffers::NativeTable {
  typedef CallWithReturn TableType;
  int32_t target_node_name_id = 0;
  int32_t return_var_name_id = 0;
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT>> arg_exprs{};
  CallWithReturnT() = default;
  CallWithReturnT(const CallWithReturnT &o);
  CallWithReturnT(CallWithReturnT&&) FLATBUFFERS_NOEXCEPT = default;
  CallWithReturnT &operator=(CallWithReturnT o) FLATBUFFERS_NOEXCEPT;
};

struct CallWithReturn FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CallWithReturnT NativeTableType;
  typedef CallWithReturnBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET_NODE_NAME_ID = 4,
    VT_RETURN_VAR_NAME_ID = 6,
    VT_ARG_EXPRS = 8
  };
  int32_t target_node_name_id() const {
    return GetField<int32_t>(VT_TARGET_NODE_NAME_ID, 0);
  }
  int32_t return_var_name_id() const {
    return GetField<int32_t>(VT_RETURN_VAR_NAME_ID, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression>> *arg_exprs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression>> *>(VT_ARG_EXPRS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TARGET_NODE_NAME_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_RETURN_VAR_NAME_ID, 4) &&
           VerifyOffset(verifier, VT_ARG_EXPRS) &&
           verifier.VerifyVector(arg_exprs()) &&
           verifier.VerifyVectorOfTables(arg_exprs()) &&
           verifier.EndTable();
  }
  CallWithReturnT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CallWithReturnT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CallWithReturn> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CallWithReturnT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CallWithReturnBuilder {
  typedef CallWithReturn Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target_node_name_id(int32_t target_node_name_id) {
    fbb_.AddElement<int32_t>(CallWithReturn::VT_TARGET_NODE_NAME_ID, target_node_name_id, 0);
  }
  void add_return_var_name_id(int32_t return_var_name_id) {
    fbb_.AddElement<int32_t>(CallWithReturn::VT_RETURN_VAR_NAME_ID, return_var_name_id, 0);
  }
  void add_arg_exprs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression>>> arg_exprs) {
    fbb_.AddOffset(CallWithReturn::VT_ARG_EXPRS, arg_exprs);
  }
  explicit CallWithReturnBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CallWithReturn> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CallWithReturn>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CallWithReturn> CreateCallWithReturn(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t target_node_name_id = 0,
    int32_t return_var_name_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression>>> arg_exprs = 0) {
  CallWithReturnBuilder builder_(_fbb);
  builder_.add_arg_exprs(arg_exprs);
  builder_.add_return_var_name_id(return_var_name_id);
  builder_.add_target_node_name_id(target_node_name_id);
  return builder_.Finish();
}

struct CallWithReturn::Traits {
  using type = CallWithReturn;
  static auto constexpr Create = CreateCallWithReturn;
};

inline ::flatbuffers::Offset<CallWithReturn> CreateCallWithReturnDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t target_node_name_id = 0,
    int32_t return_var_name_id = 0,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression>> *arg_exprs = nullptr) {
  auto arg_exprs__ = arg_exprs ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression>>(*arg_exprs) : 0;
  return ICPDev::Gyeol::Schema::CreateCallWithReturn(
      _fbb,
      target_node_name_id,
      return_var_name_id,
      arg_exprs__);
}

::flatbuffers::Offset<CallWithReturn> CreateCallWithReturn(::flatbuffers::FlatBufferBuilder &_fbb, const CallWithReturnT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CharacterDefT : public ::flatbuffers::NativeTable {
  typedef CharacterDef TableType;
  int32_t name_id = 0;
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::TagT>> properties{};
  CharacterDefT() = default;
  CharacterDefT(const CharacterDefT &o);
  CharacterDefT(CharacterDefT&&) FLATBUFFERS_NOEXCEPT = default;
  CharacterDefT &operator=(CharacterDefT o) FLATBUFFERS_NOEXCEPT;
};

struct CharacterDef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CharacterDefT NativeTableType;
  typedef CharacterDefBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME_ID = 4,
    VT_PROPERTIES = 6
  };
  int32_t name_id() const {
    return GetField<int32_t>(VT_NAME_ID, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>> *properties() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>> *>(VT_PROPERTIES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NAME_ID, 4) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           verifier.EndTable();
  }
  CharacterDefT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CharacterDefT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CharacterDef> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CharacterDefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CharacterDefBuilder {
  typedef CharacterDef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name_id(int32_t name_id) {
    fbb_.AddElement<int32_t>(CharacterDef::VT_NAME_ID, name_id, 0);
  }
  void add_properties(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>>> properties) {
    fbb_.AddOffset(CharacterDef::VT_PROPERTIES, properties);
  }
  explicit CharacterDefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CharacterDef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CharacterDef>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CharacterDef> CreateCharacterDef(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t name_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>>> properties = 0) {
  CharacterDefBuilder builder_(_fbb);
  builder_.add_properties(properties);
  builder_.add_name_id(name_id);
  return builder_.Finish();
}

struct CharacterDef::Traits {
  using type = CharacterDef;
  static auto constexpr Create = CreateCharacterDef;
};

inline ::flatbuffers::Offset<CharacterDef> CreateCharacterDefDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t name_id = 0,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>> *properties = nullptr) {
  auto properties__ = properties ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>>(*properties) : 0;
  return ICPDev::Gyeol::Schema::CreateCharacterDef(
      _fbb,
      name_id,
      properties__);
}

::flatbuffers::Offset<CharacterDef> CreateCharacterDef(::flatbuffers::FlatBufferBuilder &_fbb, const CharacterDefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InstructionT : public ::flatbuffers::NativeTable {
  typedef Instruction TableType;
  ICPDev::Gyeol::Schema::OpDataUnion data{};
};

struct Instruction FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InstructionT NativeTableType;
  typedef InstructionBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_DATA = 6
  };
  ICPDev::Gyeol::Schema::OpData data_type() const {
    return static_cast<ICPDev::Gyeol::Schema::OpData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const ICPDev::Gyeol::Schema::Line *data_as_Line() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Line ? static_cast<const ICPDev::Gyeol::Schema::Line *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::Choice *data_as_Choice() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Choice ? static_cast<const ICPDev::Gyeol::Schema::Choice *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::Jump *data_as_Jump() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Jump ? static_cast<const ICPDev::Gyeol::Schema::Jump *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::Command *data_as_Command() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Command ? static_cast<const ICPDev::Gyeol::Schema::Command *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::SetVar *data_as_SetVar() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::SetVar ? static_cast<const ICPDev::Gyeol::Schema::SetVar *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::Condition *data_as_Condition() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Condition ? static_cast<const ICPDev::Gyeol::Schema::Condition *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::Random *data_as_Random() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Random ? static_cast<const ICPDev::Gyeol::Schema::Random *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::Return *data_as_Return() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Return ? static_cast<const ICPDev::Gyeol::Schema::Return *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::CallWithReturn *data_as_CallWithReturn() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::CallWithReturn ? static_cast<const ICPDev::Gyeol::Schema::CallWithReturn *>(data()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyOpData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
  InstructionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InstructionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Instruction> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InstructionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ICPDev::Gyeol::Schema::Line *Instruction::data_as<ICPDev::Gyeol::Schema::Line>() const {
  return data_as_Line();
}

template<> inline const ICPDev::Gyeol::Schema::Choice *Instruction::data_as<ICPDev::Gyeol::Schema::Choice>() const {
  return data_as_Choice();
}

template<> inline const ICPDev::Gyeol::Schema::Jump *Instruction::data_as<ICPDev::Gyeol::Schema::Jump>() const {
  return data_as_Jump();
}

template<> inline const ICPDev::Gyeol::Schema::Command *Instruction::data_as<ICPDev::Gyeol::Schema::Command>() const {
  return data_as_Command();
}

template<> inline const ICPDev::Gyeol::Schema::SetVar *Instruction::data_as<ICPDev::Gyeol::Schema::SetVar>() const {
  return data_as_SetVar();
}

template<> inline const ICPDev::Gyeol::Schema::Condition *Instruction::data_as<ICPDev::Gyeol::Schema::Condition>() const {
  return data_as_Condition();
}

template<> inline const ICPDev::Gyeol::Schema::Random *Instruction::data_as<ICPDev::Gyeol::Schema::Random>() const {
  return data_as_Random();
}

template<> inline const ICPDev::Gyeol::Schema::Return *Instruction::data_as<ICPDev::Gyeol::Schema::Return>() const {
  return data_as_Return();
}

template<> inline const ICPDev::Gyeol::Schema::CallWithReturn *Instruction::data_as<ICPDev::Gyeol::Schema::CallWithReturn>() const {
  return data_as_CallWithReturn();
}

struct InstructionBuilder {
  typedef Instruction Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data_type(ICPDev::Gyeol::Schema::OpData data_type) {
    fbb_.AddElement<uint8_t>(Instruction::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(::flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Instruction::VT_DATA, data);
  }
  explicit InstructionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Instruction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Instruction>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Instruction> CreateInstruction(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ICPDev::Gyeol::Schema::OpData data_type = ICPDev::Gyeol::Schema::OpData::NONE,
    ::flatbuffers::Offset<void> data = 0) {
  InstructionBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

struct Instruction::Traits {
  using type = Instruction;
  static auto constexpr Create = CreateInstruction;
};

::flatbuffers::Offset<Instruction> CreateInstruction(::flatbuffers::FlatBufferBuilder &_fbb, const InstructionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NodeT : public ::flatbuffers::NativeTable {
  typedef Node TableType;
  std::string name{};
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::InstructionT>> lines{};
  std::vector<int32_t> param_ids{};
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::TagT>> tags{};
  NodeT() = default;
  NodeT(const NodeT &o);
  NodeT(NodeT&&) FLATBUFFERS_NOEXCEPT = default;
  NodeT &operator=(NodeT o) FLATBUFFERS_NOEXCEPT;
};

struct Node FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NodeT NativeTableType;
  typedef NodeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_LINES = 6,
    VT_PARAM_IDS = 8,
    VT_TAGS = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const Node * const o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *_name) const {
    return strcmp(name()->c_str(), _name);
  }
  template<typename StringType>
  int KeyCompareWithValue(const StringType& _name) const {
    if (name()->c_str() < _name) return -1;
    if (_name < name()->c_str()) return 1;
    return 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>> *lines() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>> *>(VT_LINES);
  }
  const ::flatbuffers::Vector<int32_t> *param_ids() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PARAM_IDS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>> *tags() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>> *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_LINES) &&
           verifier.VerifyVector(lines()) &&
           verifier.VerifyVectorOfTables(lines()) &&
           VerifyOffset(verifier, VT_PARAM_IDS) &&
           verifier.VerifyVector(param_ids()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfTables(tags()) &&
           verifier.EndTable();
  }
  NodeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NodeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Node> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NodeBuilder {
  typedef Node Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Node::VT_NAME, name);
  }
  void add_lines(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>>> lines) {
    fbb_.AddOffset(Node::VT_LINES, lines);
  }
  void add_param_ids(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> param_ids) {
    fbb_.AddOffset(Node::VT_PARAM_IDS, param_ids);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>>> tags) {
    fbb_.AddOffset(Node::VT_TAGS, tags);
  }
  explicit NodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Node>(end);
    fbb_.Required(o, Node::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<Node> CreateNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>>> lines = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> param_ids = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>>> tags = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_tags(tags);
  builder_.add_param_ids(param_ids);
  builder_.add_lines(lines);
  builder_.add_name(name);
  return builder_.Finish();
}

struct Node::Traits {
  using type = Node;
  static auto constexpr Create = CreateNode;
};

inline ::flatbuffers::Offset<Node> CreateNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>> *lines = nullptr,
    const std::vector<int32_t> *param_ids = nullptr,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>> *tags = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto lines__ = lines ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>>(*lines) : 0;
  auto param_ids__ = param_ids ? _fbb.CreateVector<int32_t>(*param_ids) : 0;
  auto tags__ = tags ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>>(*tags) : 0;
  return ICPDev::Gyeol::Schema::CreateNode(
      _fbb,
      name__,
      lines__,
      param_ids__,
      tags__);
}

::flatbuffers::Offset<Node> CreateNode(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SavedVarT : public ::flatbuffers::NativeTable {
  typedef SavedVar TableType;
  std::string name{};
  ICPDev::Gyeol::Schema::ValueDataUnion value{};
  std::string string_value{};
  std::vector<std::string> list_items{};
};

struct SavedVar FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SavedVarT NativeTableType;
  typedef SavedVarBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8,
    VT_STRING_VALUE = 10,
    VT_LIST_ITEMS = 12
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ICPDev::Gyeol::Schema::ValueData value_type() const {
    return static_cast<ICPDev::Gyeol::Schema::ValueData>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const ICPDev::Gyeol::Schema::BoolValue *value_as_BoolValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::BoolValue ? static_cast<const ICPDev::Gyeol::Schema::BoolValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::IntValue *value_as_IntValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::IntValue ? static_cast<const ICPDev::Gyeol::Schema::IntValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::FloatValue *value_as_FloatValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::FloatValue ? static_cast<const ICPDev::Gyeol::Schema::FloatValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::StringRef *value_as_StringRef() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::StringRef ? static_cast<const ICPDev::Gyeol::Schema::StringRef *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::ListValue *value_as_ListValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::ListValue ? static_cast<const ICPDev::Gyeol::Schema::ListValue *>(value()) : nullptr;
  }
  const ::flatbuffers::String *string_value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STRING_VALUE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *list_items() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_LIST_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValueData(verifier, value(), value_type()) &&
           VerifyOffset(verifier, VT_STRING_VALUE) &&
           verifier.VerifyString(string_value()) &&
           VerifyOffset(verifier, VT_LIST_ITEMS) &&
           verifier.VerifyVector(list_items()) &&
           verifier.VerifyVectorOfStrings(list_items()) &&
           verifier.EndTable();
  }
  SavedVarT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SavedVarT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SavedVar> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SavedVarT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ICPDev::Gyeol::Schema::BoolValue *SavedVar::value_as<ICPDev::Gyeol::Schema::BoolValue>() const {
  return value_as_BoolValue();
}

template<> inline const ICPDev::Gyeol::Schema::IntValue *SavedVar::value_as<ICPDev::Gyeol::Schema::IntValue>() const {
  return value_as_IntValue();
}

template<> inline const ICPDev::Gyeol::Schema::FloatValue *SavedVar::value_as<ICPDev::Gyeol::Schema::FloatValue>() const {
  return value_as_FloatValue();
}

template<> inline const ICPDev::Gyeol::Schema::StringRef *SavedVar::value_as<ICPDev::Gyeol::Schema::StringRef>() const {
  return value_as_StringRef();
}

template<> inline const ICPDev::Gyeol::Schema::ListValue *SavedVar::value_as<ICPDev::Gyeol::Schema::ListValue>() const {
  return value_as_ListValue();
}

struct SavedVarBuilder {
  typedef SavedVar Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SavedVar::VT_NAME, name);
  }
  void add_value_type(ICPDev::Gyeol::Schema::ValueData value_type) {
    fbb_.AddElement<uint8_t>(SavedVar::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(SavedVar::VT_VALUE, value);
  }
  void add_string_value(::flatbuffers::Offset<::flatbuffers::String> string_value) {
    fbb_.AddOffset(SavedVar::VT_STRING_VALUE, string_value);
  }
  void add_list_items(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> list_items) {
    fbb_.AddOffset(SavedVar::VT_LIST_ITEMS, list_items);
  }
  explicit SavedVarBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SavedVar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SavedVar>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SavedVar> CreateSavedVar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ICPDev::Gyeol::Schema::ValueData value_type = ICPDev::Gyeol::Schema::ValueData::NONE,
    ::flatbuffers::Offset<void> value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> string_value = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> list_items = 0) {
  SavedVarBuilder builder_(_fbb);
  builder_.add_list_items(list_items);
  builder_.add_string_value(string_value);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct SavedVar::Traits {
  using type = SavedVar;
  static auto constexpr Create = CreateSavedVar;
};

inline ::flatbuffers::Offset<SavedVar> CreateSavedVarDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ICPDev::Gyeol::Schema::ValueData value_type = ICPDev::Gyeol::Schema::ValueData::NONE,
    ::flatbuffers::Offset<void> value = 0,
    const char *string_value = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *list_items = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto string_value__ = string_value ? _fbb.CreateString(string_value) : 0;
  auto list_items__ = list_items ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*list_items) : 0;
  return ICPDev::Gyeol::Schema::CreateSavedVar(
      _fbb,
      name__,
      value_type,
      value,
      string_value__,
      list_items__);
}

::flatbuffers::Offset<SavedVar> CreateSavedVar(::flatbuffers::FlatBufferBuilder &_fbb, const SavedVarT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SavedShadowedVarT : public ::flatbuffers::NativeTable {
  typedef SavedShadowedVar TableType;
  std::string name{};
  ICPDev::Gyeol::Schema::ValueDataUnion value{};
  std::string string_value{};
  bool existed = true;
  std::vector<std::string> list_items{};
};

struct SavedShadowedVar FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SavedShadowedVarT NativeTableType;
  typedef SavedShadowedVarBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8,
    VT_STRING_VALUE = 10,
    VT_EXISTED = 12,
    VT_LIST_ITEMS = 14
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ICPDev::Gyeol::Schema::ValueData value_type() const {
    return static_cast<ICPDev::Gyeol::Schema::ValueData>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const ICPDev::Gyeol::Schema::BoolValue *value_as_BoolValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::BoolValue ? static_cast<const ICPDev::Gyeol::Schema::BoolValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::IntValue *value_as_IntValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::IntValue ? static_cast<const ICPDev::Gyeol::Schema::IntValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::FloatValue *value_as_FloatValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::FloatValue ? static_cast<const ICPDev::Gyeol::Schema::FloatValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::StringRef *value_as_StringRef() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::StringRef ? static_cast<const ICPDev::Gyeol::Schema::StringRef *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::ListValue *value_as_ListValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::ListValue ? static_cast<const ICPDev::Gyeol::Schema::ListValue *>(value()) : nullptr;
  }
  const ::flatbuffers::String *string_value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STRING_VALUE);
  }
  bool existed() const {
    return GetField<uint8_t>(VT_EXISTED, 1) != 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *list_items() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_LIST_ITEMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValueData(verifier, value(), value_type()) &&
           VerifyOffset(verifier, VT_STRING_VALUE) &&
           verifier.VerifyString(string_value()) &&
           VerifyField<uint8_t>(verifier, VT_EXISTED, 1) &&
           VerifyOffset(verifier, VT_LIST_ITEMS) &&
           verifier.VerifyVector(list_items()) &&
           verifier.VerifyVectorOfStrings(list_items()) &&
           verifier.EndTable();
  }
  SavedShadowedVarT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SavedShadowedVarT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SavedShadowedVar> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SavedShadowedVarT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ICPDev::Gyeol::Schema::BoolValue *SavedShadowedVar::value_as<ICPDev::Gyeol::Schema::BoolValue>() const {
  return value_as_BoolValue();
}

template<> inline const ICPDev::Gyeol::Schema::IntValue *SavedShadowedVar::value_as<ICPDev::Gyeol::Schema::IntValue>() const {
  return value_as_IntValue();
}

template<> inline const ICPDev::Gyeol::Schema::FloatValue *SavedShadowedVar::value_as<ICPDev::Gyeol::Schema::FloatValue>() const {
  return value_as_FloatValue();
}

template<> inline const ICPDev::Gyeol::Schema::StringRef *SavedShadowedVar::value_as<ICPDev::Gyeol::Schema::StringRef>() const {
  return value_as_StringRef();
}

template<> inline const ICPDev::Gyeol::Schema::ListValue *SavedShadowedVar::value_as<ICPDev::Gyeol::Schema::ListValue>() const {
  return value_as_ListValue();
}

struct SavedShadowedVarBuilder {
  typedef SavedShadowedVar Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SavedShadowedVar::VT_NAME, name);
  }
  void add_value_type(ICPDev::Gyeol::Schema::ValueData value_type) {
    fbb_.AddElement<uint8_t>(SavedShadowedVar::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(SavedShadowedVar::VT_VALUE, value);
  }
  void add_string_value(::flatbuffers::Offset<::flatbuffers::String> string_value) {
    fbb_.AddOffset(SavedShadowedVar::VT_STRING_VALUE, string_value);
  }
  void add_existed(bool existed) {
    fbb_.AddElement<uint8_t>(SavedShadowedVar::VT_EXISTED, static_cast<uint8_t>(existed), 1);
  }
  void add_list_items(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> list_items) {
    fbb_.AddOffset(SavedShadowedVar::VT_LIST_ITEMS, list_items);
  }
  explicit SavedShadowedVarBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SavedShadowedVar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SavedShadowedVar>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SavedShadowedVar> CreateSavedShadowedVar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ICPDev::Gyeol::Schema::ValueData value_type = ICPDev::Gyeol::Schema::ValueData::NONE,
    ::flatbuffers::Offset<void> value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> string_value = 0,
    bool existed = true,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> list_items = 0) {
  SavedShadowedVarBuilder builder_(_fbb);
  builder_.add_list_items(list_items);
  builder_.add_string_value(string_value);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_existed(existed);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct SavedShadowedVar::Traits {
  using type = SavedShadowedVar;
  static auto constexpr Create = CreateSavedShadowedVar;
};

inline ::flatbuffers::Offset<SavedShadowedVar> CreateSavedShadowedVarDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ICPDev::Gyeol::Schema::ValueData value_type = ICPDev::Gyeol::Schema::ValueData::NONE,
    ::flatbuffers::Offset<void> value = 0,
    const char *string_value = nullptr,
    bool existed = true,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *list_items = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto string_value__ = string_value ? _fbb.CreateString(string_value) : 0;
  auto list_items__ = list_items ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*list_items) : 0;
  return ICPDev::Gyeol::Schema::CreateSavedShadowedVar(
      _fbb,
      name__,
      value_type,
      value,
      string_value__,
      existed,
      list_items__);
}

::flatbuffers::Offset<SavedShadowedVar> CreateSavedShadowedVar(::flatbuffers::FlatBufferBuilder &_fbb, const SavedShadowedVarT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SavedCallFrameT : public ::flatbuffers::NativeTable {
  typedef SavedCallFrame TableType;
  std::string node_name{};
  uint32_t pc = 0;
  std::string return_var_name{};
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::SavedShadowedVarT>> shadowed_vars{};
  std::vector<std::string> param_names{};
  SavedCallFrameT() = default;
  SavedCallFrameT(const SavedCallFrameT &o);
  SavedCallFrameT(SavedCallFrameT&&) FLATBUFFERS_NOEXCEPT = default;
  SavedCallFrameT &operator=(SavedCallFrameT o) FLATBUFFERS_NOEXCEPT;
};

struct SavedCallFrame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SavedCallFrameT NativeTableType;
  typedef SavedCallFrameBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE_NAME = 4,
    VT_PC = 6,
    VT_RETURN_VAR_NAME = 8,
    VT_SHADOWED_VARS = 10,
    VT_PARAM_NAMES = 12
  };
  const ::flatbuffers::String *node_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NODE_NAME);
  }
  uint32_t pc() const {
    return GetField<uint32_t>(VT_PC, 0);
  }
  const ::flatbuffers::String *return_var_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RETURN_VAR_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedShadowedVar>> *shadowed_vars() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedShadowedVar>> *>(VT_SHADOWED_VARS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *param_names() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_PARAM_NAMES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODE_NAME) &&
           verifier.VerifyString(node_name()) &&
           VerifyField<uint32_t>(verifier, VT_PC, 4) &&
           VerifyOffset(verifier, VT_RETURN_VAR_NAME) &&
           verifier.VerifyString(return_var_name()) &&
           VerifyOffset(verifier, VT_SHADOWED_VARS) &&
           verifier.VerifyVector(shadowed_vars()) &&
           verifier.VerifyVectorOfTables(shadowed_vars()) &&
           VerifyOffset(verifier, VT_PARAM_NAMES) &&
           verifier.VerifyVector(param_names()) &&
           verifier.VerifyVectorOfStrings(param_names()) &&
           verifier.EndTable();
  }
  SavedCallFrameT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SavedCallFrameT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SavedCallFrame> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SavedCallFrameT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SavedCallFrameBuilder {
  typedef SavedCallFrame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_node_name(::flatbuffers::Offset<::flatbuffers::String> node_name) {
    fbb_.AddOffset(SavedCallFrame::VT_NODE_NAME, node_name);
  }
  void add_pc(uint32_t pc) {
    fbb_.AddElement<uint32_t>(SavedCallFrame::VT_PC, pc, 0);
  }
  void add_return_var_name(::flatbuffers::Offset<::flatbuffers::String> return_var_name) {
    fbb_.AddOffset(SavedCallFrame::VT_RETURN_VAR_NAME, return_var_name);
  }
  void add_shadowed_vars(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedShadowedVar>>> shadowed_vars) {
    fbb_.AddOffset(SavedCallFrame::VT_SHADOWED_VARS, shadowed_vars);
  }
  void add_param_names(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> param_names) {
    fbb_.AddOffset(SavedCallFrame::VT_PARAM_NAMES, param_names);
  }
  explicit SavedCallFrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SavedCallFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SavedCallFrame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SavedCallFrame> CreateSavedCallFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> node_name = 0,
    uint32_t pc = 0,
    ::flatbuffers::Offset<::flatbuffers::String> return_var_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedShadowedVar>>> shadowed_vars = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> param_names = 0) {
  SavedCallFrameBuilder builder_(_fbb);
  builder_.add_param_names(param_names);
  builder_.add_shadowed_vars(shadowed_vars);
  builder_.add_return_var_name(return_var_name);
  builder_.add_pc(pc);
  builder_.add_node_name(node_name);
  return builder_.Finish();
}

struct SavedCallFrame::Traits {
  using type = SavedCallFrame;
  static auto constexpr Create = CreateSavedCallFrame;
};

inline ::flatbuffers::Offset<SavedCallFrame> CreateSavedCallFrameDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *node_name = nullptr,
    uint32_t pc = 0,
    const char *return_var_name = nullptr,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedShadowedVar>> *shadowed_vars = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *param_names = nullptr) {
  auto node_name__ = node_name ? _fbb.CreateString(node_name) : 0;
  auto return_var_name__ = return_var_name ? _fbb.CreateString(return_var_name) : 0;
  auto shadowed_vars__ = shadowed_vars ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedShadowedVar>>(*shadowed_vars) : 0;
  auto param_names__ = param_names ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*param_names) : 0;
  return ICPDev::Gyeol::Schema::CreateSavedCallFrame(
      _fbb,
      node_name__,
      pc,
      return_var_name__,
      shadowed_vars__,
      param_names__);
}

::flatbuffers::Offset<SavedCallFrame> CreateSavedCallFrame(::flatbuffers::FlatBufferBuilder &_fbb, const SavedCallFrameT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SavedPendingChoiceT : public ::flatbuffers::NativeTable {
  typedef SavedPendingChoice TableType;
  std::string text{};
  std::string target_node_name{};
  ICPDev::Gyeol::Schema::ChoiceModifier choice_modifier = ICPDev::Gyeol::Schema::ChoiceModifier::Default;
};

struct SavedPendingChoice FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SavedPendingChoiceT NativeTableType;
  typedef SavedPendingChoiceBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4,
    VT_TARGET_NODE_NAME = 6,
    VT_CHOICE_MODIFIER = 8
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  const ::flatbuffers::String *target_node_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TARGET_NODE_NAME);
  }
  ICPDev::Gyeol::Schema::ChoiceModifier choice_modifier() const {
    return static_cast<ICPDev::Gyeol::Schema::ChoiceModifier>(GetField<int8_t>(VT_CHOICE_MODIFIER, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyOffset(verifier, VT_TARGET_NODE_NAME) &&
           verifier.VerifyString(target_node_name()) &&
           VerifyField<int8_t>(verifier, VT_CHOICE_MODIFIER, 1) &&
           verifier.EndTable();
  }
  SavedPendingChoiceT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SavedPendingChoiceT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SavedPendingChoice> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SavedPendingChoiceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SavedPendingChoiceBuilder {
  typedef SavedPendingChoice Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(SavedPendingChoice::VT_TEXT, text);
  }
  void add_target_node_name(::flatbuffers::Offset<::flatbuffers::String> target_node_name) {
    fbb_.AddOffset(SavedPendingChoice::VT_TARGET_NODE_NAME, target_node_name);
  }
  void add_choice_modifier(ICPDev::Gyeol::Schema::ChoiceModifier choice_modifier) {
    fbb_.AddElement<int8_t>(SavedPendingChoice::VT_CHOICE_MODIFIER, static_cast<int8_t>(choice_modifier), 0);
  }
  explicit SavedPendingChoiceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SavedPendingChoice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SavedPendingChoice>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SavedPendingChoice> CreateSavedPendingChoice(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    ::flatbuffers::Offset<::flatbuffers::String> target_node_name = 0,
    ICPDev::Gyeol::Schema::ChoiceModifier choice_modifier = ICPDev::Gyeol::Schema::ChoiceModifier::Default) {
  SavedPendingChoiceBuilder builder_(_fbb);
  builder_.add_target_node_name(target_node_name);
  builder_.add_text(text);
  builder_.add_choice_modifier(choice_modifier);
  return builder_.Finish();
}

struct SavedPendingChoice::Traits {
  using type = SavedPendingChoice;
  static auto constexpr Create = CreateSavedPendingChoice;
};

inline ::flatbuffers::Offset<SavedPendingChoice> CreateSavedPendingChoiceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    const char *target_node_name = nullptr,
    ICPDev::Gyeol::Schema::ChoiceModifier choice_modifier = ICPDev::Gyeol::Schema::ChoiceModifier::Default) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  auto target_node_name__ = target_node_name ? _fbb.CreateString(target_node_name) : 0;
  return ICPDev::Gyeol::Schema::CreateSavedPendingChoice(
      _fbb,
      text__,
      target_node_name__,
      choice_modifier);
}

::flatbuffers::Offset<SavedPendingChoice> CreateSavedPendingChoice(::flatbuffers::FlatBufferBuilder &_fbb, const SavedPendingChoiceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SavedVisitCountT : public ::flatbuffers::NativeTable {
  typedef SavedVisitCount TableType;
  std::string node_name{};
  uint32_t count = 0;
};

struct SavedVisitCount FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SavedVisitCountT NativeTableType;
  typedef SavedVisitCountBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE_NAME = 4,
    VT_COUNT = 6
  };
  const ::flatbuffers::String *node_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NODE_NAME);
  }
  uint32_t count() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODE_NAME) &&
           verifier.VerifyString(node_name()) &&
           VerifyField<uint32_t>(verifier, VT_COUNT, 4) &&
           verifier.EndTable();
  }
  SavedVisitCountT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SavedVisitCountT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SavedVisitCount> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SavedVisitCountT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SavedVisitCountBuilder {
  typedef SavedVisitCount Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_node_name(::flatbuffers::Offset<::flatbuffers::String> node_name) {
    fbb_.AddOffset(SavedVisitCount::VT_NODE_NAME, node_name);
  }
  void add_count(uint32_t count) {
    fbb_.AddElement<uint32_t>(SavedVisitCount::VT_COUNT, count, 0);
  }
  explicit SavedVisitCountBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SavedVisitCount> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SavedVisitCount>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SavedVisitCount> CreateSavedVisitCount(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> node_name = 0,
    uint32_t count = 0) {
  SavedVisitCountBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_node_name(node_name);
  return builder_.Finish();
}

struct SavedVisitCount::Traits {
  using type = SavedVisitCount;
  static auto constexpr Create = CreateSavedVisitCount;
};

inline ::flatbuffers::Offset<SavedVisitCount> CreateSavedVisitCountDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *node_name = nullptr,
    uint32_t count = 0) {
  auto node_name__ = node_name ? _fbb.CreateString(node_name) : 0;
  return ICPDev::Gyeol::Schema::CreateSavedVisitCount(
      _fbb,
      node_name__,
      count);
}

::flatbuffers::Offset<SavedVisitCount> CreateSavedVisitCount(::flatbuffers::FlatBufferBuilder &_fbb, const SavedVisitCountT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SaveStateT : public ::flatbuffers::NativeTable {
  typedef SaveState TableType;
  std::string version{};
  std::string story_version{};
  std::string current_node_name{};
  uint32_t pc = 0;
  bool finished = false;
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::SavedVarT>> variables{};
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::SavedCallFrameT>> call_stack{};
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::SavedPendingChoiceT>> pending_choices{};
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::SavedVisitCountT>> visit_counts{};
  std::vector<std::string> chosen_once_choices{};
  SaveStateT() = default;
  SaveStateT(const SaveStateT &o);
  SaveStateT(SaveStateT&&) FLATBUFFERS_NOEXCEPT = default;
  SaveStateT &operator=(SaveStateT o) FLATBUFFERS_NOEXCEPT;
};

struct SaveState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SaveStateT NativeTableType;
  typedef SaveStateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_STORY_VERSION = 6,
    VT_CURRENT_NODE_NAME = 8,
    VT_PC = 10,
    VT_FINISHED = 12,
    VT_VARIABLES = 14,
    VT_CALL_STACK = 16,
    VT_PENDING_CHOICES = 18,
    VT_VISIT_COUNTS = 20,
    VT_CHOSEN_ONCE_CHOICES = 22
  };
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  const ::flatbuffers::String *story_version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STORY_VERSION);
  }
  const ::flatbuffers::String *current_node_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CURRENT_NODE_NAME);
  }
  uint32_t pc() const {
    return GetField<uint32_t>(VT_PC, 0);
  }
  bool finished() const {
    return GetField<uint8_t>(VT_FINISHED, 0) != 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVar>> *variables() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVar>> *>(VT_VARIABLES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedCallFrame>> *call_stack() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedCallFrame>> *>(VT_CALL_STACK);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedPendingChoice>> *pending_choices() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedPendingChoice>> *>(VT_PENDING_CHOICES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVisitCount>> *visit_counts() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVisitCount>> *>(VT_VISIT_COUNTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *chosen_once_choices() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CHOSEN_ONCE_CHOICES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_STORY_VERSION) &&
           verifier.VerifyString(story_version()) &&
           VerifyOffset(verifier, VT_CURRENT_NODE_NAME) &&
           verifier.VerifyString(current_node_name()) &&
           VerifyField<uint32_t>(verifier, VT_PC, 4) &&
           VerifyField<uint8_t>(verifier, VT_FINISHED, 1) &&
           VerifyOffset(verifier, VT_VARIABLES) &&
           verifier.VerifyVector(variables()) &&
           verifier.VerifyVectorOfTables(variables()) &&
           VerifyOffset(verifier, VT_CALL_STACK) &&
           verifier.VerifyVector(call_stack()) &&
           verifier.VerifyVectorOfTables(call_stack()) &&
           VerifyOffset(verifier, VT_PENDING_CHOICES) &&
           verifier.VerifyVector(pending_choices()) &&
           verifier.VerifyVectorOfTables(pending_choices()) &&
           VerifyOffset(verifier, VT_VISIT_COUNTS) &&
           verifier.VerifyVector(visit_counts()) &&
           verifier.VerifyVectorOfTables(visit_counts()) &&
           VerifyOffset(verifier, VT_CHOSEN_ONCE_CHOICES) &&
           verifier.VerifyVector(chosen_once_choices()) &&
           verifier.VerifyVectorOfStrings(chosen_once_choices()) &&
           verifier.EndTable();
  }
  SaveStateT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SaveStateT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SaveState> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SaveStateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SaveStateBuilder {
  typedef SaveState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(SaveState::VT_VERSION, version);
  }
  void add_story_version(::flatbuffers::Offset<::flatbuffers::String> story_version) {
    fbb_.AddOffset(SaveState::VT_STORY_VERSION, story_version);
  }
  void add_current_node_name(::flatbuffers::Offset<::flatbuffers::String> current_node_name) {
    fbb_.AddOffset(SaveState::VT_CURRENT_NODE_NAME, current_node_name);
  }
  void add_pc(uint32_t pc) {
    fbb_.AddElement<uint32_t>(SaveState::VT_PC, pc, 0);
  }
  void add_finished(bool finished) {
    fbb_.AddElement<uint8_t>(SaveState::VT_FINISHED, static_cast<uint8_t>(finished), 0);
  }
  void add_variables(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVar>>> variables) {
    fbb_.AddOffset(SaveState::VT_VARIABLES, variables);
  }
  void add_call_stack(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedCallFrame>>> call_stack) {
    fbb_.AddOffset(SaveState::VT_CALL_STACK, call_stack);
  }
  void add_pending_choices(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedPendingChoice>>> pending_choices) {
    fbb_.AddOffset(SaveState::VT_PENDING_CHOICES, pending_choices);
  }
  void add_visit_counts(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVisitCount>>> visit_counts) {
    fbb_.AddOffset(SaveState::VT_VISIT_COUNTS, visit_counts);
  }
  void add_chosen_once_choices(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> chosen_once_choices) {
    fbb_.AddOffset(SaveState::VT_CHOSEN_ONCE_CHOICES, chosen_once_choices);
  }
  explicit SaveStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SaveState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SaveState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SaveState> CreateSaveState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> story_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> current_node_name = 0,
    uint32_t pc = 0,
    bool finished = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVar>>> variables = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedCallFrame>>> call_stack = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedPendingChoice>>> pending_choices = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVisitCount>>> visit_counts = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> chosen_once_choices = 0) {
  SaveStateBuilder builder_(_fbb);
  builder_.add_chosen_once_choices(chosen_once_choices);
  builder_.add_visit_counts(visit_counts);
  builder_.add_pending_choices(pending_choices);
  builder_.add_call_stack(call_stack);
  builder_.add_variables(variables);
  builder_.add_pc(pc);
  builder_.add_current_node_name(current_node_name);
  builder_.add_story_version(story_version);
  builder_.add_version(version);
  builder_.add_finished(finished);
  return builder_.Finish();
}

struct SaveState::Traits {
  using type = SaveState;
  static auto constexpr Create = CreateSaveState;
};

inline ::flatbuffers::Offset<SaveState> CreateSaveStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    const char *story_version = nullptr,
    const char *current_node_name = nullptr,
    uint32_t pc = 0,
    bool finished = false,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVar>> *variables = nullptr,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedCallFrame>> *call_stack = nullptr,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedPendingChoice>> *pending_choices = nullptr,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVisitCount>> *visit_counts = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *chosen_once_choices = nullptr) {
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto story_version__ = story_version ? _fbb.CreateString(story_version) : 0;
  auto current_node_name__ = current_node_name ? _fbb.CreateString(current_node_name) : 0;
  auto variables__ = variables ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVar>>(*variables) : 0;
  auto call_stack__ = call_stack ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedCallFrame>>(*call_stack) : 0;
  auto pending_choices__ = pending_choices ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedPendingChoice>>(*pending_choices) : 0;
  auto visit_counts__ = visit_counts ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVisitCount>>(*visit_counts) : 0;
  auto chosen_once_choices__ = chosen_once_choices ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*chosen_once_choices) : 0;
  return ICPDev::Gyeol::Schema::CreateSaveState(
      _fbb,
      version__,
      story_version__,
      current_node_name__,
      pc,
      finished,
      variables__,
      call_stack__,
      pending_choices__,
      visit_counts__,
      chosen_once_choices__);
}

::flatbuffers::Offset<SaveState> CreateSaveState(::flatbuffers::FlatBufferBuilder &_fbb, const SaveStateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StoryT : public ::flatbuffers::NativeTable {
  typedef Story TableType;
  std::string version{};
  std::vector<std::string> string_pool{};
  std::vector<std::string> line_ids{};
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::SetVarT>> global_vars{};
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::NodeT>> nodes{};
  std::string start_node_name{};
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::CharacterDefT>> characters{};
  StoryT() = default;
  StoryT(const StoryT &o);
  StoryT(StoryT&&) FLATBUFFERS_NOEXCEPT = default;
  StoryT &operator=(StoryT o) FLATBUFFERS_NOEXCEPT;
};

struct Story FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StoryT NativeTableType;
  typedef StoryBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_STRING_POOL = 6,
    VT_LINE_IDS = 8,
    VT_GLOBAL_VARS = 10,
    VT_NODES = 12,
    VT_START_NODE_NAME = 14,
    VT_CHARACTERS = 16
  };
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *string_pool() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRING_POOL);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *line_ids() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_LINE_IDS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>> *global_vars() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>> *>(VT_GLOBAL_VARS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>> *nodes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>> *>(VT_NODES);
  }
  const ::flatbuffers::String *start_node_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_START_NODE_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::CharacterDef>> *characters() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::CharacterDef>> *>(VT_CHARACTERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_STRING_POOL) &&
           verifier.VerifyVector(string_pool()) &&
           verifier.VerifyVectorOfStrings(string_pool()) &&
           VerifyOffset(verifier, VT_LINE_IDS) &&
           verifier.VerifyVector(line_ids()) &&
           verifier.VerifyVectorOfStrings(line_ids()) &&
           VerifyOffset(verifier, VT_GLOBAL_VARS) &&
           verifier.VerifyVector(global_vars()) &&
           verifier.VerifyVectorOfTables(global_vars()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_START_NODE_NAME) &&
           verifier.VerifyString(start_node_name()) &&
           VerifyOffset(verifier, VT_CHARACTERS) &&
           verifier.VerifyVector(characters()) &&
           verifier.VerifyVectorOfTables(characters()) &&
           verifier.EndTable();
  }
  StoryT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StoryT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Story> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StoryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StoryBuilder {
  typedef Story Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(Story::VT_VERSION, version);
  }
  void add_string_pool(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> string_pool) {
    fbb_.AddOffset(Story::VT_STRING_POOL, string_pool);
  }
  void add_line_ids(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> line_ids) {
    fbb_.AddOffset(Story::VT_LINE_IDS, line_ids);
  }
  void add_global_vars(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>>> global_vars) {
    fbb_.AddOffset(Story::VT_GLOBAL_VARS, global_vars);
  }
  void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>>> nodes) {
    fbb_.AddOffset(Story::VT_NODES, nodes);
  }
  void add_start_node_name(::flatbuffers::Offset<::flatbuffers::String> start_node_name) {
    fbb_.AddOffset(Story::VT_START_NODE_NAME, start_node_name);
  }
  void add_characters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::CharacterDef>>> characters) {
    fbb_.AddOffset(Story::VT_CHARACTERS, characters);
  }
  explicit StoryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Story> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Story>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Story> CreateStory(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> string_pool = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> line_ids = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>>> global_vars = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>>> nodes = 0,
    ::flatbuffers::Offset<::flatbuffers::String> start_node_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::CharacterDef>>> characters = 0) {
  StoryBuilder builder_(_fbb);
  builder_.add_characters(characters);
  builder_.add_start_node_name(start_node_name);
  builder_.add_nodes(nodes);
  builder_.add_global_vars(global_vars);
  builder_.add_line_ids(line_ids);
  builder_.add_string_pool(string_pool);
  builder_.add_version(version);
  return builder_.Finish();
}

struct Story::Traits {
  using type = Story;
  static auto constexpr Create = CreateStory;
};

inline ::flatbuffers::Offset<Story> CreateStoryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *string_pool = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *line_ids = nullptr,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>> *global_vars = nullptr,
    std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>> *nodes = nullptr,
    const char *start_node_name = nullptr,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::CharacterDef>> *characters = nullptr) {
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto string_pool__ = string_pool ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*string_pool) : 0;
  auto line_ids__ = line_ids ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*line_ids) : 0;
  auto global_vars__ = global_vars ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>>(*global_vars) : 0;
  auto nodes__ = nodes ? _fbb.CreateVectorOfSortedTables<ICPDev::Gyeol::Schema::Node>(nodes) : 0;
  auto start_node_name__ = start_node_name ? _fbb.CreateString(start_node_name) : 0;
  auto characters__ = characters ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::CharacterDef>>(*characters) : 0;
  return ICPDev::Gyeol::Schema::CreateStory(
      _fbb,
      version__,
      string_pool__,
      line_ids__,
      global_vars__,
      nodes__,
      start_node_name__,
      characters__);
}

::flatbuffers::Offset<Story> CreateStory(::flatbuffers::FlatBufferBuilder &_fbb, const StoryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline BoolValueT *BoolValue::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<BoolValueT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BoolValue::UnPackTo(BoolValueT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = val(); _o->val = _e; }
}

inline ::flatbuffers::Offset<BoolValue> BoolValue::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BoolValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBoolValue(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BoolValue> CreateBoolValue(::flatbuffers::FlatBufferBuilder &_fbb, const BoolValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BoolValueT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _val = _o->val;
  return ICPDev::Gyeol::Schema::CreateBoolValue(
      _fbb,
      _val);
}

inline IntValueT *IntValue::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<IntValueT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IntValue::UnPackTo(IntValueT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = val(); _o->val = _e; }
}

inline ::flatbuffers::Offset<IntValue> IntValue::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IntValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIntValue(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<IntValue> CreateIntValue(::flatbuffers::FlatBufferBuilder &_fbb, const IntValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const IntValueT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _val = _o->val;
  return ICPDev::Gyeol::Schema::CreateIntValue(
      _fbb,
      _val);
}

inline FloatValueT *FloatValue::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FloatValueT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FloatValue::UnPackTo(FloatValueT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = val(); _o->val = _e; }
}

inline ::flatbuffers::Offset<FloatValue> FloatValue::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FloatValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloatValue(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FloatValue> CreateFloatValue(::flatbuffers::FlatBufferBuilder &_fbb, const FloatValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FloatValueT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _val = _o->val;
  return ICPDev::Gyeol::Schema::CreateFloatValue(
      _fbb,
      _val);
}

inline StringRefT *StringRef::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<StringRefT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StringRef::UnPackTo(StringRefT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = index(); _o->index = _e; }
}

inline ::flatbuffers::Offset<StringRef> StringRef::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StringRefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStringRef(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StringRef> CreateStringRef(::flatbuffers::FlatBufferBuilder &_fbb, const StringRefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StringRefT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _index = _o->index;
  return ICPDev::Gyeol::Schema::CreateStringRef(
      _fbb,
      _index);
}

inline ListValueT *ListValue::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ListValueT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ListValue::UnPackTo(ListValueT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = items(); if (_e) { _o->items.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->items[_i] = _e->Get(_i); } } else { _o->items.resize(0); } }
}

inline ::flatbuffers::Offset<ListValue> ListValue::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ListValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateListValue(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ListValue> CreateListValue(::flatbuffers::FlatBufferBuilder &_fbb, const ListValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ListValueT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _items = _o->items.size() ? _fbb.CreateVector(_o->items) : 0;
  return ICPDev::Gyeol::Schema::CreateListValue(
      _fbb,
      _items);
}

inline TagT *Tag::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<TagT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Tag::UnPackTo(TagT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = key_id(); _o->key_id = _e; }
  { auto _e = value_id(); _o->value_id = _e; }
}

inline ::flatbuffers::Offset<Tag> Tag::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const TagT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTag(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Tag> CreateTag(::flatbuffers::FlatBufferBuilder &_fbb, const TagT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const TagT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _key_id = _o->key_id;
  auto _value_id = _o->value_id;
  return ICPDev::Gyeol::Schema::CreateTag(
      _fbb,
      _key_id,
      _value_id);
}

inline LineT::LineT(const LineT &o)
      : character_id(o.character_id),
        text_id(o.text_id),
        voice_asset_id(o.voice_asset_id) {
  tags.reserve(o.tags.size());
  for (const auto &tags_ : o.tags) { tags.emplace_back((tags_) ? new ICPDev::Gyeol::Schema::TagT(*tags_) : nullptr); }
}

inline LineT &LineT::operator=(LineT o) FLATBUFFERS_NOEXCEPT {
  std::swap(character_id, o.character_id);
  std::swap(text_id, o.text_id);
  std::swap(voice_asset_id, o.voice_asset_id);
  std::swap(tags, o.tags);
  return *this;
}

inline LineT *Line::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LineT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Line::UnPackTo(LineT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character_id(); _o->character_id = _e; }
  { auto _e = text_id(); _o->text_id = _e; }
  { auto _e = voice_asset_id(); _o->voice_asset_id = _e; }
  { auto _e = tags(); if (_e) { _o->tags.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->tags[_i]) { _e->Get(_i)->UnPackTo(_o->tags[_i].get(), _resolver); } else { _o->tags[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::TagT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->tags.resize(0); } }
}

inline ::flatbuffers::Offset<Line> Line::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LineT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLine(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Line> CreateLine(::flatbuffers::FlatBufferBuilder &_fbb, const LineT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LineT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _character_id = _o->character_id;
  auto _text_id = _o->text_id;
  auto _voice_asset_id = _o->voice_asset_id;
  auto _tags = _o->tags.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>> (_o->tags.size(), [](size_t i, _VectorArgs *__va) { return CreateTag(*__va->__fbb, __va->__o->tags[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ICPDev::Gyeol::Schema::CreateLine(
      _fbb,
      _character_id,
      _text_id,
      _voice_asset_id,
      _tags);
}

inline ChoiceT *Choice::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ChoiceT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Choice::UnPackTo(ChoiceT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = text_id(); _o->text_id = _e; }
  { auto _e = target_node_name_id(); _o->target_node_name_id = _e; }
  { auto _e = condition_var_id(); _o->condition_var_id = _e; }
  { auto _e = choice_modifier(); _o->choice_modifier = _e; }
}

inline ::flatbuffers::Offset<Choice> Choice::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ChoiceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateChoice(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Choice> CreateChoice(::flatbuffers::FlatBufferBuilder &_fbb, const ChoiceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ChoiceT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _text_id = _o->text_id;
  auto _target_node_name_id = _o->target_node_name_id;
  auto _condition_var_id = _o->condition_var_id;
  auto _choice_modifier = _o->choice_modifier;
  return ICPDev::Gyeol::Schema::CreateChoice(
      _fbb,
      _text_id,
      _target_node_name_id,
      _condition_var_id,
      _choice_modifier);
}

inline JumpT::JumpT(const JumpT &o)
      : target_node_name_id(o.target_node_name_id),
        is_call(o.is_call) {
  arg_exprs.reserve(o.arg_exprs.size());
  for (const auto &arg_exprs_ : o.arg_exprs) { arg_exprs.emplace_back((arg_exprs_) ? new ICPDev::Gyeol::Schema::ExpressionT(*arg_exprs_) : nullptr); }
}

inline JumpT &JumpT::operator=(JumpT o) FLATBUFFERS_NOEXCEPT {
  std::swap(target_node_name_id, o.target_node_name_id);
  std::swap(is_call, o.is_call);
  std::swap(arg_exprs, o.arg_exprs);
  return *this;
}

inline JumpT *Jump::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<JumpT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Jump::UnPackTo(JumpT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target_node_name_id(); _o->target_node_name_id = _e; }
  { auto _e = is_call(); _o->is_call = _e; }
  { auto _e = arg_exprs(); if (_e) { _o->arg_exprs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->arg_exprs[_i]) { _e->Get(_i)->UnPackTo(_o->arg_exprs[_i].get(), _resolver); } else { _o->arg_exprs[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->arg_exprs.resize(0); } }
}

inline ::flatbuffers::Offset<Jump> Jump::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JumpT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJump(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Jump> CreateJump(::flatbuffers::FlatBufferBuilder &_fbb, const JumpT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const JumpT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target_node_name_id = _o->target_node_name_id;
  auto _is_call = _o->is_call;
  auto _arg_exprs = _o->arg_exprs.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression>> (_o->arg_exprs.size(), [](size_t i, _VectorArgs *__va) { return CreateExpression(*__va->__fbb, __va->__o->arg_exprs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ICPDev::Gyeol::Schema::CreateJump(
      _fbb,
      _target_node_name_id,
      _is_call,
      _arg_exprs);
}

inline CommandT *Command::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CommandT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Command::UnPackTo(CommandT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type_id(); _o->type_id = _e; }
  { auto _e = params(); if (_e) { _o->params.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->params[_i] = _e->Get(_i); } } else { _o->params.resize(0); } }
}

inline ::flatbuffers::Offset<Command> Command::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCommand(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Command> CreateCommand(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CommandT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type_id = _o->type_id;
  auto _params = _o->params.size() ? _fbb.CreateVector(_o->params) : 0;
  return ICPDev::Gyeol::Schema::CreateCommand(
      _fbb,
      _type_id,
      _params);
}

inline ExprTokenT *ExprToken::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ExprTokenT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExprToken::UnPackTo(ExprTokenT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = op(); _o->op = _e; }
  { auto _e = literal_value_type(); _o->literal_value.type = _e; }
  { auto _e = literal_value(); if (_e) _o->literal_value.value = ICPDev::Gyeol::Schema::ValueDataUnion::UnPack(_e, literal_value_type(), _resolver); }
  { auto _e = var_name_id(); _o->var_name_id = _e; }
}

inline ::flatbuffers::Offset<ExprToken> ExprToken::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExprTokenT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExprToken(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ExprToken> CreateExprToken(::flatbuffers::FlatBufferBuilder &_fbb, const ExprTokenT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ExprTokenT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _op = _o->op;
  auto _literal_value_type = _o->literal_value.type;
  auto _literal_value = _o->literal_value.Pack(_fbb);
  auto _var_name_id = _o->var_name_id;
  return ICPDev::Gyeol::Schema::CreateExprToken(
      _fbb,
      _op,
      _literal_value_type,
      _literal_value,
      _var_name_id);
}

inline ExpressionT::ExpressionT(const ExpressionT &o) {
  tokens.reserve(o.tokens.size());
  for (const auto &tokens_ : o.tokens) { tokens.emplace_back((tokens_) ? new ICPDev::Gyeol::Schema::ExprTokenT(*tokens_) : nullptr); }
}

inline ExpressionT &ExpressionT::operator=(ExpressionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(tokens, o.tokens);
  return *this;
}

inline ExpressionT *Expression::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ExpressionT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Expression::UnPackTo(ExpressionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tokens(); if (_e) { _o->tokens.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->tokens[_i]) { _e->Get(_i)->UnPackTo(_o->tokens[_i].get(), _resolver); } else { _o->tokens[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::ExprTokenT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->tokens.resize(0); } }
}

inline ::flatbuffers::Offset<Expression> Expression::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExpressionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpression(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Expression> CreateExpression(::flatbuffers::FlatBufferBuilder &_fbb, const ExpressionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ExpressionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tokens = _o->tokens.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::ExprToken>> (_o->tokens.size(), [](size_t i, _VectorArgs *__va) { return CreateExprToken(*__va->__fbb, __va->__o->tokens[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ICPDev::Gyeol::Schema::CreateExpression(
      _fbb,
      _tokens);
}

inline SetVarT::SetVarT(const SetVarT &o)
      : var_name_id(o.var_name_id),
        value(o.value),
        expr((o.expr) ? new ICPDev::Gyeol::Schema::ExpressionT(*o.expr) : nullptr),
        assign_op(o.assign_op) {
}

inline SetVarT &SetVarT::operator=(SetVarT o) FLATBUFFERS_NOEXCEPT {
  std::swap(var_name_id, o.var_name_id);
  std::swap(value, o.value);
  std::swap(expr, o.expr);
  std::swap(assign_op, o.assign_op);
  return *this;
}

inline SetVarT *SetVar::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SetVarT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetVar::UnPackTo(SetVarT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = var_name_id(); _o->var_name_id = _e; }
  { auto _e = value_type(); _o->value.type = _e; }
  { auto _e = value(); if (_e) _o->value.value = ICPDev::Gyeol::Schema::ValueDataUnion::UnPack(_e, value_type(), _resolver); }
  { auto _e = expr(); if (_e) { if(_o->expr) { _e->UnPackTo(_o->expr.get(), _resolver); } else { _o->expr = std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT>(_e->UnPack(_resolver)); } } else if (_o->expr) { _o->expr.reset(); } }
  { auto _e = assign_op(); _o->assign_op = _e; }
}

inline ::flatbuffers::Offset<SetVar> SetVar::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetVarT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetVar(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetVar> CreateSetVar(::flatbuffers::FlatBufferBuilder &_fbb, const SetVarT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetVarT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _var_name_id = _o->var_name_id;
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  auto _expr = _o->expr ? CreateExpression(_fbb, _o->expr.get(), _rehasher) : 0;
  auto _assign_op = _o->assign_op;
  return ICPDev::Gyeol::Schema::CreateSetVar(
      _fbb,
      _var_name_id,
      _value_type,
      _value,
      _expr,
      _assign_op);
}

inline ConditionT::ConditionT(const ConditionT &o)
      : var_name_id(o.var_name_id),
        op(o.op),
        compare_value(o.compare_value),
        true_jump_node_id(o.true_jump_node_id),
        false_jump_node_id(o.false_jump_node_id),
        lhs_expr((o.lhs_expr) ? new ICPDev::Gyeol::Schema::ExpressionT(*o.lhs_expr) : nullptr),
        rhs_expr((o.rhs_expr) ? new ICPDev::Gyeol::Schema::ExpressionT(*o.rhs_expr) : nullptr),
        cond_expr((o.cond_expr) ? new ICPDev::Gyeol::Schema::ExpressionT(*o.cond_expr) : nullptr) {
}

inline ConditionT &ConditionT::operator=(ConditionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(var_name_id, o.var_name_id);
  std::swap(op, o.op);
  std::swap(compare_value, o.compare_value);
  std::swap(true_jump_node_id, o.true_jump_node_id);
  std::swap(false_jump_node_id, o.false_jump_node_id);
  std::swap(lhs_expr, o.lhs_expr);
  std::swap(rhs_expr, o.rhs_expr);
  std::swap(cond_expr, o.cond_expr);
  return *this;
}

inline ConditionT *Condition::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ConditionT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Condition::UnPackTo(ConditionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = var_name_id(); _o->var_name_id = _e; }
  { auto _e = op(); _o->op = _e; }
  { auto _e = compare_value_type(); _o->compare_value.type = _e; }
  { auto _e = compare_value(); if (_e) _o->compare_value.value = ICPDev::Gyeol::Schema::ValueDataUnion::UnPack(_e, compare_value_type(), _resolver); }
  { auto _e = true_jump_node_id(); _o->true_jump_node_id = _e; }
  { auto _e = false_jump_node_id(); _o->false_jump_node_id = _e; }
  { auto _e = lhs_expr(); if (_e) { if(_o->lhs_expr) { _e->UnPackTo(_o->lhs_expr.get(), _resolver); } else { _o->lhs_expr = std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT>(_e->UnPack(_resolver)); } } else if (_o->lhs_expr) { _o->lhs_expr.reset(); } }
  { auto _e = rhs_expr(); if (_e) { if(_o->rhs_expr) { _e->UnPackTo(_o->rhs_expr.get(), _resolver); } else { _o->rhs_expr = std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT>(_e->UnPack(_resolver)); } } else if (_o->rhs_expr) { _o->rhs_expr.reset(); } }
  { auto _e = cond_expr(); if (_e) { if(_o->cond_expr) { _e->UnPackTo(_o->cond_expr.get(), _resolver); } else { _o->cond_expr = std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT>(_e->UnPack(_resolver)); } } else if (_o->cond_expr) { _o->cond_expr.reset(); } }
}

inline ::flatbuffers::Offset<Condition> Condition::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConditionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCondition(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Condition> CreateCondition(::flatbuffers::FlatBufferBuilder &_fbb, const ConditionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ConditionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _var_name_id = _o->var_name_id;
  auto _op = _o->op;
  auto _compare_value_type = _o->compare_value.type;
  auto _compare_value = _o->compare_value.Pack(_fbb);
  auto _true_jump_node_id = _o->true_jump_node_id;
  auto _false_jump_node_id = _o->false_jump_node_id;
  auto _lhs_expr = _o->lhs_expr ? CreateExpression(_fbb, _o->lhs_expr.get(), _rehasher) : 0;
  auto _rhs_expr = _o->rhs_expr ? CreateExpression(_fbb, _o->rhs_expr.get(), _rehasher) : 0;
  auto _cond_expr = _o->cond_expr ? CreateExpression(_fbb, _o->cond_expr.get(), _rehasher) : 0;
  return ICPDev::Gyeol::Schema::CreateCondition(
      _fbb,
      _var_name_id,
      _op,
      _compare_value_type,
      _compare_value,
      _true_jump_node_id,
      _false_jump_node_id,
      _lhs_expr,
      _rhs_expr,
      _cond_expr);
}

inline RandomBranchT *RandomBranch::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<RandomBranchT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RandomBranch::UnPackTo(RandomBranchT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target_node_name_id(); _o->target_node_name_id = _e; }
  { auto _e = weight(); _o->weight = _e; }
}

inline ::flatbuffers::Offset<RandomBranch> RandomBranch::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RandomBranchT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRandomBranch(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RandomBranch> CreateRandomBranch(::flatbuffers::FlatBufferBuilder &_fbb, const RandomBranchT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RandomBranchT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target_node_name_id = _o->target_node_name_id;
  auto _weight = _o->weight;
  return ICPDev::Gyeol::Schema::CreateRandomBranch(
      _fbb,
      _target_node_name_id,
      _weight);
}

inline RandomT::RandomT(const RandomT &o) {
  branches.reserve(o.branches.size());
  for (const auto &branches_ : o.branches) { branches.emplace_back((branches_) ? new ICPDev::Gyeol::Schema::RandomBranchT(*branches_) : nullptr); }
}

inline RandomT &RandomT::operator=(RandomT o) FLATBUFFERS_NOEXCEPT {
  std::swap(branches, o.branches);
  return *this;
}

inline RandomT *Random::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<RandomT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Random::UnPackTo(RandomT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = branches(); if (_e) { _o->branches.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->branches[_i]) { _e->Get(_i)->UnPackTo(_o->branches[_i].get(), _resolver); } else { _o->branches[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::RandomBranchT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->branches.resize(0); } }
}

inline ::flatbuffers::Offset<Random> Random::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RandomT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRandom(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Random> CreateRandom(::flatbuffers::FlatBufferBuilder &_fbb, const RandomT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RandomT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _branches = _o->branches.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::RandomBranch>> (_o->branches.size(), [](size_t i, _VectorArgs *__va) { return CreateRandomBranch(*__va->__fbb, __va->__o->branches[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ICPDev::Gyeol::Schema::CreateRandom(
      _fbb,
      _branches);
}

inline ReturnT::ReturnT(const ReturnT &o)
      : expr((o.expr) ? new ICPDev::Gyeol::Schema::ExpressionT(*o.expr) : nullptr),
        value(o.value) {
}

inline ReturnT &ReturnT::operator=(ReturnT o) FLATBUFFERS_NOEXCEPT {
  std::swap(expr, o.expr);
  std::swap(value, o.value);
  return *this;
}

inline ReturnT *Return::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ReturnT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Return::UnPackTo(ReturnT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = expr(); if (_e) { if(_o->expr) { _e->UnPackTo(_o->expr.get(), _resolver); } else { _o->expr = std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT>(_e->UnPack(_resolver)); } } else if (_o->expr) { _o->expr.reset(); } }
  { auto _e = value_type(); _o->value.type = _e; }
  { auto _e = value(); if (_e) _o->value.value = ICPDev::Gyeol::Schema::ValueDataUnion::UnPack(_e, value_type(), _resolver); }
}

inline ::flatbuffers::Offset<Return> Return::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReturnT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReturn(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Return> CreateReturn(::flatbuffers::FlatBufferBuilder &_fbb, const ReturnT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReturnT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _expr = _o->expr ? CreateExpression(_fbb, _o->expr.get(), _rehasher) : 0;
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  return ICPDev::Gyeol::Schema::CreateReturn(
      _fbb,
      _expr,
      _value_type,
      _value);
}

inline CallWithReturnT::CallWithReturnT(const CallWithReturnT &o)
      : target_node_name_id(o.target_node_name_id),
        return_var_name_id(o.return_var_name_id) {
  arg_exprs.reserve(o.arg_exprs.size());
  for (const auto &arg_exprs_ : o.arg_exprs) { arg_exprs.emplace_back((arg_exprs_) ? new ICPDev::Gyeol::Schema::ExpressionT(*arg_exprs_) : nullptr); }
}

inline CallWithReturnT &CallWithReturnT::operator=(CallWithReturnT o) FLATBUFFERS_NOEXCEPT {
  std::swap(target_node_name_id, o.target_node_name_id);
  std::swap(return_var_name_id, o.return_var_name_id);
  std::swap(arg_exprs, o.arg_exprs);
  return *this;
}

inline CallWithReturnT *CallWithReturn::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CallWithReturnT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CallWithReturn::UnPackTo(CallWithReturnT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target_node_name_id(); _o->target_node_name_id = _e; }
  { auto _e = return_var_name_id(); _o->return_var_name_id = _e; }
  { auto _e = arg_exprs(); if (_e) { _o->arg_exprs.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->arg_exprs[_i]) { _e->Get(_i)->UnPackTo(_o->arg_exprs[_i].get(), _resolver); } else { _o->arg_exprs[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->arg_exprs.resize(0); } }
}

inline ::flatbuffers::Offset<CallWithReturn> CallWithReturn::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CallWithReturnT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCallWithReturn(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CallWithReturn> CreateCallWithReturn(::flatbuffers::FlatBufferBuilder &_fbb, const CallWithReturnT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CallWithReturnT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target_node_name_id = _o->target_node_name_id;
  auto _return_var_name_id = _o->return_var_name_id;
  auto _arg_exprs = _o->arg_exprs.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression>> (_o->arg_exprs.size(), [](size_t i, _VectorArgs *__va) { return CreateExpression(*__va->__fbb, __va->__o->arg_exprs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ICPDev::Gyeol::Schema::CreateCallWithReturn(
      _fbb,
      _target_node_name_id,
      _return_var_name_id,
      _arg_exprs);
}

inline CharacterDefT::CharacterDefT(const CharacterDefT &o)
      : name_id(o.name_id) {
  properties.reserve(o.properties.size());
  for (const auto &properties_ : o.properties) { properties.emplace_back((properties_) ? new ICPDev::Gyeol::Schema::TagT(*properties_) : nullptr); }
}

inline CharacterDefT &CharacterDefT::operator=(CharacterDefT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name_id, o.name_id);
  std::swap(properties, o.properties);
  return *this;
}

inline CharacterDefT *CharacterDef::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CharacterDefT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CharacterDef::UnPackTo(CharacterDefT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name_id(); _o->name_id = _e; }
  { auto _e = properties(); if (_e) { _o->properties.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->properties[_i]) { _e->Get(_i)->UnPackTo(_o->properties[_i].get(), _resolver); } else { _o->properties[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::TagT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->properties.resize(0); } }
}

inline ::flatbuffers::Offset<CharacterDef> CharacterDef::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CharacterDefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCharacterDef(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CharacterDef> CreateCharacterDef(::flatbuffers::FlatBufferBuilder &_fbb, const CharacterDefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CharacterDefT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name_id = _o->name_id;
  auto _properties = _o->properties.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>> (_o->properties.size(), [](size_t i, _VectorArgs *__va) { return CreateTag(*__va->__fbb, __va->__o->properties[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ICPDev::Gyeol::Schema::CreateCharacterDef(
      _fbb,
      _name_id,
      _properties);
}

inline InstructionT *Instruction::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<InstructionT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Instruction::UnPackTo(InstructionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data_type(); _o->data.type = _e; }
  { auto _e = data(); if (_e) _o->data.value = ICPDev::Gyeol::Schema::OpDataUnion::UnPack(_e, data_type(), _resolver); }
}

inline ::flatbuffers::Offset<Instruction> Instruction::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InstructionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInstruction(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Instruction> CreateInstruction(::flatbuffers::FlatBufferBuilder &_fbb, const InstructionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const InstructionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data_type = _o->data.type;
  auto _data = _o->data.Pack(_fbb);
  return ICPDev::Gyeol::Schema::CreateInstruction(
      _fbb,
      _data_type,
      _data);
}

inline NodeT::NodeT(const NodeT &o)
      : name(o.name),
        param_ids(o.param_ids) {
  lines.reserve(o.lines.size());
  for (const auto &lines_ : o.lines) { lines.emplace_back((lines_) ? new ICPDev::Gyeol::Schema::InstructionT(*lines_) : nullptr); }
  tags.reserve(o.tags.size());
  for (const auto &tags_ : o.tags) { tags.emplace_back((tags_) ? new ICPDev::Gyeol::Schema::TagT(*tags_) : nullptr); }
}

inline NodeT &NodeT::operator=(NodeT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(lines, o.lines);
  std::swap(param_ids, o.param_ids);
  std::swap(tags, o.tags);
  return *this;
}

inline NodeT *Node::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<NodeT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Node::UnPackTo(NodeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = lines(); if (_e) { _o->lines.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->lines[_i]) { _e->Get(_i)->UnPackTo(_o->lines[_i].get(), _resolver); } else { _o->lines[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::InstructionT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->lines.resize(0); } }
  { auto _e = param_ids(); if (_e) { _o->param_ids.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->param_ids[_i] = _e->Get(_i); } } else { _o->param_ids.resize(0); } }
  { auto _e = tags(); if (_e) { _o->tags.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->tags[_i]) { _e->Get(_i)->UnPackTo(_o->tags[_i].get(), _resolver); } else { _o->tags[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::TagT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->tags.resize(0); } }
}

inline ::flatbuffers::Offset<Node> Node::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNode(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Node> CreateNode(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NodeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _fbb.CreateString(_o->name);
  auto _lines = _o->lines.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>> (_o->lines.size(), [](size_t i, _VectorArgs *__va) { return CreateInstruction(*__va->__fbb, __va->__o->lines[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _param_ids = _o->param_ids.size() ? _fbb.CreateVector(_o->param_ids) : 0;
  auto _tags = _o->tags.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Tag>> (_o->tags.size(), [](size_t i, _VectorArgs *__va) { return CreateTag(*__va->__fbb, __va->__o->tags[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ICPDev::Gyeol::Schema::CreateNode(
      _fbb,
      _name,
      _lines,
      _param_ids,
      _tags);
}

inline SavedVarT *SavedVar::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SavedVarT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SavedVar::UnPackTo(SavedVarT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = value_type(); _o->value.type = _e; }
  { auto _e = value(); if (_e) _o->value.value = ICPDev::Gyeol::Schema::ValueDataUnion::UnPack(_e, value_type(), _resolver); }
  { auto _e = string_value(); if (_e) _o->string_value = _e->str(); }
  { auto _e = list_items(); if (_e) { _o->list_items.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->list_items[_i] = _e->Get(_i)->str(); } } else { _o->list_items.resize(0); } }
}

inline ::flatbuffers::Offset<SavedVar> SavedVar::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SavedVarT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSavedVar(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SavedVar> CreateSavedVar(::flatbuffers::FlatBufferBuilder &_fbb, const SavedVarT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SavedVarT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  auto _string_value = _o->string_value.empty() ? 0 : _fbb.CreateString(_o->string_value);
  auto _list_items = _o->list_items.size() ? _fbb.CreateVectorOfStrings(_o->list_items) : 0;
  return ICPDev::Gyeol::Schema::CreateSavedVar(
      _fbb,
      _name,
      _value_type,
      _value,
      _string_value,
      _list_items);
}

inline SavedShadowedVarT *SavedShadowedVar::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SavedShadowedVarT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SavedShadowedVar::UnPackTo(SavedShadowedVarT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = value_type(); _o->value.type = _e; }
  { auto _e = value(); if (_e) _o->value.value = ICPDev::Gyeol::Schema::ValueDataUnion::UnPack(_e, value_type(), _resolver); }
  { auto _e = string_value(); if (_e) _o->string_value = _e->str(); }
  { auto _e = existed(); _o->existed = _e; }
  { auto _e = list_items(); if (_e) { _o->list_items.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->list_items[_i] = _e->Get(_i)->str(); } } else { _o->list_items.resize(0); } }
}

inline ::flatbuffers::Offset<SavedShadowedVar> SavedShadowedVar::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SavedShadowedVarT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSavedShadowedVar(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SavedShadowedVar> CreateSavedShadowedVar(::flatbuffers::FlatBufferBuilder &_fbb, const SavedShadowedVarT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SavedShadowedVarT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  auto _string_value = _o->string_value.empty() ? 0 : _fbb.CreateString(_o->string_value);
  auto _existed = _o->existed;
  auto _list_items = _o->list_items.size() ? _fbb.CreateVectorOfStrings(_o->list_items) : 0;
  return ICPDev::Gyeol::Schema::CreateSavedShadowedVar(
      _fbb,
      _name,
      _value_type,
      _value,
      _string_value,
      _existed,
      _list_items);
}

inline SavedCallFrameT::SavedCallFrameT(const SavedCallFrameT &o)
      : node_name(o.node_name),
        pc(o.pc),
        return_var_name(o.return_var_name),
        param_names(o.param_names) {
  shadowed_vars.reserve(o.shadowed_vars.size());
  for (const auto &shadowed_vars_ : o.shadowed_vars) { shadowed_vars.emplace_back((shadowed_vars_) ? new ICPDev::Gyeol::Schema::SavedShadowedVarT(*shadowed_vars_) : nullptr); }
}

inline SavedCallFrameT &SavedCallFrameT::operator=(SavedCallFrameT o) FLATBUFFERS_NOEXCEPT {
  std::swap(node_name, o.node_name);
  std::swap(pc, o.pc);
  std::swap(return_var_name, o.return_var_name);
  std::swap(shadowed_vars, o.shadowed_vars);
  std::swap(param_names, o.param_names);
  return *this;
}

inline SavedCallFrameT *SavedCallFrame::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SavedCallFrameT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SavedCallFrame::UnPackTo(SavedCallFrameT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = node_name(); if (_e) _o->node_name = _e->str(); }
  { auto _e = pc(); _o->pc = _e; }
  { auto _e = return_var_name(); if (_e) _o->return_var_name = _e->str(); }
  { auto _e = shadowed_vars(); if (_e) { _o->shadowed_vars.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->shadowed_vars[_i]) { _e->Get(_i)->UnPackTo(_o->shadowed_vars[_i].get(), _resolver); } else { _o->shadowed_vars[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::SavedShadowedVarT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->shadowed_vars.resize(0); } }
  { auto _e = param_names(); if (_e) { _o->param_names.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->param_names[_i] = _e->Get(_i)->str(); } } else { _o->param_names.resize(0); } }
}

inline ::flatbuffers::Offset<SavedCallFrame> SavedCallFrame::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SavedCallFrameT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSavedCallFrame(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SavedCallFrame> CreateSavedCallFrame(::flatbuffers::FlatBufferBuilder &_fbb, const SavedCallFrameT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SavedCallFrameT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _node_name = _o->node_name.empty() ? 0 : _fbb.CreateString(_o->node_name);
  auto _pc = _o->pc;
  auto _return_var_name = _o->return_var_name.empty() ? 0 : _fbb.CreateString(_o->return_var_name);
  auto _shadowed_vars = _o->shadowed_vars.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedShadowedVar>> (_o->shadowed_vars.size(), [](size_t i, _VectorArgs *__va) { return CreateSavedShadowedVar(*__va->__fbb, __va->__o->shadowed_vars[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _param_names = _o->param_names.size() ? _fbb.CreateVectorOfStrings(_o->param_names) : 0;
  return ICPDev::Gyeol::Schema::CreateSavedCallFrame(
      _fbb,
      _node_name,
      _pc,
      _return_var_name,
      _shadowed_vars,
      _param_names);
}

inline SavedPendingChoiceT *SavedPendingChoice::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SavedPendingChoiceT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SavedPendingChoice::UnPackTo(SavedPendingChoiceT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = text(); if (_e) _o->text = _e->str(); }
  { auto _e = target_node_name(); if (_e) _o->target_node_name = _e->str(); }
  { auto _e = choice_modifier(); _o->choice_modifier = _e; }
}

inline ::flatbuffers::Offset<SavedPendingChoice> SavedPendingChoice::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SavedPendingChoiceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSavedPendingChoice(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SavedPendingChoice> CreateSavedPendingChoice(::flatbuffers::FlatBufferBuilder &_fbb, const SavedPendingChoiceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SavedPendingChoiceT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _text = _o->text.empty() ? 0 : _fbb.CreateString(_o->text);
  auto _target_node_name = _o->target_node_name.empty() ? 0 : _fbb.CreateString(_o->target_node_name);
  auto _choice_modifier = _o->choice_modifier;
  return ICPDev::Gyeol::Schema::CreateSavedPendingChoice(
      _fbb,
      _text,
      _target_node_name,
      _choice_modifier);
}

inline SavedVisitCountT *SavedVisitCount::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SavedVisitCountT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SavedVisitCount::UnPackTo(SavedVisitCountT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = node_name(); if (_e) _o->node_name = _e->str(); }
  { auto _e = count(); _o->count = _e; }
}

inline ::flatbuffers::Offset<SavedVisitCount> SavedVisitCount::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SavedVisitCountT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSavedVisitCount(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SavedVisitCount> CreateSavedVisitCount(::flatbuffers::FlatBufferBuilder &_fbb, const SavedVisitCountT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SavedVisitCountT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _node_name = _o->node_name.empty() ? 0 : _fbb.CreateString(_o->node_name);
  auto _count = _o->count;
  return ICPDev::Gyeol::Schema::CreateSavedVisitCount(
      _fbb,
      _node_name,
      _count);
}

inline SaveStateT::SaveStateT(const SaveStateT &o)
      : version(o.version),
        story_version(o.story_version),
        current_node_name(o.current_node_name),
        pc(o.pc),
        finished(o.finished),
        chosen_once_choices(o.chosen_once_choices) {
  variables.reserve(o.variables.size());
  for (const auto &variables_ : o.variables) { variables.emplace_back((variables_) ? new ICPDev::Gyeol::Schema::SavedVarT(*variables_) : nullptr); }
  call_stack.reserve(o.call_stack.size());
  for (const auto &call_stack_ : o.call_stack) { call_stack.emplace_back((call_stack_) ? new ICPDev::Gyeol::Schema::SavedCallFrameT(*call_stack_) : nullptr); }
  pending_choices.reserve(o.pending_choices.size());
  for (const auto &pending_choices_ : o.pending_choices) { pending_choices.emplace_back((pending_choices_) ? new ICPDev::Gyeol::Schema::SavedPendingChoiceT(*pending_choices_) : nullptr); }
  visit_counts.reserve(o.visit_counts.size());
  for (const auto &visit_counts_ : o.visit_counts) { visit_counts.emplace_back((visit_counts_) ? new ICPDev::Gyeol::Schema::SavedVisitCountT(*visit_counts_) : nullptr); }
}

inline SaveStateT &SaveStateT::operator=(SaveStateT o) FLATBUFFERS_NOEXCEPT {
  std::swap(version, o.version);
  std::swap(story_version, o.story_version);
  std::swap(current_node_name, o.current_node_name);
  std::swap(pc, o.pc);
  std::swap(finished, o.finished);
  std::swap(variables, o.variables);
  std::swap(call_stack, o.call_stack);
  std::swap(pending_choices, o.pending_choices);
  std::swap(visit_counts, o.visit_counts);
  std::swap(chosen_once_choices, o.chosen_once_choices);
  return *this;
}

inline SaveStateT *SaveState::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SaveStateT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SaveState::UnPackTo(SaveStateT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); if (_e) _o->version = _e->str(); }
  { auto _e = story_version(); if (_e) _o->story_version = _e->str(); }
  { auto _e = current_node_name(); if (_e) _o->current_node_name = _e->str(); }
  { auto _e = pc(); _o->pc = _e; }
  { auto _e = finished(); _o->finished = _e; }
  { auto _e = variables(); if (_e) { _o->variables.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->variables[_i]) { _e->Get(_i)->UnPackTo(_o->variables[_i].get(), _resolver); } else { _o->variables[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::SavedVarT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->variables.resize(0); } }
  { auto _e = call_stack(); if (_e) { _o->call_stack.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->call_stack[_i]) { _e->Get(_i)->UnPackTo(_o->call_stack[_i].get(), _resolver); } else { _o->call_stack[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::SavedCallFrameT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->call_stack.resize(0); } }
  { auto _e = pending_choices(); if (_e) { _o->pending_choices.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->pending_choices[_i]) { _e->Get(_i)->UnPackTo(_o->pending_choices[_i].get(), _resolver); } else { _o->pending_choices[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::SavedPendingChoiceT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->pending_choices.resize(0); } }
  { auto _e = visit_counts(); if (_e) { _o->visit_counts.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->visit_counts[_i]) { _e->Get(_i)->UnPackTo(_o->visit_counts[_i].get(), _resolver); } else { _o->visit_counts[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::SavedVisitCountT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->visit_counts.resize(0); } }
  { auto _e = chosen_once_choices(); if (_e) { _o->chosen_once_choices.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->chosen_once_choices[_i] = _e->Get(_i)->str(); } } else { _o->chosen_once_choices.resize(0); } }
}

inline ::flatbuffers::Offset<SaveState> SaveState::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SaveStateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSaveState(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SaveState> CreateSaveState(::flatbuffers::FlatBufferBuilder &_fbb, const SaveStateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SaveStateT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _story_version = _o->story_version.empty() ? 0 : _fbb.CreateString(_o->story_version);
  auto _current_node_name = _o->current_node_name.empty() ? 0 : _fbb.CreateString(_o->current_node_name);
  auto _pc = _o->pc;
  auto _finished = _o->finished;
  auto _variables = _o->variables.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVar>> (_o->variables.size(), [](size_t i, _VectorArgs *__va) { return CreateSavedVar(*__va->__fbb, __va->__o->variables[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _call_stack = _o->call_stack.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedCallFrame>> (_o->call_stack.size(), [](size_t i, _VectorArgs *__va) { return CreateSavedCallFrame(*__va->__fbb, __va->__o->call_stack[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _pending_choices = _o->pending_choices.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedPendingChoice>> (_o->pending_choices.size(), [](size_t i, _VectorArgs *__va) { return CreateSavedPendingChoice(*__va->__fbb, __va->__o->pending_choices[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _visit_counts = _o->visit_counts.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVisitCount>> (_o->visit_counts.size(), [](size_t i, _VectorArgs *__va) { return CreateSavedVisitCount(*__va->__fbb, __va->__o->visit_counts[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _chosen_once_choices = _o->chosen_once_choices.size() ? _fbb.CreateVectorOfStrings(_o->chosen_once_choices) : 0;
  return ICPDev::Gyeol::Schema::CreateSaveState(
      _fbb,
      _version,
      _story_version,
      _current_node_name,
      _pc,
      _finished,
      _variables,
      _call_stack,
      _pending_choices,
      _visit_counts,
      _chosen_once_choices);
}

inline StoryT::StoryT(const StoryT &o)
      : version(o.version),
        string_pool(o.string_pool),
        line_ids(o.line_ids),
        start_node_name(o.start_node_name) {
  global_vars.reserve(o.global_vars.size());
  for (const auto &global_vars_ : o.global_vars) { global_vars.emplace_back((global_vars_) ? new ICPDev::Gyeol::Schema::SetVarT(*global_vars_) : nullptr); }
  nodes.reserve(o.nodes.size());
  for (const auto &nodes_ : o.nodes) { nodes.emplace_back((nodes_) ? new ICPDev::Gyeol::Schema::NodeT(*nodes_) : nullptr); }
  characters.reserve(o.characters.size());
  for (const auto &characters_ : o.characters) { characters.emplace_back((characters_) ? new ICPDev::Gyeol::Schema::CharacterDefT(*characters_) : nullptr); }
}

inline StoryT &StoryT::operator=(StoryT o) FLATBUFFERS_NOEXCEPT {
  std::swap(version, o.version);
  std::swap(string_pool, o.string_pool);
  std::swap(line_ids, o.line_ids);
  std::swap(global_vars, o.global_vars);
  std::swap(nodes, o.nodes);
  std::swap(start_node_name, o.start_node_name);
  std::swap(characters, o.characters);
  return *this;
}

inline StoryT *Story::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<StoryT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Story::UnPackTo(StoryT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); if (_e) _o->version = _e->str(); }
  { auto _e = string_pool(); if (_e) { _o->string_pool.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->string_pool[_i] = _e->Get(_i)->str(); } } else { _o->string_pool.resize(0); } }
  { auto _e = line_ids(); if (_e) { _o->line_ids.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->line_ids[_i] = _e->Get(_i)->str(); } } else { _o->line_ids.resize(0); } }
  { auto _e = global_vars(); if (_e) { _o->global_vars.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->global_vars[_i]) { _e->Get(_i)->UnPackTo(_o->global_vars[_i].get(), _resolver); } else { _o->global_vars[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::SetVarT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->global_vars.resize(0); } }
  { auto _e = nodes(); if (_e) { _o->nodes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->nodes[_i]) { _e->Get(_i)->UnPackTo(_o->nodes[_i].get(), _resolver); } else { _o->nodes[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::NodeT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->nodes.resize(0); } }
  { auto _e = start_node_name(); if (_e) _o->start_node_name = _e->str(); }
  { auto _e = characters(); if (_e) { _o->characters.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->characters[_i]) { _e->Get(_i)->UnPackTo(_o->characters[_i].get(), _resolver); } else { _o->characters[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::CharacterDefT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->characters.resize(0); } }
}

inline ::flatbuffers::Offset<Story> Story::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StoryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStory(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Story> CreateStory(::flatbuffers::FlatBufferBuilder &_fbb, const StoryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StoryT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _string_pool = _o->string_pool.size() ? _fbb.CreateVectorOfStrings(_o->string_pool) : 0;
  auto _line_ids = _o->line_ids.size() ? _fbb.CreateVectorOfStrings(_o->line_ids) : 0;
  auto _global_vars = _o->global_vars.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>> (_o->global_vars.size(), [](size_t i, _VectorArgs *__va) { return CreateSetVar(*__va->__fbb, __va->__o->global_vars[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _nodes = _o->nodes.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>> (_o->nodes.size(), [](size_t i, _VectorArgs *__va) { return CreateNode(*__va->__fbb, __va->__o->nodes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _start_node_name = _o->start_node_name.empty() ? 0 : _fbb.CreateString(_o->start_node_name);
  auto _characters = _o->characters.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::CharacterDef>> (_o->characters.size(), [](size_t i, _VectorArgs *__va) { return CreateCharacterDef(*__va->__fbb, __va->__o->characters[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ICPDev::Gyeol::Schema::CreateStory(
      _fbb,
      _version,
      _string_pool,
      _line_ids,
      _global_vars,
      _nodes,
      _start_node_name,
      _characters);
}

inline bool VerifyValueData(::flatbuffers::Verifier &verifier, const void *obj, ValueData type) {
  switch (type) {
    case ValueData::NONE: {
      return true;
    }
    case ValueData::BoolValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::BoolValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueData::IntValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::IntValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueData::FloatValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::FloatValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueData::StringRef: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::StringRef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueData::ListValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::ListValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValueDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ValueData> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValueData(
        verifier,  values->Get(i), types->GetEnum<ValueData>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ValueDataUnion::UnPack(const void *obj, ValueData type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case ValueData::BoolValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::BoolValue *>(obj);
      return ptr->UnPack(resolver);
    }
    case ValueData::IntValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::IntValue *>(obj);
      return ptr->UnPack(resolver);
    }
    case ValueData::FloatValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::FloatValue *>(obj);
      return ptr->UnPack(resolver);
    }
    case ValueData::StringRef: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::StringRef *>(obj);
      return ptr->UnPack(resolver);
    }
    case ValueData::ListValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::ListValue *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> ValueDataUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case ValueData::BoolValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::BoolValueT *>(value);
      return CreateBoolValue(_fbb, ptr, _rehasher).Union();
    }
    case ValueData::IntValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::IntValueT *>(value);
      return CreateIntValue(_fbb, ptr, _rehasher).Union();
    }
    case ValueData::FloatValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::FloatValueT *>(value);
      return CreateFloatValue(_fbb, ptr, _rehasher).Union();
    }
    case ValueData::StringRef: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::StringRefT *>(value);
      return CreateStringRef(_fbb, ptr, _rehasher).Union();
    }
    case ValueData::ListValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::ListValueT *>(value);
      return CreateListValue(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ValueDataUnion::ValueDataUnion(const ValueDataUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ValueData::BoolValue: {
      value = new ICPDev::Gyeol::Schema::BoolValueT(*reinterpret_cast<ICPDev::Gyeol::Schema::BoolValueT *>(u.value));
      break;
    }
    case ValueData::IntValue: {
      value = new ICPDev::Gyeol::Schema::IntValueT(*reinterpret_cast<ICPDev::Gyeol::Schema::IntValueT *>(u.value));
      break;
    }
    case ValueData::FloatValue: {
      value = new ICPDev::Gyeol::Schema::FloatValueT(*reinterpret_cast<ICPDev::Gyeol::Schema::FloatValueT *>(u.value));
      break;
    }
    case ValueData::StringRef: {
      value = new ICPDev::Gyeol::Schema::StringRefT(*reinterpret_cast<ICPDev::Gyeol::Schema::StringRefT *>(u.value));
      break;
    }
    case ValueData::ListValue: {
      value = new ICPDev::Gyeol::Schema::ListValueT(*reinterpret_cast<ICPDev::Gyeol::Schema::ListValueT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ValueDataUnion::Reset() {
  switch (type) {
    case ValueData::BoolValue: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::BoolValueT *>(value);
      delete ptr;
      break;
    }
    case ValueData::IntValue: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::IntValueT *>(value);
      delete ptr;
      break;
    }
    case ValueData::FloatValue: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::FloatValueT *>(value);
      delete ptr;
      break;
    }
    case ValueData::StringRef: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::StringRefT *>(value);
      delete ptr;
      break;
    }
    case ValueData::ListValue: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::ListValueT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ValueData::NONE;
}

inline bool VerifyOpData(::flatbuffers::Verifier &verifier, const void *obj, OpData type) {
  switch (type) {
    case OpData::NONE: {
      return true;
    }
    case OpData::Line: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Line *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::Choice: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Choice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::Jump: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Jump *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::Command: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Command *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::SetVar: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::SetVar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::Condition: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Condition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::Random: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Random *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::Return: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Return *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::CallWithReturn: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::CallWithReturn *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOpDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<OpData> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOpData(
        verifier,  values->Get(i), types->GetEnum<OpData>(i))) {
      return false;
    }
  }
  return true;
}

inline void *OpDataUnion::UnPack(const void *obj, OpData type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case OpData::Line: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Line *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::Choice: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Choice *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::Jump: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Jump *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::Command: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Command *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::SetVar: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::SetVar *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::Condition: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Condition *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::Random: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Random *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::Return: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Return *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::CallWithReturn: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::CallWithReturn *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> OpDataUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case OpData::Line: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::LineT *>(value);
      return CreateLine(_fbb, ptr, _rehasher).Union();
    }
    case OpData::Choice: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::ChoiceT *>(value);
      return CreateChoice(_fbb, ptr, _rehasher).Union();
    }
    case OpData::Jump: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::JumpT *>(value);
      return CreateJump(_fbb, ptr, _rehasher).Union();
    }
    case OpData::Command: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::CommandT *>(value);
      return CreateCommand(_fbb, ptr, _rehasher).Union();
    }
    case OpData::SetVar: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::SetVarT *>(value);
      return CreateSetVar(_fbb, ptr, _rehasher).Union();
    }
    case OpData::Condition: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::ConditionT *>(value);
      return CreateCondition(_fbb, ptr, _rehasher).Union();
    }
    case OpData::Random: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::RandomT *>(value);
      return CreateRandom(_fbb, ptr, _rehasher).Union();
    }
    case OpData::Return: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::ReturnT *>(value);
      return CreateReturn(_fbb, ptr, _rehasher).Union();
    }
    case OpData::CallWithReturn: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::CallWithReturnT *>(value);
      return CreateCallWithReturn(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline OpDataUnion::OpDataUnion(const OpDataUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case OpData::Line: {
      value = new ICPDev::Gyeol::Schema::LineT(*reinterpret_cast<ICPDev::Gyeol::Schema::LineT *>(u.value));
      break;
    }
    case OpData::Choice: {
      value = new ICPDev::Gyeol::Schema::ChoiceT(*reinterpret_cast<ICPDev::Gyeol::Schema::ChoiceT *>(u.value));
      break;
    }
    case OpData::Jump: {
      value = new ICPDev::Gyeol::Schema::JumpT(*reinterpret_cast<ICPDev::Gyeol::Schema::JumpT *>(u.value));
      break;
    }
    case OpData::Command: {
      value = new ICPDev::Gyeol::Schema::CommandT(*reinterpret_cast<ICPDev::Gyeol::Schema::CommandT *>(u.value));
      break;
    }
    case OpData::SetVar: {
      value = new ICPDev::Gyeol::Schema::SetVarT(*reinterpret_cast<ICPDev::Gyeol::Schema::SetVarT *>(u.value));
      break;
    }
    case OpData::Condition: {
      value = new ICPDev::Gyeol::Schema::ConditionT(*reinterpret_cast<ICPDev::Gyeol::Schema::ConditionT *>(u.value));
      break;
    }
    case OpData::Random: {
      value = new ICPDev::Gyeol::Schema::RandomT(*reinterpret_cast<ICPDev::Gyeol::Schema::RandomT *>(u.value));
      break;
    }
    case OpData::Return: {
      value = new ICPDev::Gyeol::Schema::ReturnT(*reinterpret_cast<ICPDev::Gyeol::Schema::ReturnT *>(u.value));
      break;
    }
    case OpData::CallWithReturn: {
      value = new ICPDev::Gyeol::Schema::CallWithReturnT(*reinterpret_cast<ICPDev::Gyeol::Schema::CallWithReturnT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void OpDataUnion::Reset() {
  switch (type) {
    case OpData::Line: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::LineT *>(value);
      delete ptr;
      break;
    }
    case OpData::Choice: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::ChoiceT *>(value);
      delete ptr;
      break;
    }
    case OpData::Jump: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::JumpT *>(value);
      delete ptr;
      break;
    }
    case OpData::Command: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::CommandT *>(value);
      delete ptr;
      break;
    }
    case OpData::SetVar: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::SetVarT *>(value);
      delete ptr;
      break;
    }
    case OpData::Condition: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::ConditionT *>(value);
      delete ptr;
      break;
    }
    case OpData::Random: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::RandomT *>(value);
      delete ptr;
      break;
    }
    case OpData::Return: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::ReturnT *>(value);
      delete ptr;
      break;
    }
    case OpData::CallWithReturn: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::CallWithReturnT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = OpData::NONE;
}

inline const ICPDev::Gyeol::Schema::Story *GetStory(const void *buf) {
  return ::flatbuffers::GetRoot<ICPDev::Gyeol::Schema::Story>(buf);
}

inline const ICPDev::Gyeol::Schema::Story *GetSizePrefixedStory(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ICPDev::Gyeol::Schema::Story>(buf);
}

inline bool VerifyStoryBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ICPDev::Gyeol::Schema::Story>(nullptr);
}

inline bool VerifySizePrefixedStoryBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ICPDev::Gyeol::Schema::Story>(nullptr);
}

inline void FinishStoryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ICPDev::Gyeol::Schema::Story> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedStoryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ICPDev::Gyeol::Schema::Story> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<ICPDev::Gyeol::Schema::StoryT> UnPackStory(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ICPDev::Gyeol::Schema::StoryT>(GetStory(buf)->UnPack(res));
}

inline std::unique_ptr<ICPDev::Gyeol::Schema::StoryT> UnPackSizePrefixedStory(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ICPDev::Gyeol::Schema::StoryT>(GetSizePrefixedStory(buf)->UnPack(res));
}

}  // namespace Schema
}  // namespace Gyeol
}  // namespace ICPDev

#endif  // FLATBUFFERS_GENERATED_GYEOL_ICPDEV_GYEOL_SCHEMA_H_
