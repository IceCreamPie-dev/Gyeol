// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GYEOL_ICPDEV_GYEOL_SCHEMA_H_
#define FLATBUFFERS_GENERATED_GYEOL_ICPDEV_GYEOL_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace ICPDev {
namespace Gyeol {
namespace Schema {

struct BoolValue;
struct BoolValueBuilder;
struct BoolValueT;

struct IntValue;
struct IntValueBuilder;
struct IntValueT;

struct FloatValue;
struct FloatValueBuilder;
struct FloatValueT;

struct StringRef;
struct StringRefBuilder;
struct StringRefT;

struct Line;
struct LineBuilder;
struct LineT;

struct Choice;
struct ChoiceBuilder;
struct ChoiceT;

struct Jump;
struct JumpBuilder;
struct JumpT;

struct Command;
struct CommandBuilder;
struct CommandT;

struct SetVar;
struct SetVarBuilder;
struct SetVarT;

struct Condition;
struct ConditionBuilder;
struct ConditionT;

struct Instruction;
struct InstructionBuilder;
struct InstructionT;

struct Node;
struct NodeBuilder;
struct NodeT;

struct Story;
struct StoryBuilder;
struct StoryT;

enum class Operator : int8_t {
  Equal = 0,
  NotEqual = 1,
  Greater = 2,
  Less = 3,
  GreaterOrEqual = 4,
  LessOrEqual = 5,
  MIN = Equal,
  MAX = LessOrEqual
};

inline const Operator (&EnumValuesOperator())[6] {
  static const Operator values[] = {
    Operator::Equal,
    Operator::NotEqual,
    Operator::Greater,
    Operator::Less,
    Operator::GreaterOrEqual,
    Operator::LessOrEqual
  };
  return values;
}

inline const char * const *EnumNamesOperator() {
  static const char * const names[7] = {
    "Equal",
    "NotEqual",
    "Greater",
    "Less",
    "GreaterOrEqual",
    "LessOrEqual",
    nullptr
  };
  return names;
}

inline const char *EnumNameOperator(Operator e) {
  if (::flatbuffers::IsOutRange(e, Operator::Equal, Operator::LessOrEqual)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOperator()[index];
}

enum class ValueData : uint8_t {
  NONE = 0,
  BoolValue = 1,
  IntValue = 2,
  FloatValue = 3,
  StringRef = 4,
  MIN = NONE,
  MAX = StringRef
};

inline const ValueData (&EnumValuesValueData())[5] {
  static const ValueData values[] = {
    ValueData::NONE,
    ValueData::BoolValue,
    ValueData::IntValue,
    ValueData::FloatValue,
    ValueData::StringRef
  };
  return values;
}

inline const char * const *EnumNamesValueData() {
  static const char * const names[6] = {
    "NONE",
    "BoolValue",
    "IntValue",
    "FloatValue",
    "StringRef",
    nullptr
  };
  return names;
}

inline const char *EnumNameValueData(ValueData e) {
  if (::flatbuffers::IsOutRange(e, ValueData::NONE, ValueData::StringRef)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValueData()[index];
}

template<typename T> struct ValueDataTraits {
  static const ValueData enum_value = ValueData::NONE;
};

template<> struct ValueDataTraits<ICPDev::Gyeol::Schema::BoolValue> {
  static const ValueData enum_value = ValueData::BoolValue;
};

template<> struct ValueDataTraits<ICPDev::Gyeol::Schema::IntValue> {
  static const ValueData enum_value = ValueData::IntValue;
};

template<> struct ValueDataTraits<ICPDev::Gyeol::Schema::FloatValue> {
  static const ValueData enum_value = ValueData::FloatValue;
};

template<> struct ValueDataTraits<ICPDev::Gyeol::Schema::StringRef> {
  static const ValueData enum_value = ValueData::StringRef;
};

template<typename T> struct ValueDataUnionTraits {
  static const ValueData enum_value = ValueData::NONE;
};

template<> struct ValueDataUnionTraits<ICPDev::Gyeol::Schema::BoolValueT> {
  static const ValueData enum_value = ValueData::BoolValue;
};

template<> struct ValueDataUnionTraits<ICPDev::Gyeol::Schema::IntValueT> {
  static const ValueData enum_value = ValueData::IntValue;
};

template<> struct ValueDataUnionTraits<ICPDev::Gyeol::Schema::FloatValueT> {
  static const ValueData enum_value = ValueData::FloatValue;
};

template<> struct ValueDataUnionTraits<ICPDev::Gyeol::Schema::StringRefT> {
  static const ValueData enum_value = ValueData::StringRef;
};

struct ValueDataUnion {
  ValueData type;
  void *value;

  ValueDataUnion() : type(ValueData::NONE), value(nullptr) {}
  ValueDataUnion(ValueDataUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ValueData::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ValueDataUnion(const ValueDataUnion &);
  ValueDataUnion &operator=(const ValueDataUnion &u)
    { ValueDataUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ValueDataUnion &operator=(ValueDataUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ValueDataUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ValueDataUnionTraits<RT>::enum_value;
    if (type != ValueData::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, ValueData type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  ICPDev::Gyeol::Schema::BoolValueT *AsBoolValue() {
    return type == ValueData::BoolValue ?
      reinterpret_cast<ICPDev::Gyeol::Schema::BoolValueT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::BoolValueT *AsBoolValue() const {
    return type == ValueData::BoolValue ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::BoolValueT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::IntValueT *AsIntValue() {
    return type == ValueData::IntValue ?
      reinterpret_cast<ICPDev::Gyeol::Schema::IntValueT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::IntValueT *AsIntValue() const {
    return type == ValueData::IntValue ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::IntValueT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::FloatValueT *AsFloatValue() {
    return type == ValueData::FloatValue ?
      reinterpret_cast<ICPDev::Gyeol::Schema::FloatValueT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::FloatValueT *AsFloatValue() const {
    return type == ValueData::FloatValue ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::FloatValueT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::StringRefT *AsStringRef() {
    return type == ValueData::StringRef ?
      reinterpret_cast<ICPDev::Gyeol::Schema::StringRefT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::StringRefT *AsStringRef() const {
    return type == ValueData::StringRef ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::StringRefT *>(value) : nullptr;
  }
};

bool VerifyValueData(::flatbuffers::Verifier &verifier, const void *obj, ValueData type);
bool VerifyValueDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ValueData> *types);

enum class OpData : uint8_t {
  NONE = 0,
  Line = 1,
  Choice = 2,
  Jump = 3,
  Command = 4,
  SetVar = 5,
  Condition = 6,
  MIN = NONE,
  MAX = Condition
};

inline const OpData (&EnumValuesOpData())[7] {
  static const OpData values[] = {
    OpData::NONE,
    OpData::Line,
    OpData::Choice,
    OpData::Jump,
    OpData::Command,
    OpData::SetVar,
    OpData::Condition
  };
  return values;
}

inline const char * const *EnumNamesOpData() {
  static const char * const names[8] = {
    "NONE",
    "Line",
    "Choice",
    "Jump",
    "Command",
    "SetVar",
    "Condition",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpData(OpData e) {
  if (::flatbuffers::IsOutRange(e, OpData::NONE, OpData::Condition)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpData()[index];
}

template<typename T> struct OpDataTraits {
  static const OpData enum_value = OpData::NONE;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Line> {
  static const OpData enum_value = OpData::Line;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Choice> {
  static const OpData enum_value = OpData::Choice;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Jump> {
  static const OpData enum_value = OpData::Jump;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Command> {
  static const OpData enum_value = OpData::Command;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::SetVar> {
  static const OpData enum_value = OpData::SetVar;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Condition> {
  static const OpData enum_value = OpData::Condition;
};

template<typename T> struct OpDataUnionTraits {
  static const OpData enum_value = OpData::NONE;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::LineT> {
  static const OpData enum_value = OpData::Line;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::ChoiceT> {
  static const OpData enum_value = OpData::Choice;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::JumpT> {
  static const OpData enum_value = OpData::Jump;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::CommandT> {
  static const OpData enum_value = OpData::Command;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::SetVarT> {
  static const OpData enum_value = OpData::SetVar;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::ConditionT> {
  static const OpData enum_value = OpData::Condition;
};

struct OpDataUnion {
  OpData type;
  void *value;

  OpDataUnion() : type(OpData::NONE), value(nullptr) {}
  OpDataUnion(OpDataUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(OpData::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  OpDataUnion(const OpDataUnion &);
  OpDataUnion &operator=(const OpDataUnion &u)
    { OpDataUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  OpDataUnion &operator=(OpDataUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~OpDataUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = OpDataUnionTraits<RT>::enum_value;
    if (type != OpData::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, OpData type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  ICPDev::Gyeol::Schema::LineT *AsLine() {
    return type == OpData::Line ?
      reinterpret_cast<ICPDev::Gyeol::Schema::LineT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::LineT *AsLine() const {
    return type == OpData::Line ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::LineT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::ChoiceT *AsChoice() {
    return type == OpData::Choice ?
      reinterpret_cast<ICPDev::Gyeol::Schema::ChoiceT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::ChoiceT *AsChoice() const {
    return type == OpData::Choice ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::ChoiceT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::JumpT *AsJump() {
    return type == OpData::Jump ?
      reinterpret_cast<ICPDev::Gyeol::Schema::JumpT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::JumpT *AsJump() const {
    return type == OpData::Jump ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::JumpT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::CommandT *AsCommand() {
    return type == OpData::Command ?
      reinterpret_cast<ICPDev::Gyeol::Schema::CommandT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::CommandT *AsCommand() const {
    return type == OpData::Command ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::CommandT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::SetVarT *AsSetVar() {
    return type == OpData::SetVar ?
      reinterpret_cast<ICPDev::Gyeol::Schema::SetVarT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::SetVarT *AsSetVar() const {
    return type == OpData::SetVar ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::SetVarT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::ConditionT *AsCondition() {
    return type == OpData::Condition ?
      reinterpret_cast<ICPDev::Gyeol::Schema::ConditionT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::ConditionT *AsCondition() const {
    return type == OpData::Condition ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::ConditionT *>(value) : nullptr;
  }
};

bool VerifyOpData(::flatbuffers::Verifier &verifier, const void *obj, OpData type);
bool VerifyOpDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<OpData> *types);

struct BoolValueT : public ::flatbuffers::NativeTable {
  typedef BoolValue TableType;
  bool val = false;
};

struct BoolValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoolValueT NativeTableType;
  typedef BoolValueBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  bool val() const {
    return GetField<uint8_t>(VT_VAL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VAL, 1) &&
           verifier.EndTable();
  }
  BoolValueT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BoolValueT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BoolValue> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BoolValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BoolValueBuilder {
  typedef BoolValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(bool val) {
    fbb_.AddElement<uint8_t>(BoolValue::VT_VAL, static_cast<uint8_t>(val), 0);
  }
  explicit BoolValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BoolValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BoolValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BoolValue> CreateBoolValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool val = false) {
  BoolValueBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct BoolValue::Traits {
  using type = BoolValue;
  static auto constexpr Create = CreateBoolValue;
};

::flatbuffers::Offset<BoolValue> CreateBoolValue(::flatbuffers::FlatBufferBuilder &_fbb, const BoolValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IntValueT : public ::flatbuffers::NativeTable {
  typedef IntValue TableType;
  int32_t val = 0;
};

struct IntValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntValueT NativeTableType;
  typedef IntValueBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  int32_t val() const {
    return GetField<int32_t>(VT_VAL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VAL, 4) &&
           verifier.EndTable();
  }
  IntValueT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IntValueT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<IntValue> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IntValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IntValueBuilder {
  typedef IntValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(int32_t val) {
    fbb_.AddElement<int32_t>(IntValue::VT_VAL, val, 0);
  }
  explicit IntValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntValue> CreateIntValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t val = 0) {
  IntValueBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct IntValue::Traits {
  using type = IntValue;
  static auto constexpr Create = CreateIntValue;
};

::flatbuffers::Offset<IntValue> CreateIntValue(::flatbuffers::FlatBufferBuilder &_fbb, const IntValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloatValueT : public ::flatbuffers::NativeTable {
  typedef FloatValue TableType;
  float val = 0.0f;
};

struct FloatValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloatValueT NativeTableType;
  typedef FloatValueBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  float val() const {
    return GetField<float>(VT_VAL, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VAL, 4) &&
           verifier.EndTable();
  }
  FloatValueT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloatValueT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FloatValue> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FloatValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloatValueBuilder {
  typedef FloatValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(float val) {
    fbb_.AddElement<float>(FloatValue::VT_VAL, val, 0.0f);
  }
  explicit FloatValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloatValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloatValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloatValue> CreateFloatValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float val = 0.0f) {
  FloatValueBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct FloatValue::Traits {
  using type = FloatValue;
  static auto constexpr Create = CreateFloatValue;
};

::flatbuffers::Offset<FloatValue> CreateFloatValue(::flatbuffers::FlatBufferBuilder &_fbb, const FloatValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StringRefT : public ::flatbuffers::NativeTable {
  typedef StringRef TableType;
  int32_t index = 0;
};

struct StringRef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringRefT NativeTableType;
  typedef StringRefBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4
  };
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           verifier.EndTable();
  }
  StringRefT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StringRefT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StringRef> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StringRefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StringRefBuilder {
  typedef StringRef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(StringRef::VT_INDEX, index, 0);
  }
  explicit StringRefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringRef>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringRef> CreateStringRef(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index = 0) {
  StringRefBuilder builder_(_fbb);
  builder_.add_index(index);
  return builder_.Finish();
}

struct StringRef::Traits {
  using type = StringRef;
  static auto constexpr Create = CreateStringRef;
};

::flatbuffers::Offset<StringRef> CreateStringRef(::flatbuffers::FlatBufferBuilder &_fbb, const StringRefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LineT : public ::flatbuffers::NativeTable {
  typedef Line TableType;
  int32_t character_id = -1;
  int32_t text_id = 0;
  int32_t voice_asset_id = -1;
};

struct Line FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LineT NativeTableType;
  typedef LineBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHARACTER_ID = 4,
    VT_TEXT_ID = 6,
    VT_VOICE_ASSET_ID = 8
  };
  int32_t character_id() const {
    return GetField<int32_t>(VT_CHARACTER_ID, -1);
  }
  int32_t text_id() const {
    return GetField<int32_t>(VT_TEXT_ID, 0);
  }
  int32_t voice_asset_id() const {
    return GetField<int32_t>(VT_VOICE_ASSET_ID, -1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHARACTER_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_TEXT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_VOICE_ASSET_ID, 4) &&
           verifier.EndTable();
  }
  LineT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LineT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Line> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LineT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LineBuilder {
  typedef Line Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_character_id(int32_t character_id) {
    fbb_.AddElement<int32_t>(Line::VT_CHARACTER_ID, character_id, -1);
  }
  void add_text_id(int32_t text_id) {
    fbb_.AddElement<int32_t>(Line::VT_TEXT_ID, text_id, 0);
  }
  void add_voice_asset_id(int32_t voice_asset_id) {
    fbb_.AddElement<int32_t>(Line::VT_VOICE_ASSET_ID, voice_asset_id, -1);
  }
  explicit LineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Line> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Line>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Line> CreateLine(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t character_id = -1,
    int32_t text_id = 0,
    int32_t voice_asset_id = -1) {
  LineBuilder builder_(_fbb);
  builder_.add_voice_asset_id(voice_asset_id);
  builder_.add_text_id(text_id);
  builder_.add_character_id(character_id);
  return builder_.Finish();
}

struct Line::Traits {
  using type = Line;
  static auto constexpr Create = CreateLine;
};

::flatbuffers::Offset<Line> CreateLine(::flatbuffers::FlatBufferBuilder &_fbb, const LineT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ChoiceT : public ::flatbuffers::NativeTable {
  typedef Choice TableType;
  int32_t text_id = 0;
  int32_t target_node_name_id = 0;
  int32_t condition_var_id = -1;
};

struct Choice FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChoiceT NativeTableType;
  typedef ChoiceBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT_ID = 4,
    VT_TARGET_NODE_NAME_ID = 6,
    VT_CONDITION_VAR_ID = 8
  };
  int32_t text_id() const {
    return GetField<int32_t>(VT_TEXT_ID, 0);
  }
  int32_t target_node_name_id() const {
    return GetField<int32_t>(VT_TARGET_NODE_NAME_ID, 0);
  }
  int32_t condition_var_id() const {
    return GetField<int32_t>(VT_CONDITION_VAR_ID, -1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TEXT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_TARGET_NODE_NAME_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_CONDITION_VAR_ID, 4) &&
           verifier.EndTable();
  }
  ChoiceT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ChoiceT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Choice> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ChoiceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ChoiceBuilder {
  typedef Choice Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text_id(int32_t text_id) {
    fbb_.AddElement<int32_t>(Choice::VT_TEXT_ID, text_id, 0);
  }
  void add_target_node_name_id(int32_t target_node_name_id) {
    fbb_.AddElement<int32_t>(Choice::VT_TARGET_NODE_NAME_ID, target_node_name_id, 0);
  }
  void add_condition_var_id(int32_t condition_var_id) {
    fbb_.AddElement<int32_t>(Choice::VT_CONDITION_VAR_ID, condition_var_id, -1);
  }
  explicit ChoiceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Choice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Choice>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Choice> CreateChoice(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t text_id = 0,
    int32_t target_node_name_id = 0,
    int32_t condition_var_id = -1) {
  ChoiceBuilder builder_(_fbb);
  builder_.add_condition_var_id(condition_var_id);
  builder_.add_target_node_name_id(target_node_name_id);
  builder_.add_text_id(text_id);
  return builder_.Finish();
}

struct Choice::Traits {
  using type = Choice;
  static auto constexpr Create = CreateChoice;
};

::flatbuffers::Offset<Choice> CreateChoice(::flatbuffers::FlatBufferBuilder &_fbb, const ChoiceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JumpT : public ::flatbuffers::NativeTable {
  typedef Jump TableType;
  int32_t target_node_name_id = 0;
  bool is_call = false;
};

struct Jump FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JumpT NativeTableType;
  typedef JumpBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET_NODE_NAME_ID = 4,
    VT_IS_CALL = 6
  };
  int32_t target_node_name_id() const {
    return GetField<int32_t>(VT_TARGET_NODE_NAME_ID, 0);
  }
  bool is_call() const {
    return GetField<uint8_t>(VT_IS_CALL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TARGET_NODE_NAME_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_CALL, 1) &&
           verifier.EndTable();
  }
  JumpT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JumpT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Jump> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JumpT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JumpBuilder {
  typedef Jump Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target_node_name_id(int32_t target_node_name_id) {
    fbb_.AddElement<int32_t>(Jump::VT_TARGET_NODE_NAME_ID, target_node_name_id, 0);
  }
  void add_is_call(bool is_call) {
    fbb_.AddElement<uint8_t>(Jump::VT_IS_CALL, static_cast<uint8_t>(is_call), 0);
  }
  explicit JumpBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Jump> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Jump>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Jump> CreateJump(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t target_node_name_id = 0,
    bool is_call = false) {
  JumpBuilder builder_(_fbb);
  builder_.add_target_node_name_id(target_node_name_id);
  builder_.add_is_call(is_call);
  return builder_.Finish();
}

struct Jump::Traits {
  using type = Jump;
  static auto constexpr Create = CreateJump;
};

::flatbuffers::Offset<Jump> CreateJump(::flatbuffers::FlatBufferBuilder &_fbb, const JumpT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CommandT : public ::flatbuffers::NativeTable {
  typedef Command TableType;
  int32_t type_id = 0;
  std::vector<int32_t> params{};
};

struct Command FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandT NativeTableType;
  typedef CommandBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE_ID = 4,
    VT_PARAMS = 6
  };
  int32_t type_id() const {
    return GetField<int32_t>(VT_TYPE_ID, 0);
  }
  const ::flatbuffers::Vector<int32_t> *params() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PARAMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE_ID, 4) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           verifier.EndTable();
  }
  CommandT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CommandT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Command> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CommandBuilder {
  typedef Command Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type_id(int32_t type_id) {
    fbb_.AddElement<int32_t>(Command::VT_TYPE_ID, type_id, 0);
  }
  void add_params(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> params) {
    fbb_.AddOffset(Command::VT_PARAMS, params);
  }
  explicit CommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Command> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Command>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Command> CreateCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> params = 0) {
  CommandBuilder builder_(_fbb);
  builder_.add_params(params);
  builder_.add_type_id(type_id);
  return builder_.Finish();
}

struct Command::Traits {
  using type = Command;
  static auto constexpr Create = CreateCommand;
};

inline ::flatbuffers::Offset<Command> CreateCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type_id = 0,
    const std::vector<int32_t> *params = nullptr) {
  auto params__ = params ? _fbb.CreateVector<int32_t>(*params) : 0;
  return ICPDev::Gyeol::Schema::CreateCommand(
      _fbb,
      type_id,
      params__);
}

::flatbuffers::Offset<Command> CreateCommand(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetVarT : public ::flatbuffers::NativeTable {
  typedef SetVar TableType;
  int32_t var_name_id = 0;
  ICPDev::Gyeol::Schema::ValueDataUnion value{};
};

struct SetVar FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetVarT NativeTableType;
  typedef SetVarBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAR_NAME_ID = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  int32_t var_name_id() const {
    return GetField<int32_t>(VT_VAR_NAME_ID, 0);
  }
  ICPDev::Gyeol::Schema::ValueData value_type() const {
    return static_cast<ICPDev::Gyeol::Schema::ValueData>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const ICPDev::Gyeol::Schema::BoolValue *value_as_BoolValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::BoolValue ? static_cast<const ICPDev::Gyeol::Schema::BoolValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::IntValue *value_as_IntValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::IntValue ? static_cast<const ICPDev::Gyeol::Schema::IntValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::FloatValue *value_as_FloatValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::FloatValue ? static_cast<const ICPDev::Gyeol::Schema::FloatValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::StringRef *value_as_StringRef() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::StringRef ? static_cast<const ICPDev::Gyeol::Schema::StringRef *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VAR_NAME_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValueData(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
  SetVarT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetVarT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetVar> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetVarT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ICPDev::Gyeol::Schema::BoolValue *SetVar::value_as<ICPDev::Gyeol::Schema::BoolValue>() const {
  return value_as_BoolValue();
}

template<> inline const ICPDev::Gyeol::Schema::IntValue *SetVar::value_as<ICPDev::Gyeol::Schema::IntValue>() const {
  return value_as_IntValue();
}

template<> inline const ICPDev::Gyeol::Schema::FloatValue *SetVar::value_as<ICPDev::Gyeol::Schema::FloatValue>() const {
  return value_as_FloatValue();
}

template<> inline const ICPDev::Gyeol::Schema::StringRef *SetVar::value_as<ICPDev::Gyeol::Schema::StringRef>() const {
  return value_as_StringRef();
}

struct SetVarBuilder {
  typedef SetVar Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_var_name_id(int32_t var_name_id) {
    fbb_.AddElement<int32_t>(SetVar::VT_VAR_NAME_ID, var_name_id, 0);
  }
  void add_value_type(ICPDev::Gyeol::Schema::ValueData value_type) {
    fbb_.AddElement<uint8_t>(SetVar::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(SetVar::VT_VALUE, value);
  }
  explicit SetVarBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetVar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetVar>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetVar> CreateSetVar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t var_name_id = 0,
    ICPDev::Gyeol::Schema::ValueData value_type = ICPDev::Gyeol::Schema::ValueData::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  SetVarBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_var_name_id(var_name_id);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct SetVar::Traits {
  using type = SetVar;
  static auto constexpr Create = CreateSetVar;
};

::flatbuffers::Offset<SetVar> CreateSetVar(::flatbuffers::FlatBufferBuilder &_fbb, const SetVarT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConditionT : public ::flatbuffers::NativeTable {
  typedef Condition TableType;
  int32_t var_name_id = 0;
  ICPDev::Gyeol::Schema::Operator op = ICPDev::Gyeol::Schema::Operator::Equal;
  ICPDev::Gyeol::Schema::ValueDataUnion compare_value{};
  int32_t true_jump_node_id = 0;
  int32_t false_jump_node_id = 0;
};

struct Condition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConditionT NativeTableType;
  typedef ConditionBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAR_NAME_ID = 4,
    VT_OP = 6,
    VT_COMPARE_VALUE_TYPE = 8,
    VT_COMPARE_VALUE = 10,
    VT_TRUE_JUMP_NODE_ID = 12,
    VT_FALSE_JUMP_NODE_ID = 14
  };
  int32_t var_name_id() const {
    return GetField<int32_t>(VT_VAR_NAME_ID, 0);
  }
  ICPDev::Gyeol::Schema::Operator op() const {
    return static_cast<ICPDev::Gyeol::Schema::Operator>(GetField<int8_t>(VT_OP, 0));
  }
  ICPDev::Gyeol::Schema::ValueData compare_value_type() const {
    return static_cast<ICPDev::Gyeol::Schema::ValueData>(GetField<uint8_t>(VT_COMPARE_VALUE_TYPE, 0));
  }
  const void *compare_value() const {
    return GetPointer<const void *>(VT_COMPARE_VALUE);
  }
  template<typename T> const T *compare_value_as() const;
  const ICPDev::Gyeol::Schema::BoolValue *compare_value_as_BoolValue() const {
    return compare_value_type() == ICPDev::Gyeol::Schema::ValueData::BoolValue ? static_cast<const ICPDev::Gyeol::Schema::BoolValue *>(compare_value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::IntValue *compare_value_as_IntValue() const {
    return compare_value_type() == ICPDev::Gyeol::Schema::ValueData::IntValue ? static_cast<const ICPDev::Gyeol::Schema::IntValue *>(compare_value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::FloatValue *compare_value_as_FloatValue() const {
    return compare_value_type() == ICPDev::Gyeol::Schema::ValueData::FloatValue ? static_cast<const ICPDev::Gyeol::Schema::FloatValue *>(compare_value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::StringRef *compare_value_as_StringRef() const {
    return compare_value_type() == ICPDev::Gyeol::Schema::ValueData::StringRef ? static_cast<const ICPDev::Gyeol::Schema::StringRef *>(compare_value()) : nullptr;
  }
  int32_t true_jump_node_id() const {
    return GetField<int32_t>(VT_TRUE_JUMP_NODE_ID, 0);
  }
  int32_t false_jump_node_id() const {
    return GetField<int32_t>(VT_FALSE_JUMP_NODE_ID, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VAR_NAME_ID, 4) &&
           VerifyField<int8_t>(verifier, VT_OP, 1) &&
           VerifyField<uint8_t>(verifier, VT_COMPARE_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPARE_VALUE) &&
           VerifyValueData(verifier, compare_value(), compare_value_type()) &&
           VerifyField<int32_t>(verifier, VT_TRUE_JUMP_NODE_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_FALSE_JUMP_NODE_ID, 4) &&
           verifier.EndTable();
  }
  ConditionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConditionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Condition> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConditionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ICPDev::Gyeol::Schema::BoolValue *Condition::compare_value_as<ICPDev::Gyeol::Schema::BoolValue>() const {
  return compare_value_as_BoolValue();
}

template<> inline const ICPDev::Gyeol::Schema::IntValue *Condition::compare_value_as<ICPDev::Gyeol::Schema::IntValue>() const {
  return compare_value_as_IntValue();
}

template<> inline const ICPDev::Gyeol::Schema::FloatValue *Condition::compare_value_as<ICPDev::Gyeol::Schema::FloatValue>() const {
  return compare_value_as_FloatValue();
}

template<> inline const ICPDev::Gyeol::Schema::StringRef *Condition::compare_value_as<ICPDev::Gyeol::Schema::StringRef>() const {
  return compare_value_as_StringRef();
}

struct ConditionBuilder {
  typedef Condition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_var_name_id(int32_t var_name_id) {
    fbb_.AddElement<int32_t>(Condition::VT_VAR_NAME_ID, var_name_id, 0);
  }
  void add_op(ICPDev::Gyeol::Schema::Operator op) {
    fbb_.AddElement<int8_t>(Condition::VT_OP, static_cast<int8_t>(op), 0);
  }
  void add_compare_value_type(ICPDev::Gyeol::Schema::ValueData compare_value_type) {
    fbb_.AddElement<uint8_t>(Condition::VT_COMPARE_VALUE_TYPE, static_cast<uint8_t>(compare_value_type), 0);
  }
  void add_compare_value(::flatbuffers::Offset<void> compare_value) {
    fbb_.AddOffset(Condition::VT_COMPARE_VALUE, compare_value);
  }
  void add_true_jump_node_id(int32_t true_jump_node_id) {
    fbb_.AddElement<int32_t>(Condition::VT_TRUE_JUMP_NODE_ID, true_jump_node_id, 0);
  }
  void add_false_jump_node_id(int32_t false_jump_node_id) {
    fbb_.AddElement<int32_t>(Condition::VT_FALSE_JUMP_NODE_ID, false_jump_node_id, 0);
  }
  explicit ConditionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Condition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Condition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Condition> CreateCondition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t var_name_id = 0,
    ICPDev::Gyeol::Schema::Operator op = ICPDev::Gyeol::Schema::Operator::Equal,
    ICPDev::Gyeol::Schema::ValueData compare_value_type = ICPDev::Gyeol::Schema::ValueData::NONE,
    ::flatbuffers::Offset<void> compare_value = 0,
    int32_t true_jump_node_id = 0,
    int32_t false_jump_node_id = 0) {
  ConditionBuilder builder_(_fbb);
  builder_.add_false_jump_node_id(false_jump_node_id);
  builder_.add_true_jump_node_id(true_jump_node_id);
  builder_.add_compare_value(compare_value);
  builder_.add_var_name_id(var_name_id);
  builder_.add_compare_value_type(compare_value_type);
  builder_.add_op(op);
  return builder_.Finish();
}

struct Condition::Traits {
  using type = Condition;
  static auto constexpr Create = CreateCondition;
};

::flatbuffers::Offset<Condition> CreateCondition(::flatbuffers::FlatBufferBuilder &_fbb, const ConditionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InstructionT : public ::flatbuffers::NativeTable {
  typedef Instruction TableType;
  ICPDev::Gyeol::Schema::OpDataUnion data{};
};

struct Instruction FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InstructionT NativeTableType;
  typedef InstructionBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_DATA = 6
  };
  ICPDev::Gyeol::Schema::OpData data_type() const {
    return static_cast<ICPDev::Gyeol::Schema::OpData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const ICPDev::Gyeol::Schema::Line *data_as_Line() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Line ? static_cast<const ICPDev::Gyeol::Schema::Line *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::Choice *data_as_Choice() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Choice ? static_cast<const ICPDev::Gyeol::Schema::Choice *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::Jump *data_as_Jump() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Jump ? static_cast<const ICPDev::Gyeol::Schema::Jump *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::Command *data_as_Command() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Command ? static_cast<const ICPDev::Gyeol::Schema::Command *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::SetVar *data_as_SetVar() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::SetVar ? static_cast<const ICPDev::Gyeol::Schema::SetVar *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::Condition *data_as_Condition() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Condition ? static_cast<const ICPDev::Gyeol::Schema::Condition *>(data()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyOpData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
  InstructionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InstructionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Instruction> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InstructionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ICPDev::Gyeol::Schema::Line *Instruction::data_as<ICPDev::Gyeol::Schema::Line>() const {
  return data_as_Line();
}

template<> inline const ICPDev::Gyeol::Schema::Choice *Instruction::data_as<ICPDev::Gyeol::Schema::Choice>() const {
  return data_as_Choice();
}

template<> inline const ICPDev::Gyeol::Schema::Jump *Instruction::data_as<ICPDev::Gyeol::Schema::Jump>() const {
  return data_as_Jump();
}

template<> inline const ICPDev::Gyeol::Schema::Command *Instruction::data_as<ICPDev::Gyeol::Schema::Command>() const {
  return data_as_Command();
}

template<> inline const ICPDev::Gyeol::Schema::SetVar *Instruction::data_as<ICPDev::Gyeol::Schema::SetVar>() const {
  return data_as_SetVar();
}

template<> inline const ICPDev::Gyeol::Schema::Condition *Instruction::data_as<ICPDev::Gyeol::Schema::Condition>() const {
  return data_as_Condition();
}

struct InstructionBuilder {
  typedef Instruction Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data_type(ICPDev::Gyeol::Schema::OpData data_type) {
    fbb_.AddElement<uint8_t>(Instruction::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(::flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Instruction::VT_DATA, data);
  }
  explicit InstructionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Instruction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Instruction>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Instruction> CreateInstruction(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ICPDev::Gyeol::Schema::OpData data_type = ICPDev::Gyeol::Schema::OpData::NONE,
    ::flatbuffers::Offset<void> data = 0) {
  InstructionBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

struct Instruction::Traits {
  using type = Instruction;
  static auto constexpr Create = CreateInstruction;
};

::flatbuffers::Offset<Instruction> CreateInstruction(::flatbuffers::FlatBufferBuilder &_fbb, const InstructionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NodeT : public ::flatbuffers::NativeTable {
  typedef Node TableType;
  std::string name{};
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::InstructionT>> lines{};
  NodeT() = default;
  NodeT(const NodeT &o);
  NodeT(NodeT&&) FLATBUFFERS_NOEXCEPT = default;
  NodeT &operator=(NodeT o) FLATBUFFERS_NOEXCEPT;
};

struct Node FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NodeT NativeTableType;
  typedef NodeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_LINES = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const Node * const o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *_name) const {
    return strcmp(name()->c_str(), _name);
  }
  template<typename StringType>
  int KeyCompareWithValue(const StringType& _name) const {
    if (name()->c_str() < _name) return -1;
    if (_name < name()->c_str()) return 1;
    return 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>> *lines() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>> *>(VT_LINES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_LINES) &&
           verifier.VerifyVector(lines()) &&
           verifier.VerifyVectorOfTables(lines()) &&
           verifier.EndTable();
  }
  NodeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NodeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Node> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NodeBuilder {
  typedef Node Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Node::VT_NAME, name);
  }
  void add_lines(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>>> lines) {
    fbb_.AddOffset(Node::VT_LINES, lines);
  }
  explicit NodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Node>(end);
    fbb_.Required(o, Node::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<Node> CreateNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>>> lines = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_lines(lines);
  builder_.add_name(name);
  return builder_.Finish();
}

struct Node::Traits {
  using type = Node;
  static auto constexpr Create = CreateNode;
};

inline ::flatbuffers::Offset<Node> CreateNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>> *lines = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto lines__ = lines ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>>(*lines) : 0;
  return ICPDev::Gyeol::Schema::CreateNode(
      _fbb,
      name__,
      lines__);
}

::flatbuffers::Offset<Node> CreateNode(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StoryT : public ::flatbuffers::NativeTable {
  typedef Story TableType;
  std::string version{};
  std::vector<std::string> string_pool{};
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::SetVarT>> global_vars{};
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::NodeT>> nodes{};
  std::string start_node_name{};
  StoryT() = default;
  StoryT(const StoryT &o);
  StoryT(StoryT&&) FLATBUFFERS_NOEXCEPT = default;
  StoryT &operator=(StoryT o) FLATBUFFERS_NOEXCEPT;
};

struct Story FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StoryT NativeTableType;
  typedef StoryBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_STRING_POOL = 6,
    VT_GLOBAL_VARS = 8,
    VT_NODES = 10,
    VT_START_NODE_NAME = 12
  };
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *string_pool() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRING_POOL);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>> *global_vars() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>> *>(VT_GLOBAL_VARS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>> *nodes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>> *>(VT_NODES);
  }
  const ::flatbuffers::String *start_node_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_START_NODE_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_STRING_POOL) &&
           verifier.VerifyVector(string_pool()) &&
           verifier.VerifyVectorOfStrings(string_pool()) &&
           VerifyOffset(verifier, VT_GLOBAL_VARS) &&
           verifier.VerifyVector(global_vars()) &&
           verifier.VerifyVectorOfTables(global_vars()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_START_NODE_NAME) &&
           verifier.VerifyString(start_node_name()) &&
           verifier.EndTable();
  }
  StoryT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StoryT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Story> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StoryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StoryBuilder {
  typedef Story Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(Story::VT_VERSION, version);
  }
  void add_string_pool(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> string_pool) {
    fbb_.AddOffset(Story::VT_STRING_POOL, string_pool);
  }
  void add_global_vars(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>>> global_vars) {
    fbb_.AddOffset(Story::VT_GLOBAL_VARS, global_vars);
  }
  void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>>> nodes) {
    fbb_.AddOffset(Story::VT_NODES, nodes);
  }
  void add_start_node_name(::flatbuffers::Offset<::flatbuffers::String> start_node_name) {
    fbb_.AddOffset(Story::VT_START_NODE_NAME, start_node_name);
  }
  explicit StoryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Story> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Story>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Story> CreateStory(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> string_pool = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>>> global_vars = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>>> nodes = 0,
    ::flatbuffers::Offset<::flatbuffers::String> start_node_name = 0) {
  StoryBuilder builder_(_fbb);
  builder_.add_start_node_name(start_node_name);
  builder_.add_nodes(nodes);
  builder_.add_global_vars(global_vars);
  builder_.add_string_pool(string_pool);
  builder_.add_version(version);
  return builder_.Finish();
}

struct Story::Traits {
  using type = Story;
  static auto constexpr Create = CreateStory;
};

inline ::flatbuffers::Offset<Story> CreateStoryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *string_pool = nullptr,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>> *global_vars = nullptr,
    std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>> *nodes = nullptr,
    const char *start_node_name = nullptr) {
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto string_pool__ = string_pool ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*string_pool) : 0;
  auto global_vars__ = global_vars ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>>(*global_vars) : 0;
  auto nodes__ = nodes ? _fbb.CreateVectorOfSortedTables<ICPDev::Gyeol::Schema::Node>(nodes) : 0;
  auto start_node_name__ = start_node_name ? _fbb.CreateString(start_node_name) : 0;
  return ICPDev::Gyeol::Schema::CreateStory(
      _fbb,
      version__,
      string_pool__,
      global_vars__,
      nodes__,
      start_node_name__);
}

::flatbuffers::Offset<Story> CreateStory(::flatbuffers::FlatBufferBuilder &_fbb, const StoryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline BoolValueT *BoolValue::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<BoolValueT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BoolValue::UnPackTo(BoolValueT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = val(); _o->val = _e; }
}

inline ::flatbuffers::Offset<BoolValue> BoolValue::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BoolValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBoolValue(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BoolValue> CreateBoolValue(::flatbuffers::FlatBufferBuilder &_fbb, const BoolValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BoolValueT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _val = _o->val;
  return ICPDev::Gyeol::Schema::CreateBoolValue(
      _fbb,
      _val);
}

inline IntValueT *IntValue::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<IntValueT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IntValue::UnPackTo(IntValueT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = val(); _o->val = _e; }
}

inline ::flatbuffers::Offset<IntValue> IntValue::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IntValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIntValue(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<IntValue> CreateIntValue(::flatbuffers::FlatBufferBuilder &_fbb, const IntValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const IntValueT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _val = _o->val;
  return ICPDev::Gyeol::Schema::CreateIntValue(
      _fbb,
      _val);
}

inline FloatValueT *FloatValue::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FloatValueT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FloatValue::UnPackTo(FloatValueT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = val(); _o->val = _e; }
}

inline ::flatbuffers::Offset<FloatValue> FloatValue::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FloatValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloatValue(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FloatValue> CreateFloatValue(::flatbuffers::FlatBufferBuilder &_fbb, const FloatValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FloatValueT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _val = _o->val;
  return ICPDev::Gyeol::Schema::CreateFloatValue(
      _fbb,
      _val);
}

inline StringRefT *StringRef::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<StringRefT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StringRef::UnPackTo(StringRefT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = index(); _o->index = _e; }
}

inline ::flatbuffers::Offset<StringRef> StringRef::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StringRefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStringRef(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StringRef> CreateStringRef(::flatbuffers::FlatBufferBuilder &_fbb, const StringRefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StringRefT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _index = _o->index;
  return ICPDev::Gyeol::Schema::CreateStringRef(
      _fbb,
      _index);
}

inline LineT *Line::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LineT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Line::UnPackTo(LineT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character_id(); _o->character_id = _e; }
  { auto _e = text_id(); _o->text_id = _e; }
  { auto _e = voice_asset_id(); _o->voice_asset_id = _e; }
}

inline ::flatbuffers::Offset<Line> Line::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LineT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLine(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Line> CreateLine(::flatbuffers::FlatBufferBuilder &_fbb, const LineT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LineT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _character_id = _o->character_id;
  auto _text_id = _o->text_id;
  auto _voice_asset_id = _o->voice_asset_id;
  return ICPDev::Gyeol::Schema::CreateLine(
      _fbb,
      _character_id,
      _text_id,
      _voice_asset_id);
}

inline ChoiceT *Choice::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ChoiceT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Choice::UnPackTo(ChoiceT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = text_id(); _o->text_id = _e; }
  { auto _e = target_node_name_id(); _o->target_node_name_id = _e; }
  { auto _e = condition_var_id(); _o->condition_var_id = _e; }
}

inline ::flatbuffers::Offset<Choice> Choice::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ChoiceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateChoice(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Choice> CreateChoice(::flatbuffers::FlatBufferBuilder &_fbb, const ChoiceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ChoiceT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _text_id = _o->text_id;
  auto _target_node_name_id = _o->target_node_name_id;
  auto _condition_var_id = _o->condition_var_id;
  return ICPDev::Gyeol::Schema::CreateChoice(
      _fbb,
      _text_id,
      _target_node_name_id,
      _condition_var_id);
}

inline JumpT *Jump::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<JumpT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Jump::UnPackTo(JumpT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target_node_name_id(); _o->target_node_name_id = _e; }
  { auto _e = is_call(); _o->is_call = _e; }
}

inline ::flatbuffers::Offset<Jump> Jump::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JumpT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJump(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Jump> CreateJump(::flatbuffers::FlatBufferBuilder &_fbb, const JumpT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const JumpT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target_node_name_id = _o->target_node_name_id;
  auto _is_call = _o->is_call;
  return ICPDev::Gyeol::Schema::CreateJump(
      _fbb,
      _target_node_name_id,
      _is_call);
}

inline CommandT *Command::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CommandT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Command::UnPackTo(CommandT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type_id(); _o->type_id = _e; }
  { auto _e = params(); if (_e) { _o->params.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->params[_i] = _e->Get(_i); } } else { _o->params.resize(0); } }
}

inline ::flatbuffers::Offset<Command> Command::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCommand(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Command> CreateCommand(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CommandT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type_id = _o->type_id;
  auto _params = _o->params.size() ? _fbb.CreateVector(_o->params) : 0;
  return ICPDev::Gyeol::Schema::CreateCommand(
      _fbb,
      _type_id,
      _params);
}

inline SetVarT *SetVar::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SetVarT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetVar::UnPackTo(SetVarT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = var_name_id(); _o->var_name_id = _e; }
  { auto _e = value_type(); _o->value.type = _e; }
  { auto _e = value(); if (_e) _o->value.value = ICPDev::Gyeol::Schema::ValueDataUnion::UnPack(_e, value_type(), _resolver); }
}

inline ::flatbuffers::Offset<SetVar> SetVar::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetVarT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetVar(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetVar> CreateSetVar(::flatbuffers::FlatBufferBuilder &_fbb, const SetVarT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetVarT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _var_name_id = _o->var_name_id;
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  return ICPDev::Gyeol::Schema::CreateSetVar(
      _fbb,
      _var_name_id,
      _value_type,
      _value);
}

inline ConditionT *Condition::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ConditionT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Condition::UnPackTo(ConditionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = var_name_id(); _o->var_name_id = _e; }
  { auto _e = op(); _o->op = _e; }
  { auto _e = compare_value_type(); _o->compare_value.type = _e; }
  { auto _e = compare_value(); if (_e) _o->compare_value.value = ICPDev::Gyeol::Schema::ValueDataUnion::UnPack(_e, compare_value_type(), _resolver); }
  { auto _e = true_jump_node_id(); _o->true_jump_node_id = _e; }
  { auto _e = false_jump_node_id(); _o->false_jump_node_id = _e; }
}

inline ::flatbuffers::Offset<Condition> Condition::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConditionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCondition(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Condition> CreateCondition(::flatbuffers::FlatBufferBuilder &_fbb, const ConditionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ConditionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _var_name_id = _o->var_name_id;
  auto _op = _o->op;
  auto _compare_value_type = _o->compare_value.type;
  auto _compare_value = _o->compare_value.Pack(_fbb);
  auto _true_jump_node_id = _o->true_jump_node_id;
  auto _false_jump_node_id = _o->false_jump_node_id;
  return ICPDev::Gyeol::Schema::CreateCondition(
      _fbb,
      _var_name_id,
      _op,
      _compare_value_type,
      _compare_value,
      _true_jump_node_id,
      _false_jump_node_id);
}

inline InstructionT *Instruction::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<InstructionT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Instruction::UnPackTo(InstructionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data_type(); _o->data.type = _e; }
  { auto _e = data(); if (_e) _o->data.value = ICPDev::Gyeol::Schema::OpDataUnion::UnPack(_e, data_type(), _resolver); }
}

inline ::flatbuffers::Offset<Instruction> Instruction::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InstructionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInstruction(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Instruction> CreateInstruction(::flatbuffers::FlatBufferBuilder &_fbb, const InstructionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const InstructionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data_type = _o->data.type;
  auto _data = _o->data.Pack(_fbb);
  return ICPDev::Gyeol::Schema::CreateInstruction(
      _fbb,
      _data_type,
      _data);
}

inline NodeT::NodeT(const NodeT &o)
      : name(o.name) {
  lines.reserve(o.lines.size());
  for (const auto &lines_ : o.lines) { lines.emplace_back((lines_) ? new ICPDev::Gyeol::Schema::InstructionT(*lines_) : nullptr); }
}

inline NodeT &NodeT::operator=(NodeT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(lines, o.lines);
  return *this;
}

inline NodeT *Node::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<NodeT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Node::UnPackTo(NodeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = lines(); if (_e) { _o->lines.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->lines[_i]) { _e->Get(_i)->UnPackTo(_o->lines[_i].get(), _resolver); } else { _o->lines[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::InstructionT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->lines.resize(0); } }
}

inline ::flatbuffers::Offset<Node> Node::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNode(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Node> CreateNode(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NodeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _fbb.CreateString(_o->name);
  auto _lines = _o->lines.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>> (_o->lines.size(), [](size_t i, _VectorArgs *__va) { return CreateInstruction(*__va->__fbb, __va->__o->lines[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ICPDev::Gyeol::Schema::CreateNode(
      _fbb,
      _name,
      _lines);
}

inline StoryT::StoryT(const StoryT &o)
      : version(o.version),
        string_pool(o.string_pool),
        start_node_name(o.start_node_name) {
  global_vars.reserve(o.global_vars.size());
  for (const auto &global_vars_ : o.global_vars) { global_vars.emplace_back((global_vars_) ? new ICPDev::Gyeol::Schema::SetVarT(*global_vars_) : nullptr); }
  nodes.reserve(o.nodes.size());
  for (const auto &nodes_ : o.nodes) { nodes.emplace_back((nodes_) ? new ICPDev::Gyeol::Schema::NodeT(*nodes_) : nullptr); }
}

inline StoryT &StoryT::operator=(StoryT o) FLATBUFFERS_NOEXCEPT {
  std::swap(version, o.version);
  std::swap(string_pool, o.string_pool);
  std::swap(global_vars, o.global_vars);
  std::swap(nodes, o.nodes);
  std::swap(start_node_name, o.start_node_name);
  return *this;
}

inline StoryT *Story::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<StoryT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Story::UnPackTo(StoryT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); if (_e) _o->version = _e->str(); }
  { auto _e = string_pool(); if (_e) { _o->string_pool.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->string_pool[_i] = _e->Get(_i)->str(); } } else { _o->string_pool.resize(0); } }
  { auto _e = global_vars(); if (_e) { _o->global_vars.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->global_vars[_i]) { _e->Get(_i)->UnPackTo(_o->global_vars[_i].get(), _resolver); } else { _o->global_vars[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::SetVarT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->global_vars.resize(0); } }
  { auto _e = nodes(); if (_e) { _o->nodes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->nodes[_i]) { _e->Get(_i)->UnPackTo(_o->nodes[_i].get(), _resolver); } else { _o->nodes[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::NodeT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->nodes.resize(0); } }
  { auto _e = start_node_name(); if (_e) _o->start_node_name = _e->str(); }
}

inline ::flatbuffers::Offset<Story> Story::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StoryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStory(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Story> CreateStory(::flatbuffers::FlatBufferBuilder &_fbb, const StoryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StoryT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _string_pool = _o->string_pool.size() ? _fbb.CreateVectorOfStrings(_o->string_pool) : 0;
  auto _global_vars = _o->global_vars.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>> (_o->global_vars.size(), [](size_t i, _VectorArgs *__va) { return CreateSetVar(*__va->__fbb, __va->__o->global_vars[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _nodes = _o->nodes.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>> (_o->nodes.size(), [](size_t i, _VectorArgs *__va) { return CreateNode(*__va->__fbb, __va->__o->nodes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _start_node_name = _o->start_node_name.empty() ? 0 : _fbb.CreateString(_o->start_node_name);
  return ICPDev::Gyeol::Schema::CreateStory(
      _fbb,
      _version,
      _string_pool,
      _global_vars,
      _nodes,
      _start_node_name);
}

inline bool VerifyValueData(::flatbuffers::Verifier &verifier, const void *obj, ValueData type) {
  switch (type) {
    case ValueData::NONE: {
      return true;
    }
    case ValueData::BoolValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::BoolValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueData::IntValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::IntValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueData::FloatValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::FloatValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueData::StringRef: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::StringRef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValueDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ValueData> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValueData(
        verifier,  values->Get(i), types->GetEnum<ValueData>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ValueDataUnion::UnPack(const void *obj, ValueData type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case ValueData::BoolValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::BoolValue *>(obj);
      return ptr->UnPack(resolver);
    }
    case ValueData::IntValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::IntValue *>(obj);
      return ptr->UnPack(resolver);
    }
    case ValueData::FloatValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::FloatValue *>(obj);
      return ptr->UnPack(resolver);
    }
    case ValueData::StringRef: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::StringRef *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> ValueDataUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case ValueData::BoolValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::BoolValueT *>(value);
      return CreateBoolValue(_fbb, ptr, _rehasher).Union();
    }
    case ValueData::IntValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::IntValueT *>(value);
      return CreateIntValue(_fbb, ptr, _rehasher).Union();
    }
    case ValueData::FloatValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::FloatValueT *>(value);
      return CreateFloatValue(_fbb, ptr, _rehasher).Union();
    }
    case ValueData::StringRef: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::StringRefT *>(value);
      return CreateStringRef(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ValueDataUnion::ValueDataUnion(const ValueDataUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ValueData::BoolValue: {
      value = new ICPDev::Gyeol::Schema::BoolValueT(*reinterpret_cast<ICPDev::Gyeol::Schema::BoolValueT *>(u.value));
      break;
    }
    case ValueData::IntValue: {
      value = new ICPDev::Gyeol::Schema::IntValueT(*reinterpret_cast<ICPDev::Gyeol::Schema::IntValueT *>(u.value));
      break;
    }
    case ValueData::FloatValue: {
      value = new ICPDev::Gyeol::Schema::FloatValueT(*reinterpret_cast<ICPDev::Gyeol::Schema::FloatValueT *>(u.value));
      break;
    }
    case ValueData::StringRef: {
      value = new ICPDev::Gyeol::Schema::StringRefT(*reinterpret_cast<ICPDev::Gyeol::Schema::StringRefT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ValueDataUnion::Reset() {
  switch (type) {
    case ValueData::BoolValue: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::BoolValueT *>(value);
      delete ptr;
      break;
    }
    case ValueData::IntValue: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::IntValueT *>(value);
      delete ptr;
      break;
    }
    case ValueData::FloatValue: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::FloatValueT *>(value);
      delete ptr;
      break;
    }
    case ValueData::StringRef: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::StringRefT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ValueData::NONE;
}

inline bool VerifyOpData(::flatbuffers::Verifier &verifier, const void *obj, OpData type) {
  switch (type) {
    case OpData::NONE: {
      return true;
    }
    case OpData::Line: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Line *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::Choice: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Choice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::Jump: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Jump *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::Command: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Command *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::SetVar: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::SetVar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::Condition: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Condition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOpDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<OpData> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOpData(
        verifier,  values->Get(i), types->GetEnum<OpData>(i))) {
      return false;
    }
  }
  return true;
}

inline void *OpDataUnion::UnPack(const void *obj, OpData type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case OpData::Line: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Line *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::Choice: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Choice *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::Jump: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Jump *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::Command: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Command *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::SetVar: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::SetVar *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::Condition: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Condition *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> OpDataUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case OpData::Line: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::LineT *>(value);
      return CreateLine(_fbb, ptr, _rehasher).Union();
    }
    case OpData::Choice: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::ChoiceT *>(value);
      return CreateChoice(_fbb, ptr, _rehasher).Union();
    }
    case OpData::Jump: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::JumpT *>(value);
      return CreateJump(_fbb, ptr, _rehasher).Union();
    }
    case OpData::Command: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::CommandT *>(value);
      return CreateCommand(_fbb, ptr, _rehasher).Union();
    }
    case OpData::SetVar: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::SetVarT *>(value);
      return CreateSetVar(_fbb, ptr, _rehasher).Union();
    }
    case OpData::Condition: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::ConditionT *>(value);
      return CreateCondition(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline OpDataUnion::OpDataUnion(const OpDataUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case OpData::Line: {
      value = new ICPDev::Gyeol::Schema::LineT(*reinterpret_cast<ICPDev::Gyeol::Schema::LineT *>(u.value));
      break;
    }
    case OpData::Choice: {
      value = new ICPDev::Gyeol::Schema::ChoiceT(*reinterpret_cast<ICPDev::Gyeol::Schema::ChoiceT *>(u.value));
      break;
    }
    case OpData::Jump: {
      value = new ICPDev::Gyeol::Schema::JumpT(*reinterpret_cast<ICPDev::Gyeol::Schema::JumpT *>(u.value));
      break;
    }
    case OpData::Command: {
      value = new ICPDev::Gyeol::Schema::CommandT(*reinterpret_cast<ICPDev::Gyeol::Schema::CommandT *>(u.value));
      break;
    }
    case OpData::SetVar: {
      value = new ICPDev::Gyeol::Schema::SetVarT(*reinterpret_cast<ICPDev::Gyeol::Schema::SetVarT *>(u.value));
      break;
    }
    case OpData::Condition: {
      value = new ICPDev::Gyeol::Schema::ConditionT(*reinterpret_cast<ICPDev::Gyeol::Schema::ConditionT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void OpDataUnion::Reset() {
  switch (type) {
    case OpData::Line: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::LineT *>(value);
      delete ptr;
      break;
    }
    case OpData::Choice: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::ChoiceT *>(value);
      delete ptr;
      break;
    }
    case OpData::Jump: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::JumpT *>(value);
      delete ptr;
      break;
    }
    case OpData::Command: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::CommandT *>(value);
      delete ptr;
      break;
    }
    case OpData::SetVar: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::SetVarT *>(value);
      delete ptr;
      break;
    }
    case OpData::Condition: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::ConditionT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = OpData::NONE;
}

inline const ICPDev::Gyeol::Schema::Story *GetStory(const void *buf) {
  return ::flatbuffers::GetRoot<ICPDev::Gyeol::Schema::Story>(buf);
}

inline const ICPDev::Gyeol::Schema::Story *GetSizePrefixedStory(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ICPDev::Gyeol::Schema::Story>(buf);
}

inline bool VerifyStoryBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ICPDev::Gyeol::Schema::Story>(nullptr);
}

inline bool VerifySizePrefixedStoryBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ICPDev::Gyeol::Schema::Story>(nullptr);
}

inline void FinishStoryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ICPDev::Gyeol::Schema::Story> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedStoryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ICPDev::Gyeol::Schema::Story> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<ICPDev::Gyeol::Schema::StoryT> UnPackStory(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ICPDev::Gyeol::Schema::StoryT>(GetStory(buf)->UnPack(res));
}

inline std::unique_ptr<ICPDev::Gyeol::Schema::StoryT> UnPackSizePrefixedStory(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ICPDev::Gyeol::Schema::StoryT>(GetSizePrefixedStory(buf)->UnPack(res));
}

}  // namespace Schema
}  // namespace Gyeol
}  // namespace ICPDev

#endif  // FLATBUFFERS_GENERATED_GYEOL_ICPDEV_GYEOL_SCHEMA_H_
