// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GYEOL_ICPDEV_GYEOL_SCHEMA_H_
#define FLATBUFFERS_GENERATED_GYEOL_ICPDEV_GYEOL_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace ICPDev {
namespace Gyeol {
namespace Schema {

struct BoolValue;
struct BoolValueBuilder;
struct BoolValueT;

struct IntValue;
struct IntValueBuilder;
struct IntValueT;

struct FloatValue;
struct FloatValueBuilder;
struct FloatValueT;

struct StringRef;
struct StringRefBuilder;
struct StringRefT;

struct Line;
struct LineBuilder;
struct LineT;

struct Choice;
struct ChoiceBuilder;
struct ChoiceT;

struct Jump;
struct JumpBuilder;
struct JumpT;

struct Command;
struct CommandBuilder;
struct CommandT;

struct ExprToken;
struct ExprTokenBuilder;
struct ExprTokenT;

struct Expression;
struct ExpressionBuilder;
struct ExpressionT;

struct SetVar;
struct SetVarBuilder;
struct SetVarT;

struct Condition;
struct ConditionBuilder;
struct ConditionT;

struct RandomBranch;
struct RandomBranchBuilder;
struct RandomBranchT;

struct Random;
struct RandomBuilder;
struct RandomT;

struct Instruction;
struct InstructionBuilder;
struct InstructionT;

struct Node;
struct NodeBuilder;
struct NodeT;

struct SavedVar;
struct SavedVarBuilder;
struct SavedVarT;

struct SavedCallFrame;
struct SavedCallFrameBuilder;
struct SavedCallFrameT;

struct SavedPendingChoice;
struct SavedPendingChoiceBuilder;
struct SavedPendingChoiceT;

struct SaveState;
struct SaveStateBuilder;
struct SaveStateT;

struct Story;
struct StoryBuilder;
struct StoryT;

enum class Operator : int8_t {
  Equal = 0,
  NotEqual = 1,
  Greater = 2,
  Less = 3,
  GreaterOrEqual = 4,
  LessOrEqual = 5,
  MIN = Equal,
  MAX = LessOrEqual
};

inline const Operator (&EnumValuesOperator())[6] {
  static const Operator values[] = {
    Operator::Equal,
    Operator::NotEqual,
    Operator::Greater,
    Operator::Less,
    Operator::GreaterOrEqual,
    Operator::LessOrEqual
  };
  return values;
}

inline const char * const *EnumNamesOperator() {
  static const char * const names[7] = {
    "Equal",
    "NotEqual",
    "Greater",
    "Less",
    "GreaterOrEqual",
    "LessOrEqual",
    nullptr
  };
  return names;
}

inline const char *EnumNameOperator(Operator e) {
  if (::flatbuffers::IsOutRange(e, Operator::Equal, Operator::LessOrEqual)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOperator()[index];
}

enum class ValueData : uint8_t {
  NONE = 0,
  BoolValue = 1,
  IntValue = 2,
  FloatValue = 3,
  StringRef = 4,
  MIN = NONE,
  MAX = StringRef
};

inline const ValueData (&EnumValuesValueData())[5] {
  static const ValueData values[] = {
    ValueData::NONE,
    ValueData::BoolValue,
    ValueData::IntValue,
    ValueData::FloatValue,
    ValueData::StringRef
  };
  return values;
}

inline const char * const *EnumNamesValueData() {
  static const char * const names[6] = {
    "NONE",
    "BoolValue",
    "IntValue",
    "FloatValue",
    "StringRef",
    nullptr
  };
  return names;
}

inline const char *EnumNameValueData(ValueData e) {
  if (::flatbuffers::IsOutRange(e, ValueData::NONE, ValueData::StringRef)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesValueData()[index];
}

template<typename T> struct ValueDataTraits {
  static const ValueData enum_value = ValueData::NONE;
};

template<> struct ValueDataTraits<ICPDev::Gyeol::Schema::BoolValue> {
  static const ValueData enum_value = ValueData::BoolValue;
};

template<> struct ValueDataTraits<ICPDev::Gyeol::Schema::IntValue> {
  static const ValueData enum_value = ValueData::IntValue;
};

template<> struct ValueDataTraits<ICPDev::Gyeol::Schema::FloatValue> {
  static const ValueData enum_value = ValueData::FloatValue;
};

template<> struct ValueDataTraits<ICPDev::Gyeol::Schema::StringRef> {
  static const ValueData enum_value = ValueData::StringRef;
};

template<typename T> struct ValueDataUnionTraits {
  static const ValueData enum_value = ValueData::NONE;
};

template<> struct ValueDataUnionTraits<ICPDev::Gyeol::Schema::BoolValueT> {
  static const ValueData enum_value = ValueData::BoolValue;
};

template<> struct ValueDataUnionTraits<ICPDev::Gyeol::Schema::IntValueT> {
  static const ValueData enum_value = ValueData::IntValue;
};

template<> struct ValueDataUnionTraits<ICPDev::Gyeol::Schema::FloatValueT> {
  static const ValueData enum_value = ValueData::FloatValue;
};

template<> struct ValueDataUnionTraits<ICPDev::Gyeol::Schema::StringRefT> {
  static const ValueData enum_value = ValueData::StringRef;
};

struct ValueDataUnion {
  ValueData type;
  void *value;

  ValueDataUnion() : type(ValueData::NONE), value(nullptr) {}
  ValueDataUnion(ValueDataUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(ValueData::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  ValueDataUnion(const ValueDataUnion &);
  ValueDataUnion &operator=(const ValueDataUnion &u)
    { ValueDataUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  ValueDataUnion &operator=(ValueDataUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~ValueDataUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = ValueDataUnionTraits<RT>::enum_value;
    if (type != ValueData::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, ValueData type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  ICPDev::Gyeol::Schema::BoolValueT *AsBoolValue() {
    return type == ValueData::BoolValue ?
      reinterpret_cast<ICPDev::Gyeol::Schema::BoolValueT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::BoolValueT *AsBoolValue() const {
    return type == ValueData::BoolValue ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::BoolValueT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::IntValueT *AsIntValue() {
    return type == ValueData::IntValue ?
      reinterpret_cast<ICPDev::Gyeol::Schema::IntValueT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::IntValueT *AsIntValue() const {
    return type == ValueData::IntValue ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::IntValueT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::FloatValueT *AsFloatValue() {
    return type == ValueData::FloatValue ?
      reinterpret_cast<ICPDev::Gyeol::Schema::FloatValueT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::FloatValueT *AsFloatValue() const {
    return type == ValueData::FloatValue ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::FloatValueT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::StringRefT *AsStringRef() {
    return type == ValueData::StringRef ?
      reinterpret_cast<ICPDev::Gyeol::Schema::StringRefT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::StringRefT *AsStringRef() const {
    return type == ValueData::StringRef ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::StringRefT *>(value) : nullptr;
  }
};

bool VerifyValueData(::flatbuffers::Verifier &verifier, const void *obj, ValueData type);
bool VerifyValueDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ValueData> *types);

enum class OpData : uint8_t {
  NONE = 0,
  Line = 1,
  Choice = 2,
  Jump = 3,
  Command = 4,
  SetVar = 5,
  Condition = 6,
  Random = 7,
  MIN = NONE,
  MAX = Random
};

inline const OpData (&EnumValuesOpData())[8] {
  static const OpData values[] = {
    OpData::NONE,
    OpData::Line,
    OpData::Choice,
    OpData::Jump,
    OpData::Command,
    OpData::SetVar,
    OpData::Condition,
    OpData::Random
  };
  return values;
}

inline const char * const *EnumNamesOpData() {
  static const char * const names[9] = {
    "NONE",
    "Line",
    "Choice",
    "Jump",
    "Command",
    "SetVar",
    "Condition",
    "Random",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpData(OpData e) {
  if (::flatbuffers::IsOutRange(e, OpData::NONE, OpData::Random)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpData()[index];
}

template<typename T> struct OpDataTraits {
  static const OpData enum_value = OpData::NONE;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Line> {
  static const OpData enum_value = OpData::Line;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Choice> {
  static const OpData enum_value = OpData::Choice;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Jump> {
  static const OpData enum_value = OpData::Jump;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Command> {
  static const OpData enum_value = OpData::Command;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::SetVar> {
  static const OpData enum_value = OpData::SetVar;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Condition> {
  static const OpData enum_value = OpData::Condition;
};

template<> struct OpDataTraits<ICPDev::Gyeol::Schema::Random> {
  static const OpData enum_value = OpData::Random;
};

template<typename T> struct OpDataUnionTraits {
  static const OpData enum_value = OpData::NONE;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::LineT> {
  static const OpData enum_value = OpData::Line;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::ChoiceT> {
  static const OpData enum_value = OpData::Choice;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::JumpT> {
  static const OpData enum_value = OpData::Jump;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::CommandT> {
  static const OpData enum_value = OpData::Command;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::SetVarT> {
  static const OpData enum_value = OpData::SetVar;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::ConditionT> {
  static const OpData enum_value = OpData::Condition;
};

template<> struct OpDataUnionTraits<ICPDev::Gyeol::Schema::RandomT> {
  static const OpData enum_value = OpData::Random;
};

struct OpDataUnion {
  OpData type;
  void *value;

  OpDataUnion() : type(OpData::NONE), value(nullptr) {}
  OpDataUnion(OpDataUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(OpData::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  OpDataUnion(const OpDataUnion &);
  OpDataUnion &operator=(const OpDataUnion &u)
    { OpDataUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  OpDataUnion &operator=(OpDataUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~OpDataUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = OpDataUnionTraits<RT>::enum_value;
    if (type != OpData::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, OpData type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  ICPDev::Gyeol::Schema::LineT *AsLine() {
    return type == OpData::Line ?
      reinterpret_cast<ICPDev::Gyeol::Schema::LineT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::LineT *AsLine() const {
    return type == OpData::Line ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::LineT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::ChoiceT *AsChoice() {
    return type == OpData::Choice ?
      reinterpret_cast<ICPDev::Gyeol::Schema::ChoiceT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::ChoiceT *AsChoice() const {
    return type == OpData::Choice ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::ChoiceT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::JumpT *AsJump() {
    return type == OpData::Jump ?
      reinterpret_cast<ICPDev::Gyeol::Schema::JumpT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::JumpT *AsJump() const {
    return type == OpData::Jump ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::JumpT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::CommandT *AsCommand() {
    return type == OpData::Command ?
      reinterpret_cast<ICPDev::Gyeol::Schema::CommandT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::CommandT *AsCommand() const {
    return type == OpData::Command ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::CommandT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::SetVarT *AsSetVar() {
    return type == OpData::SetVar ?
      reinterpret_cast<ICPDev::Gyeol::Schema::SetVarT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::SetVarT *AsSetVar() const {
    return type == OpData::SetVar ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::SetVarT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::ConditionT *AsCondition() {
    return type == OpData::Condition ?
      reinterpret_cast<ICPDev::Gyeol::Schema::ConditionT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::ConditionT *AsCondition() const {
    return type == OpData::Condition ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::ConditionT *>(value) : nullptr;
  }
  ICPDev::Gyeol::Schema::RandomT *AsRandom() {
    return type == OpData::Random ?
      reinterpret_cast<ICPDev::Gyeol::Schema::RandomT *>(value) : nullptr;
  }
  const ICPDev::Gyeol::Schema::RandomT *AsRandom() const {
    return type == OpData::Random ?
      reinterpret_cast<const ICPDev::Gyeol::Schema::RandomT *>(value) : nullptr;
  }
};

bool VerifyOpData(::flatbuffers::Verifier &verifier, const void *obj, OpData type);
bool VerifyOpDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<OpData> *types);

enum class ExprOp : int8_t {
  PushLiteral = 0,
  PushVar = 1,
  Add = 2,
  Sub = 3,
  Mul = 4,
  Div = 5,
  Mod = 6,
  Negate = 7,
  CmpEq = 8,
  CmpNe = 9,
  CmpGt = 10,
  CmpLt = 11,
  CmpGe = 12,
  CmpLe = 13,
  And = 14,
  Or = 15,
  Not = 16,
  MIN = PushLiteral,
  MAX = Not
};

inline const ExprOp (&EnumValuesExprOp())[17] {
  static const ExprOp values[] = {
    ExprOp::PushLiteral,
    ExprOp::PushVar,
    ExprOp::Add,
    ExprOp::Sub,
    ExprOp::Mul,
    ExprOp::Div,
    ExprOp::Mod,
    ExprOp::Negate,
    ExprOp::CmpEq,
    ExprOp::CmpNe,
    ExprOp::CmpGt,
    ExprOp::CmpLt,
    ExprOp::CmpGe,
    ExprOp::CmpLe,
    ExprOp::And,
    ExprOp::Or,
    ExprOp::Not
  };
  return values;
}

inline const char * const *EnumNamesExprOp() {
  static const char * const names[18] = {
    "PushLiteral",
    "PushVar",
    "Add",
    "Sub",
    "Mul",
    "Div",
    "Mod",
    "Negate",
    "CmpEq",
    "CmpNe",
    "CmpGt",
    "CmpLt",
    "CmpGe",
    "CmpLe",
    "And",
    "Or",
    "Not",
    nullptr
  };
  return names;
}

inline const char *EnumNameExprOp(ExprOp e) {
  if (::flatbuffers::IsOutRange(e, ExprOp::PushLiteral, ExprOp::Not)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesExprOp()[index];
}

struct BoolValueT : public ::flatbuffers::NativeTable {
  typedef BoolValue TableType;
  bool val = false;
};

struct BoolValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BoolValueT NativeTableType;
  typedef BoolValueBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  bool val() const {
    return GetField<uint8_t>(VT_VAL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VAL, 1) &&
           verifier.EndTable();
  }
  BoolValueT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BoolValueT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<BoolValue> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BoolValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BoolValueBuilder {
  typedef BoolValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(bool val) {
    fbb_.AddElement<uint8_t>(BoolValue::VT_VAL, static_cast<uint8_t>(val), 0);
  }
  explicit BoolValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BoolValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BoolValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BoolValue> CreateBoolValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool val = false) {
  BoolValueBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct BoolValue::Traits {
  using type = BoolValue;
  static auto constexpr Create = CreateBoolValue;
};

::flatbuffers::Offset<BoolValue> CreateBoolValue(::flatbuffers::FlatBufferBuilder &_fbb, const BoolValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IntValueT : public ::flatbuffers::NativeTable {
  typedef IntValue TableType;
  int32_t val = 0;
};

struct IntValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IntValueT NativeTableType;
  typedef IntValueBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  int32_t val() const {
    return GetField<int32_t>(VT_VAL, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VAL, 4) &&
           verifier.EndTable();
  }
  IntValueT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IntValueT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<IntValue> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IntValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IntValueBuilder {
  typedef IntValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(int32_t val) {
    fbb_.AddElement<int32_t>(IntValue::VT_VAL, val, 0);
  }
  explicit IntValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IntValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IntValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IntValue> CreateIntValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t val = 0) {
  IntValueBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct IntValue::Traits {
  using type = IntValue;
  static auto constexpr Create = CreateIntValue;
};

::flatbuffers::Offset<IntValue> CreateIntValue(::flatbuffers::FlatBufferBuilder &_fbb, const IntValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FloatValueT : public ::flatbuffers::NativeTable {
  typedef FloatValue TableType;
  float val = 0.0f;
};

struct FloatValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FloatValueT NativeTableType;
  typedef FloatValueBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAL = 4
  };
  float val() const {
    return GetField<float>(VT_VAL, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_VAL, 4) &&
           verifier.EndTable();
  }
  FloatValueT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FloatValueT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FloatValue> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FloatValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FloatValueBuilder {
  typedef FloatValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_val(float val) {
    fbb_.AddElement<float>(FloatValue::VT_VAL, val, 0.0f);
  }
  explicit FloatValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FloatValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FloatValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FloatValue> CreateFloatValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float val = 0.0f) {
  FloatValueBuilder builder_(_fbb);
  builder_.add_val(val);
  return builder_.Finish();
}

struct FloatValue::Traits {
  using type = FloatValue;
  static auto constexpr Create = CreateFloatValue;
};

::flatbuffers::Offset<FloatValue> CreateFloatValue(::flatbuffers::FlatBufferBuilder &_fbb, const FloatValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StringRefT : public ::flatbuffers::NativeTable {
  typedef StringRef TableType;
  int32_t index = 0;
};

struct StringRef FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringRefT NativeTableType;
  typedef StringRefBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4
  };
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           verifier.EndTable();
  }
  StringRefT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StringRefT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StringRef> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StringRefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StringRefBuilder {
  typedef StringRef Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(StringRef::VT_INDEX, index, 0);
  }
  explicit StringRefBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringRef>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringRef> CreateStringRef(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t index = 0) {
  StringRefBuilder builder_(_fbb);
  builder_.add_index(index);
  return builder_.Finish();
}

struct StringRef::Traits {
  using type = StringRef;
  static auto constexpr Create = CreateStringRef;
};

::flatbuffers::Offset<StringRef> CreateStringRef(::flatbuffers::FlatBufferBuilder &_fbb, const StringRefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LineT : public ::flatbuffers::NativeTable {
  typedef Line TableType;
  int32_t character_id = -1;
  int32_t text_id = 0;
  int32_t voice_asset_id = -1;
};

struct Line FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LineT NativeTableType;
  typedef LineBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHARACTER_ID = 4,
    VT_TEXT_ID = 6,
    VT_VOICE_ASSET_ID = 8
  };
  int32_t character_id() const {
    return GetField<int32_t>(VT_CHARACTER_ID, -1);
  }
  int32_t text_id() const {
    return GetField<int32_t>(VT_TEXT_ID, 0);
  }
  int32_t voice_asset_id() const {
    return GetField<int32_t>(VT_VOICE_ASSET_ID, -1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHARACTER_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_TEXT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_VOICE_ASSET_ID, 4) &&
           verifier.EndTable();
  }
  LineT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LineT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Line> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LineT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LineBuilder {
  typedef Line Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_character_id(int32_t character_id) {
    fbb_.AddElement<int32_t>(Line::VT_CHARACTER_ID, character_id, -1);
  }
  void add_text_id(int32_t text_id) {
    fbb_.AddElement<int32_t>(Line::VT_TEXT_ID, text_id, 0);
  }
  void add_voice_asset_id(int32_t voice_asset_id) {
    fbb_.AddElement<int32_t>(Line::VT_VOICE_ASSET_ID, voice_asset_id, -1);
  }
  explicit LineBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Line> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Line>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Line> CreateLine(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t character_id = -1,
    int32_t text_id = 0,
    int32_t voice_asset_id = -1) {
  LineBuilder builder_(_fbb);
  builder_.add_voice_asset_id(voice_asset_id);
  builder_.add_text_id(text_id);
  builder_.add_character_id(character_id);
  return builder_.Finish();
}

struct Line::Traits {
  using type = Line;
  static auto constexpr Create = CreateLine;
};

::flatbuffers::Offset<Line> CreateLine(::flatbuffers::FlatBufferBuilder &_fbb, const LineT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ChoiceT : public ::flatbuffers::NativeTable {
  typedef Choice TableType;
  int32_t text_id = 0;
  int32_t target_node_name_id = 0;
  int32_t condition_var_id = -1;
};

struct Choice FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ChoiceT NativeTableType;
  typedef ChoiceBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT_ID = 4,
    VT_TARGET_NODE_NAME_ID = 6,
    VT_CONDITION_VAR_ID = 8
  };
  int32_t text_id() const {
    return GetField<int32_t>(VT_TEXT_ID, 0);
  }
  int32_t target_node_name_id() const {
    return GetField<int32_t>(VT_TARGET_NODE_NAME_ID, 0);
  }
  int32_t condition_var_id() const {
    return GetField<int32_t>(VT_CONDITION_VAR_ID, -1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TEXT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_TARGET_NODE_NAME_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_CONDITION_VAR_ID, 4) &&
           verifier.EndTable();
  }
  ChoiceT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ChoiceT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Choice> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ChoiceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ChoiceBuilder {
  typedef Choice Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text_id(int32_t text_id) {
    fbb_.AddElement<int32_t>(Choice::VT_TEXT_ID, text_id, 0);
  }
  void add_target_node_name_id(int32_t target_node_name_id) {
    fbb_.AddElement<int32_t>(Choice::VT_TARGET_NODE_NAME_ID, target_node_name_id, 0);
  }
  void add_condition_var_id(int32_t condition_var_id) {
    fbb_.AddElement<int32_t>(Choice::VT_CONDITION_VAR_ID, condition_var_id, -1);
  }
  explicit ChoiceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Choice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Choice>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Choice> CreateChoice(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t text_id = 0,
    int32_t target_node_name_id = 0,
    int32_t condition_var_id = -1) {
  ChoiceBuilder builder_(_fbb);
  builder_.add_condition_var_id(condition_var_id);
  builder_.add_target_node_name_id(target_node_name_id);
  builder_.add_text_id(text_id);
  return builder_.Finish();
}

struct Choice::Traits {
  using type = Choice;
  static auto constexpr Create = CreateChoice;
};

::flatbuffers::Offset<Choice> CreateChoice(::flatbuffers::FlatBufferBuilder &_fbb, const ChoiceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct JumpT : public ::flatbuffers::NativeTable {
  typedef Jump TableType;
  int32_t target_node_name_id = 0;
  bool is_call = false;
};

struct Jump FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef JumpT NativeTableType;
  typedef JumpBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET_NODE_NAME_ID = 4,
    VT_IS_CALL = 6
  };
  int32_t target_node_name_id() const {
    return GetField<int32_t>(VT_TARGET_NODE_NAME_ID, 0);
  }
  bool is_call() const {
    return GetField<uint8_t>(VT_IS_CALL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TARGET_NODE_NAME_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_IS_CALL, 1) &&
           verifier.EndTable();
  }
  JumpT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(JumpT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Jump> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JumpT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct JumpBuilder {
  typedef Jump Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target_node_name_id(int32_t target_node_name_id) {
    fbb_.AddElement<int32_t>(Jump::VT_TARGET_NODE_NAME_ID, target_node_name_id, 0);
  }
  void add_is_call(bool is_call) {
    fbb_.AddElement<uint8_t>(Jump::VT_IS_CALL, static_cast<uint8_t>(is_call), 0);
  }
  explicit JumpBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Jump> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Jump>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Jump> CreateJump(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t target_node_name_id = 0,
    bool is_call = false) {
  JumpBuilder builder_(_fbb);
  builder_.add_target_node_name_id(target_node_name_id);
  builder_.add_is_call(is_call);
  return builder_.Finish();
}

struct Jump::Traits {
  using type = Jump;
  static auto constexpr Create = CreateJump;
};

::flatbuffers::Offset<Jump> CreateJump(::flatbuffers::FlatBufferBuilder &_fbb, const JumpT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CommandT : public ::flatbuffers::NativeTable {
  typedef Command TableType;
  int32_t type_id = 0;
  std::vector<int32_t> params{};
};

struct Command FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CommandT NativeTableType;
  typedef CommandBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE_ID = 4,
    VT_PARAMS = 6
  };
  int32_t type_id() const {
    return GetField<int32_t>(VT_TYPE_ID, 0);
  }
  const ::flatbuffers::Vector<int32_t> *params() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PARAMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE_ID, 4) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           verifier.EndTable();
  }
  CommandT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CommandT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Command> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CommandBuilder {
  typedef Command Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type_id(int32_t type_id) {
    fbb_.AddElement<int32_t>(Command::VT_TYPE_ID, type_id, 0);
  }
  void add_params(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> params) {
    fbb_.AddOffset(Command::VT_PARAMS, params);
  }
  explicit CommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Command> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Command>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Command> CreateCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> params = 0) {
  CommandBuilder builder_(_fbb);
  builder_.add_params(params);
  builder_.add_type_id(type_id);
  return builder_.Finish();
}

struct Command::Traits {
  using type = Command;
  static auto constexpr Create = CreateCommand;
};

inline ::flatbuffers::Offset<Command> CreateCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type_id = 0,
    const std::vector<int32_t> *params = nullptr) {
  auto params__ = params ? _fbb.CreateVector<int32_t>(*params) : 0;
  return ICPDev::Gyeol::Schema::CreateCommand(
      _fbb,
      type_id,
      params__);
}

::flatbuffers::Offset<Command> CreateCommand(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExprTokenT : public ::flatbuffers::NativeTable {
  typedef ExprToken TableType;
  ICPDev::Gyeol::Schema::ExprOp op = ICPDev::Gyeol::Schema::ExprOp::PushLiteral;
  ICPDev::Gyeol::Schema::ValueDataUnion literal_value{};
  int32_t var_name_id = -1;
};

struct ExprToken FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExprTokenT NativeTableType;
  typedef ExprTokenBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP = 4,
    VT_LITERAL_VALUE_TYPE = 6,
    VT_LITERAL_VALUE = 8,
    VT_VAR_NAME_ID = 10
  };
  ICPDev::Gyeol::Schema::ExprOp op() const {
    return static_cast<ICPDev::Gyeol::Schema::ExprOp>(GetField<int8_t>(VT_OP, 0));
  }
  ICPDev::Gyeol::Schema::ValueData literal_value_type() const {
    return static_cast<ICPDev::Gyeol::Schema::ValueData>(GetField<uint8_t>(VT_LITERAL_VALUE_TYPE, 0));
  }
  const void *literal_value() const {
    return GetPointer<const void *>(VT_LITERAL_VALUE);
  }
  template<typename T> const T *literal_value_as() const;
  const ICPDev::Gyeol::Schema::BoolValue *literal_value_as_BoolValue() const {
    return literal_value_type() == ICPDev::Gyeol::Schema::ValueData::BoolValue ? static_cast<const ICPDev::Gyeol::Schema::BoolValue *>(literal_value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::IntValue *literal_value_as_IntValue() const {
    return literal_value_type() == ICPDev::Gyeol::Schema::ValueData::IntValue ? static_cast<const ICPDev::Gyeol::Schema::IntValue *>(literal_value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::FloatValue *literal_value_as_FloatValue() const {
    return literal_value_type() == ICPDev::Gyeol::Schema::ValueData::FloatValue ? static_cast<const ICPDev::Gyeol::Schema::FloatValue *>(literal_value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::StringRef *literal_value_as_StringRef() const {
    return literal_value_type() == ICPDev::Gyeol::Schema::ValueData::StringRef ? static_cast<const ICPDev::Gyeol::Schema::StringRef *>(literal_value()) : nullptr;
  }
  int32_t var_name_id() const {
    return GetField<int32_t>(VT_VAR_NAME_ID, -1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OP, 1) &&
           VerifyField<uint8_t>(verifier, VT_LITERAL_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_LITERAL_VALUE) &&
           VerifyValueData(verifier, literal_value(), literal_value_type()) &&
           VerifyField<int32_t>(verifier, VT_VAR_NAME_ID, 4) &&
           verifier.EndTable();
  }
  ExprTokenT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExprTokenT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ExprToken> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExprTokenT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ICPDev::Gyeol::Schema::BoolValue *ExprToken::literal_value_as<ICPDev::Gyeol::Schema::BoolValue>() const {
  return literal_value_as_BoolValue();
}

template<> inline const ICPDev::Gyeol::Schema::IntValue *ExprToken::literal_value_as<ICPDev::Gyeol::Schema::IntValue>() const {
  return literal_value_as_IntValue();
}

template<> inline const ICPDev::Gyeol::Schema::FloatValue *ExprToken::literal_value_as<ICPDev::Gyeol::Schema::FloatValue>() const {
  return literal_value_as_FloatValue();
}

template<> inline const ICPDev::Gyeol::Schema::StringRef *ExprToken::literal_value_as<ICPDev::Gyeol::Schema::StringRef>() const {
  return literal_value_as_StringRef();
}

struct ExprTokenBuilder {
  typedef ExprToken Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op(ICPDev::Gyeol::Schema::ExprOp op) {
    fbb_.AddElement<int8_t>(ExprToken::VT_OP, static_cast<int8_t>(op), 0);
  }
  void add_literal_value_type(ICPDev::Gyeol::Schema::ValueData literal_value_type) {
    fbb_.AddElement<uint8_t>(ExprToken::VT_LITERAL_VALUE_TYPE, static_cast<uint8_t>(literal_value_type), 0);
  }
  void add_literal_value(::flatbuffers::Offset<void> literal_value) {
    fbb_.AddOffset(ExprToken::VT_LITERAL_VALUE, literal_value);
  }
  void add_var_name_id(int32_t var_name_id) {
    fbb_.AddElement<int32_t>(ExprToken::VT_VAR_NAME_ID, var_name_id, -1);
  }
  explicit ExprTokenBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExprToken> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExprToken>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ExprToken> CreateExprToken(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ICPDev::Gyeol::Schema::ExprOp op = ICPDev::Gyeol::Schema::ExprOp::PushLiteral,
    ICPDev::Gyeol::Schema::ValueData literal_value_type = ICPDev::Gyeol::Schema::ValueData::NONE,
    ::flatbuffers::Offset<void> literal_value = 0,
    int32_t var_name_id = -1) {
  ExprTokenBuilder builder_(_fbb);
  builder_.add_var_name_id(var_name_id);
  builder_.add_literal_value(literal_value);
  builder_.add_literal_value_type(literal_value_type);
  builder_.add_op(op);
  return builder_.Finish();
}

struct ExprToken::Traits {
  using type = ExprToken;
  static auto constexpr Create = CreateExprToken;
};

::flatbuffers::Offset<ExprToken> CreateExprToken(::flatbuffers::FlatBufferBuilder &_fbb, const ExprTokenT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExpressionT : public ::flatbuffers::NativeTable {
  typedef Expression TableType;
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::ExprTokenT>> tokens{};
  ExpressionT() = default;
  ExpressionT(const ExpressionT &o);
  ExpressionT(ExpressionT&&) FLATBUFFERS_NOEXCEPT = default;
  ExpressionT &operator=(ExpressionT o) FLATBUFFERS_NOEXCEPT;
};

struct Expression FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExpressionT NativeTableType;
  typedef ExpressionBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKENS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::ExprToken>> *tokens() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::ExprToken>> *>(VT_TOKENS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOKENS) &&
           verifier.VerifyVector(tokens()) &&
           verifier.VerifyVectorOfTables(tokens()) &&
           verifier.EndTable();
  }
  ExpressionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExpressionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Expression> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExpressionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExpressionBuilder {
  typedef Expression Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tokens(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::ExprToken>>> tokens) {
    fbb_.AddOffset(Expression::VT_TOKENS, tokens);
  }
  explicit ExpressionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Expression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Expression>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Expression> CreateExpression(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::ExprToken>>> tokens = 0) {
  ExpressionBuilder builder_(_fbb);
  builder_.add_tokens(tokens);
  return builder_.Finish();
}

struct Expression::Traits {
  using type = Expression;
  static auto constexpr Create = CreateExpression;
};

inline ::flatbuffers::Offset<Expression> CreateExpressionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::ExprToken>> *tokens = nullptr) {
  auto tokens__ = tokens ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::ExprToken>>(*tokens) : 0;
  return ICPDev::Gyeol::Schema::CreateExpression(
      _fbb,
      tokens__);
}

::flatbuffers::Offset<Expression> CreateExpression(::flatbuffers::FlatBufferBuilder &_fbb, const ExpressionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SetVarT : public ::flatbuffers::NativeTable {
  typedef SetVar TableType;
  int32_t var_name_id = 0;
  ICPDev::Gyeol::Schema::ValueDataUnion value{};
  std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT> expr{};
  SetVarT() = default;
  SetVarT(const SetVarT &o);
  SetVarT(SetVarT&&) FLATBUFFERS_NOEXCEPT = default;
  SetVarT &operator=(SetVarT o) FLATBUFFERS_NOEXCEPT;
};

struct SetVar FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SetVarT NativeTableType;
  typedef SetVarBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAR_NAME_ID = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8,
    VT_EXPR = 10
  };
  int32_t var_name_id() const {
    return GetField<int32_t>(VT_VAR_NAME_ID, 0);
  }
  ICPDev::Gyeol::Schema::ValueData value_type() const {
    return static_cast<ICPDev::Gyeol::Schema::ValueData>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const ICPDev::Gyeol::Schema::BoolValue *value_as_BoolValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::BoolValue ? static_cast<const ICPDev::Gyeol::Schema::BoolValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::IntValue *value_as_IntValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::IntValue ? static_cast<const ICPDev::Gyeol::Schema::IntValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::FloatValue *value_as_FloatValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::FloatValue ? static_cast<const ICPDev::Gyeol::Schema::FloatValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::StringRef *value_as_StringRef() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::StringRef ? static_cast<const ICPDev::Gyeol::Schema::StringRef *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::Expression *expr() const {
    return GetPointer<const ICPDev::Gyeol::Schema::Expression *>(VT_EXPR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VAR_NAME_ID, 4) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValueData(verifier, value(), value_type()) &&
           VerifyOffset(verifier, VT_EXPR) &&
           verifier.VerifyTable(expr()) &&
           verifier.EndTable();
  }
  SetVarT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SetVarT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SetVar> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetVarT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ICPDev::Gyeol::Schema::BoolValue *SetVar::value_as<ICPDev::Gyeol::Schema::BoolValue>() const {
  return value_as_BoolValue();
}

template<> inline const ICPDev::Gyeol::Schema::IntValue *SetVar::value_as<ICPDev::Gyeol::Schema::IntValue>() const {
  return value_as_IntValue();
}

template<> inline const ICPDev::Gyeol::Schema::FloatValue *SetVar::value_as<ICPDev::Gyeol::Schema::FloatValue>() const {
  return value_as_FloatValue();
}

template<> inline const ICPDev::Gyeol::Schema::StringRef *SetVar::value_as<ICPDev::Gyeol::Schema::StringRef>() const {
  return value_as_StringRef();
}

struct SetVarBuilder {
  typedef SetVar Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_var_name_id(int32_t var_name_id) {
    fbb_.AddElement<int32_t>(SetVar::VT_VAR_NAME_ID, var_name_id, 0);
  }
  void add_value_type(ICPDev::Gyeol::Schema::ValueData value_type) {
    fbb_.AddElement<uint8_t>(SetVar::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(SetVar::VT_VALUE, value);
  }
  void add_expr(::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> expr) {
    fbb_.AddOffset(SetVar::VT_EXPR, expr);
  }
  explicit SetVarBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SetVar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SetVar>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SetVar> CreateSetVar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t var_name_id = 0,
    ICPDev::Gyeol::Schema::ValueData value_type = ICPDev::Gyeol::Schema::ValueData::NONE,
    ::flatbuffers::Offset<void> value = 0,
    ::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> expr = 0) {
  SetVarBuilder builder_(_fbb);
  builder_.add_expr(expr);
  builder_.add_value(value);
  builder_.add_var_name_id(var_name_id);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct SetVar::Traits {
  using type = SetVar;
  static auto constexpr Create = CreateSetVar;
};

::flatbuffers::Offset<SetVar> CreateSetVar(::flatbuffers::FlatBufferBuilder &_fbb, const SetVarT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ConditionT : public ::flatbuffers::NativeTable {
  typedef Condition TableType;
  int32_t var_name_id = 0;
  ICPDev::Gyeol::Schema::Operator op = ICPDev::Gyeol::Schema::Operator::Equal;
  ICPDev::Gyeol::Schema::ValueDataUnion compare_value{};
  int32_t true_jump_node_id = 0;
  int32_t false_jump_node_id = 0;
  std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT> lhs_expr{};
  std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT> rhs_expr{};
  std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT> cond_expr{};
  ConditionT() = default;
  ConditionT(const ConditionT &o);
  ConditionT(ConditionT&&) FLATBUFFERS_NOEXCEPT = default;
  ConditionT &operator=(ConditionT o) FLATBUFFERS_NOEXCEPT;
};

struct Condition FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConditionT NativeTableType;
  typedef ConditionBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VAR_NAME_ID = 4,
    VT_OP = 6,
    VT_COMPARE_VALUE_TYPE = 8,
    VT_COMPARE_VALUE = 10,
    VT_TRUE_JUMP_NODE_ID = 12,
    VT_FALSE_JUMP_NODE_ID = 14,
    VT_LHS_EXPR = 16,
    VT_RHS_EXPR = 18,
    VT_COND_EXPR = 20
  };
  int32_t var_name_id() const {
    return GetField<int32_t>(VT_VAR_NAME_ID, 0);
  }
  ICPDev::Gyeol::Schema::Operator op() const {
    return static_cast<ICPDev::Gyeol::Schema::Operator>(GetField<int8_t>(VT_OP, 0));
  }
  ICPDev::Gyeol::Schema::ValueData compare_value_type() const {
    return static_cast<ICPDev::Gyeol::Schema::ValueData>(GetField<uint8_t>(VT_COMPARE_VALUE_TYPE, 0));
  }
  const void *compare_value() const {
    return GetPointer<const void *>(VT_COMPARE_VALUE);
  }
  template<typename T> const T *compare_value_as() const;
  const ICPDev::Gyeol::Schema::BoolValue *compare_value_as_BoolValue() const {
    return compare_value_type() == ICPDev::Gyeol::Schema::ValueData::BoolValue ? static_cast<const ICPDev::Gyeol::Schema::BoolValue *>(compare_value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::IntValue *compare_value_as_IntValue() const {
    return compare_value_type() == ICPDev::Gyeol::Schema::ValueData::IntValue ? static_cast<const ICPDev::Gyeol::Schema::IntValue *>(compare_value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::FloatValue *compare_value_as_FloatValue() const {
    return compare_value_type() == ICPDev::Gyeol::Schema::ValueData::FloatValue ? static_cast<const ICPDev::Gyeol::Schema::FloatValue *>(compare_value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::StringRef *compare_value_as_StringRef() const {
    return compare_value_type() == ICPDev::Gyeol::Schema::ValueData::StringRef ? static_cast<const ICPDev::Gyeol::Schema::StringRef *>(compare_value()) : nullptr;
  }
  int32_t true_jump_node_id() const {
    return GetField<int32_t>(VT_TRUE_JUMP_NODE_ID, 0);
  }
  int32_t false_jump_node_id() const {
    return GetField<int32_t>(VT_FALSE_JUMP_NODE_ID, 0);
  }
  const ICPDev::Gyeol::Schema::Expression *lhs_expr() const {
    return GetPointer<const ICPDev::Gyeol::Schema::Expression *>(VT_LHS_EXPR);
  }
  const ICPDev::Gyeol::Schema::Expression *rhs_expr() const {
    return GetPointer<const ICPDev::Gyeol::Schema::Expression *>(VT_RHS_EXPR);
  }
  const ICPDev::Gyeol::Schema::Expression *cond_expr() const {
    return GetPointer<const ICPDev::Gyeol::Schema::Expression *>(VT_COND_EXPR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VAR_NAME_ID, 4) &&
           VerifyField<int8_t>(verifier, VT_OP, 1) &&
           VerifyField<uint8_t>(verifier, VT_COMPARE_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_COMPARE_VALUE) &&
           VerifyValueData(verifier, compare_value(), compare_value_type()) &&
           VerifyField<int32_t>(verifier, VT_TRUE_JUMP_NODE_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_FALSE_JUMP_NODE_ID, 4) &&
           VerifyOffset(verifier, VT_LHS_EXPR) &&
           verifier.VerifyTable(lhs_expr()) &&
           VerifyOffset(verifier, VT_RHS_EXPR) &&
           verifier.VerifyTable(rhs_expr()) &&
           VerifyOffset(verifier, VT_COND_EXPR) &&
           verifier.VerifyTable(cond_expr()) &&
           verifier.EndTable();
  }
  ConditionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ConditionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Condition> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConditionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ICPDev::Gyeol::Schema::BoolValue *Condition::compare_value_as<ICPDev::Gyeol::Schema::BoolValue>() const {
  return compare_value_as_BoolValue();
}

template<> inline const ICPDev::Gyeol::Schema::IntValue *Condition::compare_value_as<ICPDev::Gyeol::Schema::IntValue>() const {
  return compare_value_as_IntValue();
}

template<> inline const ICPDev::Gyeol::Schema::FloatValue *Condition::compare_value_as<ICPDev::Gyeol::Schema::FloatValue>() const {
  return compare_value_as_FloatValue();
}

template<> inline const ICPDev::Gyeol::Schema::StringRef *Condition::compare_value_as<ICPDev::Gyeol::Schema::StringRef>() const {
  return compare_value_as_StringRef();
}

struct ConditionBuilder {
  typedef Condition Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_var_name_id(int32_t var_name_id) {
    fbb_.AddElement<int32_t>(Condition::VT_VAR_NAME_ID, var_name_id, 0);
  }
  void add_op(ICPDev::Gyeol::Schema::Operator op) {
    fbb_.AddElement<int8_t>(Condition::VT_OP, static_cast<int8_t>(op), 0);
  }
  void add_compare_value_type(ICPDev::Gyeol::Schema::ValueData compare_value_type) {
    fbb_.AddElement<uint8_t>(Condition::VT_COMPARE_VALUE_TYPE, static_cast<uint8_t>(compare_value_type), 0);
  }
  void add_compare_value(::flatbuffers::Offset<void> compare_value) {
    fbb_.AddOffset(Condition::VT_COMPARE_VALUE, compare_value);
  }
  void add_true_jump_node_id(int32_t true_jump_node_id) {
    fbb_.AddElement<int32_t>(Condition::VT_TRUE_JUMP_NODE_ID, true_jump_node_id, 0);
  }
  void add_false_jump_node_id(int32_t false_jump_node_id) {
    fbb_.AddElement<int32_t>(Condition::VT_FALSE_JUMP_NODE_ID, false_jump_node_id, 0);
  }
  void add_lhs_expr(::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> lhs_expr) {
    fbb_.AddOffset(Condition::VT_LHS_EXPR, lhs_expr);
  }
  void add_rhs_expr(::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> rhs_expr) {
    fbb_.AddOffset(Condition::VT_RHS_EXPR, rhs_expr);
  }
  void add_cond_expr(::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> cond_expr) {
    fbb_.AddOffset(Condition::VT_COND_EXPR, cond_expr);
  }
  explicit ConditionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Condition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Condition>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Condition> CreateCondition(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t var_name_id = 0,
    ICPDev::Gyeol::Schema::Operator op = ICPDev::Gyeol::Schema::Operator::Equal,
    ICPDev::Gyeol::Schema::ValueData compare_value_type = ICPDev::Gyeol::Schema::ValueData::NONE,
    ::flatbuffers::Offset<void> compare_value = 0,
    int32_t true_jump_node_id = 0,
    int32_t false_jump_node_id = 0,
    ::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> lhs_expr = 0,
    ::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> rhs_expr = 0,
    ::flatbuffers::Offset<ICPDev::Gyeol::Schema::Expression> cond_expr = 0) {
  ConditionBuilder builder_(_fbb);
  builder_.add_cond_expr(cond_expr);
  builder_.add_rhs_expr(rhs_expr);
  builder_.add_lhs_expr(lhs_expr);
  builder_.add_false_jump_node_id(false_jump_node_id);
  builder_.add_true_jump_node_id(true_jump_node_id);
  builder_.add_compare_value(compare_value);
  builder_.add_var_name_id(var_name_id);
  builder_.add_compare_value_type(compare_value_type);
  builder_.add_op(op);
  return builder_.Finish();
}

struct Condition::Traits {
  using type = Condition;
  static auto constexpr Create = CreateCondition;
};

::flatbuffers::Offset<Condition> CreateCondition(::flatbuffers::FlatBufferBuilder &_fbb, const ConditionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RandomBranchT : public ::flatbuffers::NativeTable {
  typedef RandomBranch TableType;
  int32_t target_node_name_id = 0;
  int32_t weight = 1;
};

struct RandomBranch FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RandomBranchT NativeTableType;
  typedef RandomBranchBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TARGET_NODE_NAME_ID = 4,
    VT_WEIGHT = 6
  };
  int32_t target_node_name_id() const {
    return GetField<int32_t>(VT_TARGET_NODE_NAME_ID, 0);
  }
  int32_t weight() const {
    return GetField<int32_t>(VT_WEIGHT, 1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TARGET_NODE_NAME_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_WEIGHT, 4) &&
           verifier.EndTable();
  }
  RandomBranchT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RandomBranchT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RandomBranch> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RandomBranchT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RandomBranchBuilder {
  typedef RandomBranch Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_target_node_name_id(int32_t target_node_name_id) {
    fbb_.AddElement<int32_t>(RandomBranch::VT_TARGET_NODE_NAME_ID, target_node_name_id, 0);
  }
  void add_weight(int32_t weight) {
    fbb_.AddElement<int32_t>(RandomBranch::VT_WEIGHT, weight, 1);
  }
  explicit RandomBranchBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RandomBranch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RandomBranch>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RandomBranch> CreateRandomBranch(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t target_node_name_id = 0,
    int32_t weight = 1) {
  RandomBranchBuilder builder_(_fbb);
  builder_.add_weight(weight);
  builder_.add_target_node_name_id(target_node_name_id);
  return builder_.Finish();
}

struct RandomBranch::Traits {
  using type = RandomBranch;
  static auto constexpr Create = CreateRandomBranch;
};

::flatbuffers::Offset<RandomBranch> CreateRandomBranch(::flatbuffers::FlatBufferBuilder &_fbb, const RandomBranchT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RandomT : public ::flatbuffers::NativeTable {
  typedef Random TableType;
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::RandomBranchT>> branches{};
  RandomT() = default;
  RandomT(const RandomT &o);
  RandomT(RandomT&&) FLATBUFFERS_NOEXCEPT = default;
  RandomT &operator=(RandomT o) FLATBUFFERS_NOEXCEPT;
};

struct Random FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RandomT NativeTableType;
  typedef RandomBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BRANCHES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::RandomBranch>> *branches() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::RandomBranch>> *>(VT_BRANCHES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BRANCHES) &&
           verifier.VerifyVector(branches()) &&
           verifier.VerifyVectorOfTables(branches()) &&
           verifier.EndTable();
  }
  RandomT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RandomT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Random> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RandomT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RandomBuilder {
  typedef Random Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_branches(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::RandomBranch>>> branches) {
    fbb_.AddOffset(Random::VT_BRANCHES, branches);
  }
  explicit RandomBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Random> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Random>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Random> CreateRandom(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::RandomBranch>>> branches = 0) {
  RandomBuilder builder_(_fbb);
  builder_.add_branches(branches);
  return builder_.Finish();
}

struct Random::Traits {
  using type = Random;
  static auto constexpr Create = CreateRandom;
};

inline ::flatbuffers::Offset<Random> CreateRandomDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::RandomBranch>> *branches = nullptr) {
  auto branches__ = branches ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::RandomBranch>>(*branches) : 0;
  return ICPDev::Gyeol::Schema::CreateRandom(
      _fbb,
      branches__);
}

::flatbuffers::Offset<Random> CreateRandom(::flatbuffers::FlatBufferBuilder &_fbb, const RandomT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct InstructionT : public ::flatbuffers::NativeTable {
  typedef Instruction TableType;
  ICPDev::Gyeol::Schema::OpDataUnion data{};
};

struct Instruction FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InstructionT NativeTableType;
  typedef InstructionBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_DATA = 6
  };
  ICPDev::Gyeol::Schema::OpData data_type() const {
    return static_cast<ICPDev::Gyeol::Schema::OpData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const ICPDev::Gyeol::Schema::Line *data_as_Line() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Line ? static_cast<const ICPDev::Gyeol::Schema::Line *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::Choice *data_as_Choice() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Choice ? static_cast<const ICPDev::Gyeol::Schema::Choice *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::Jump *data_as_Jump() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Jump ? static_cast<const ICPDev::Gyeol::Schema::Jump *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::Command *data_as_Command() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Command ? static_cast<const ICPDev::Gyeol::Schema::Command *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::SetVar *data_as_SetVar() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::SetVar ? static_cast<const ICPDev::Gyeol::Schema::SetVar *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::Condition *data_as_Condition() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Condition ? static_cast<const ICPDev::Gyeol::Schema::Condition *>(data()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::Random *data_as_Random() const {
    return data_type() == ICPDev::Gyeol::Schema::OpData::Random ? static_cast<const ICPDev::Gyeol::Schema::Random *>(data()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyOpData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
  InstructionT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(InstructionT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Instruction> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InstructionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ICPDev::Gyeol::Schema::Line *Instruction::data_as<ICPDev::Gyeol::Schema::Line>() const {
  return data_as_Line();
}

template<> inline const ICPDev::Gyeol::Schema::Choice *Instruction::data_as<ICPDev::Gyeol::Schema::Choice>() const {
  return data_as_Choice();
}

template<> inline const ICPDev::Gyeol::Schema::Jump *Instruction::data_as<ICPDev::Gyeol::Schema::Jump>() const {
  return data_as_Jump();
}

template<> inline const ICPDev::Gyeol::Schema::Command *Instruction::data_as<ICPDev::Gyeol::Schema::Command>() const {
  return data_as_Command();
}

template<> inline const ICPDev::Gyeol::Schema::SetVar *Instruction::data_as<ICPDev::Gyeol::Schema::SetVar>() const {
  return data_as_SetVar();
}

template<> inline const ICPDev::Gyeol::Schema::Condition *Instruction::data_as<ICPDev::Gyeol::Schema::Condition>() const {
  return data_as_Condition();
}

template<> inline const ICPDev::Gyeol::Schema::Random *Instruction::data_as<ICPDev::Gyeol::Schema::Random>() const {
  return data_as_Random();
}

struct InstructionBuilder {
  typedef Instruction Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data_type(ICPDev::Gyeol::Schema::OpData data_type) {
    fbb_.AddElement<uint8_t>(Instruction::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(::flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Instruction::VT_DATA, data);
  }
  explicit InstructionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Instruction> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Instruction>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Instruction> CreateInstruction(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ICPDev::Gyeol::Schema::OpData data_type = ICPDev::Gyeol::Schema::OpData::NONE,
    ::flatbuffers::Offset<void> data = 0) {
  InstructionBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

struct Instruction::Traits {
  using type = Instruction;
  static auto constexpr Create = CreateInstruction;
};

::flatbuffers::Offset<Instruction> CreateInstruction(::flatbuffers::FlatBufferBuilder &_fbb, const InstructionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NodeT : public ::flatbuffers::NativeTable {
  typedef Node TableType;
  std::string name{};
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::InstructionT>> lines{};
  NodeT() = default;
  NodeT(const NodeT &o);
  NodeT(NodeT&&) FLATBUFFERS_NOEXCEPT = default;
  NodeT &operator=(NodeT o) FLATBUFFERS_NOEXCEPT;
};

struct Node FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NodeT NativeTableType;
  typedef NodeBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_LINES = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool KeyCompareLessThan(const Node * const o) const {
    return *name() < *o->name();
  }
  int KeyCompareWithValue(const char *_name) const {
    return strcmp(name()->c_str(), _name);
  }
  template<typename StringType>
  int KeyCompareWithValue(const StringType& _name) const {
    if (name()->c_str() < _name) return -1;
    if (_name < name()->c_str()) return 1;
    return 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>> *lines() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>> *>(VT_LINES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_LINES) &&
           verifier.VerifyVector(lines()) &&
           verifier.VerifyVectorOfTables(lines()) &&
           verifier.EndTable();
  }
  NodeT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NodeT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Node> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NodeBuilder {
  typedef Node Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Node::VT_NAME, name);
  }
  void add_lines(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>>> lines) {
    fbb_.AddOffset(Node::VT_LINES, lines);
  }
  explicit NodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Node> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Node>(end);
    fbb_.Required(o, Node::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<Node> CreateNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>>> lines = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_lines(lines);
  builder_.add_name(name);
  return builder_.Finish();
}

struct Node::Traits {
  using type = Node;
  static auto constexpr Create = CreateNode;
};

inline ::flatbuffers::Offset<Node> CreateNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>> *lines = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto lines__ = lines ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>>(*lines) : 0;
  return ICPDev::Gyeol::Schema::CreateNode(
      _fbb,
      name__,
      lines__);
}

::flatbuffers::Offset<Node> CreateNode(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SavedVarT : public ::flatbuffers::NativeTable {
  typedef SavedVar TableType;
  std::string name{};
  ICPDev::Gyeol::Schema::ValueDataUnion value{};
  std::string string_value{};
};

struct SavedVar FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SavedVarT NativeTableType;
  typedef SavedVarBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8,
    VT_STRING_VALUE = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  ICPDev::Gyeol::Schema::ValueData value_type() const {
    return static_cast<ICPDev::Gyeol::Schema::ValueData>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const ICPDev::Gyeol::Schema::BoolValue *value_as_BoolValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::BoolValue ? static_cast<const ICPDev::Gyeol::Schema::BoolValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::IntValue *value_as_IntValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::IntValue ? static_cast<const ICPDev::Gyeol::Schema::IntValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::FloatValue *value_as_FloatValue() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::FloatValue ? static_cast<const ICPDev::Gyeol::Schema::FloatValue *>(value()) : nullptr;
  }
  const ICPDev::Gyeol::Schema::StringRef *value_as_StringRef() const {
    return value_type() == ICPDev::Gyeol::Schema::ValueData::StringRef ? static_cast<const ICPDev::Gyeol::Schema::StringRef *>(value()) : nullptr;
  }
  const ::flatbuffers::String *string_value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STRING_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyValueData(verifier, value(), value_type()) &&
           VerifyOffset(verifier, VT_STRING_VALUE) &&
           verifier.VerifyString(string_value()) &&
           verifier.EndTable();
  }
  SavedVarT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SavedVarT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SavedVar> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SavedVarT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const ICPDev::Gyeol::Schema::BoolValue *SavedVar::value_as<ICPDev::Gyeol::Schema::BoolValue>() const {
  return value_as_BoolValue();
}

template<> inline const ICPDev::Gyeol::Schema::IntValue *SavedVar::value_as<ICPDev::Gyeol::Schema::IntValue>() const {
  return value_as_IntValue();
}

template<> inline const ICPDev::Gyeol::Schema::FloatValue *SavedVar::value_as<ICPDev::Gyeol::Schema::FloatValue>() const {
  return value_as_FloatValue();
}

template<> inline const ICPDev::Gyeol::Schema::StringRef *SavedVar::value_as<ICPDev::Gyeol::Schema::StringRef>() const {
  return value_as_StringRef();
}

struct SavedVarBuilder {
  typedef SavedVar Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SavedVar::VT_NAME, name);
  }
  void add_value_type(ICPDev::Gyeol::Schema::ValueData value_type) {
    fbb_.AddElement<uint8_t>(SavedVar::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(SavedVar::VT_VALUE, value);
  }
  void add_string_value(::flatbuffers::Offset<::flatbuffers::String> string_value) {
    fbb_.AddOffset(SavedVar::VT_STRING_VALUE, string_value);
  }
  explicit SavedVarBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SavedVar> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SavedVar>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SavedVar> CreateSavedVar(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ICPDev::Gyeol::Schema::ValueData value_type = ICPDev::Gyeol::Schema::ValueData::NONE,
    ::flatbuffers::Offset<void> value = 0,
    ::flatbuffers::Offset<::flatbuffers::String> string_value = 0) {
  SavedVarBuilder builder_(_fbb);
  builder_.add_string_value(string_value);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct SavedVar::Traits {
  using type = SavedVar;
  static auto constexpr Create = CreateSavedVar;
};

inline ::flatbuffers::Offset<SavedVar> CreateSavedVarDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ICPDev::Gyeol::Schema::ValueData value_type = ICPDev::Gyeol::Schema::ValueData::NONE,
    ::flatbuffers::Offset<void> value = 0,
    const char *string_value = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto string_value__ = string_value ? _fbb.CreateString(string_value) : 0;
  return ICPDev::Gyeol::Schema::CreateSavedVar(
      _fbb,
      name__,
      value_type,
      value,
      string_value__);
}

::flatbuffers::Offset<SavedVar> CreateSavedVar(::flatbuffers::FlatBufferBuilder &_fbb, const SavedVarT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SavedCallFrameT : public ::flatbuffers::NativeTable {
  typedef SavedCallFrame TableType;
  std::string node_name{};
  uint32_t pc = 0;
};

struct SavedCallFrame FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SavedCallFrameT NativeTableType;
  typedef SavedCallFrameBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE_NAME = 4,
    VT_PC = 6
  };
  const ::flatbuffers::String *node_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NODE_NAME);
  }
  uint32_t pc() const {
    return GetField<uint32_t>(VT_PC, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NODE_NAME) &&
           verifier.VerifyString(node_name()) &&
           VerifyField<uint32_t>(verifier, VT_PC, 4) &&
           verifier.EndTable();
  }
  SavedCallFrameT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SavedCallFrameT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SavedCallFrame> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SavedCallFrameT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SavedCallFrameBuilder {
  typedef SavedCallFrame Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_node_name(::flatbuffers::Offset<::flatbuffers::String> node_name) {
    fbb_.AddOffset(SavedCallFrame::VT_NODE_NAME, node_name);
  }
  void add_pc(uint32_t pc) {
    fbb_.AddElement<uint32_t>(SavedCallFrame::VT_PC, pc, 0);
  }
  explicit SavedCallFrameBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SavedCallFrame> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SavedCallFrame>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SavedCallFrame> CreateSavedCallFrame(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> node_name = 0,
    uint32_t pc = 0) {
  SavedCallFrameBuilder builder_(_fbb);
  builder_.add_pc(pc);
  builder_.add_node_name(node_name);
  return builder_.Finish();
}

struct SavedCallFrame::Traits {
  using type = SavedCallFrame;
  static auto constexpr Create = CreateSavedCallFrame;
};

inline ::flatbuffers::Offset<SavedCallFrame> CreateSavedCallFrameDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *node_name = nullptr,
    uint32_t pc = 0) {
  auto node_name__ = node_name ? _fbb.CreateString(node_name) : 0;
  return ICPDev::Gyeol::Schema::CreateSavedCallFrame(
      _fbb,
      node_name__,
      pc);
}

::flatbuffers::Offset<SavedCallFrame> CreateSavedCallFrame(::flatbuffers::FlatBufferBuilder &_fbb, const SavedCallFrameT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SavedPendingChoiceT : public ::flatbuffers::NativeTable {
  typedef SavedPendingChoice TableType;
  std::string text{};
  std::string target_node_name{};
};

struct SavedPendingChoice FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SavedPendingChoiceT NativeTableType;
  typedef SavedPendingChoiceBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4,
    VT_TARGET_NODE_NAME = 6
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  const ::flatbuffers::String *target_node_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TARGET_NODE_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyOffset(verifier, VT_TARGET_NODE_NAME) &&
           verifier.VerifyString(target_node_name()) &&
           verifier.EndTable();
  }
  SavedPendingChoiceT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SavedPendingChoiceT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SavedPendingChoice> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SavedPendingChoiceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SavedPendingChoiceBuilder {
  typedef SavedPendingChoice Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(SavedPendingChoice::VT_TEXT, text);
  }
  void add_target_node_name(::flatbuffers::Offset<::flatbuffers::String> target_node_name) {
    fbb_.AddOffset(SavedPendingChoice::VT_TARGET_NODE_NAME, target_node_name);
  }
  explicit SavedPendingChoiceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SavedPendingChoice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SavedPendingChoice>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SavedPendingChoice> CreateSavedPendingChoice(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    ::flatbuffers::Offset<::flatbuffers::String> target_node_name = 0) {
  SavedPendingChoiceBuilder builder_(_fbb);
  builder_.add_target_node_name(target_node_name);
  builder_.add_text(text);
  return builder_.Finish();
}

struct SavedPendingChoice::Traits {
  using type = SavedPendingChoice;
  static auto constexpr Create = CreateSavedPendingChoice;
};

inline ::flatbuffers::Offset<SavedPendingChoice> CreateSavedPendingChoiceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    const char *target_node_name = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  auto target_node_name__ = target_node_name ? _fbb.CreateString(target_node_name) : 0;
  return ICPDev::Gyeol::Schema::CreateSavedPendingChoice(
      _fbb,
      text__,
      target_node_name__);
}

::flatbuffers::Offset<SavedPendingChoice> CreateSavedPendingChoice(::flatbuffers::FlatBufferBuilder &_fbb, const SavedPendingChoiceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SaveStateT : public ::flatbuffers::NativeTable {
  typedef SaveState TableType;
  std::string version{};
  std::string story_version{};
  std::string current_node_name{};
  uint32_t pc = 0;
  bool finished = false;
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::SavedVarT>> variables{};
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::SavedCallFrameT>> call_stack{};
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::SavedPendingChoiceT>> pending_choices{};
  SaveStateT() = default;
  SaveStateT(const SaveStateT &o);
  SaveStateT(SaveStateT&&) FLATBUFFERS_NOEXCEPT = default;
  SaveStateT &operator=(SaveStateT o) FLATBUFFERS_NOEXCEPT;
};

struct SaveState FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SaveStateT NativeTableType;
  typedef SaveStateBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_STORY_VERSION = 6,
    VT_CURRENT_NODE_NAME = 8,
    VT_PC = 10,
    VT_FINISHED = 12,
    VT_VARIABLES = 14,
    VT_CALL_STACK = 16,
    VT_PENDING_CHOICES = 18
  };
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  const ::flatbuffers::String *story_version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STORY_VERSION);
  }
  const ::flatbuffers::String *current_node_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CURRENT_NODE_NAME);
  }
  uint32_t pc() const {
    return GetField<uint32_t>(VT_PC, 0);
  }
  bool finished() const {
    return GetField<uint8_t>(VT_FINISHED, 0) != 0;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVar>> *variables() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVar>> *>(VT_VARIABLES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedCallFrame>> *call_stack() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedCallFrame>> *>(VT_CALL_STACK);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedPendingChoice>> *pending_choices() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedPendingChoice>> *>(VT_PENDING_CHOICES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_STORY_VERSION) &&
           verifier.VerifyString(story_version()) &&
           VerifyOffset(verifier, VT_CURRENT_NODE_NAME) &&
           verifier.VerifyString(current_node_name()) &&
           VerifyField<uint32_t>(verifier, VT_PC, 4) &&
           VerifyField<uint8_t>(verifier, VT_FINISHED, 1) &&
           VerifyOffset(verifier, VT_VARIABLES) &&
           verifier.VerifyVector(variables()) &&
           verifier.VerifyVectorOfTables(variables()) &&
           VerifyOffset(verifier, VT_CALL_STACK) &&
           verifier.VerifyVector(call_stack()) &&
           verifier.VerifyVectorOfTables(call_stack()) &&
           VerifyOffset(verifier, VT_PENDING_CHOICES) &&
           verifier.VerifyVector(pending_choices()) &&
           verifier.VerifyVectorOfTables(pending_choices()) &&
           verifier.EndTable();
  }
  SaveStateT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SaveStateT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SaveState> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SaveStateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SaveStateBuilder {
  typedef SaveState Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(SaveState::VT_VERSION, version);
  }
  void add_story_version(::flatbuffers::Offset<::flatbuffers::String> story_version) {
    fbb_.AddOffset(SaveState::VT_STORY_VERSION, story_version);
  }
  void add_current_node_name(::flatbuffers::Offset<::flatbuffers::String> current_node_name) {
    fbb_.AddOffset(SaveState::VT_CURRENT_NODE_NAME, current_node_name);
  }
  void add_pc(uint32_t pc) {
    fbb_.AddElement<uint32_t>(SaveState::VT_PC, pc, 0);
  }
  void add_finished(bool finished) {
    fbb_.AddElement<uint8_t>(SaveState::VT_FINISHED, static_cast<uint8_t>(finished), 0);
  }
  void add_variables(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVar>>> variables) {
    fbb_.AddOffset(SaveState::VT_VARIABLES, variables);
  }
  void add_call_stack(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedCallFrame>>> call_stack) {
    fbb_.AddOffset(SaveState::VT_CALL_STACK, call_stack);
  }
  void add_pending_choices(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedPendingChoice>>> pending_choices) {
    fbb_.AddOffset(SaveState::VT_PENDING_CHOICES, pending_choices);
  }
  explicit SaveStateBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SaveState> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SaveState>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SaveState> CreateSaveState(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> story_version = 0,
    ::flatbuffers::Offset<::flatbuffers::String> current_node_name = 0,
    uint32_t pc = 0,
    bool finished = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVar>>> variables = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedCallFrame>>> call_stack = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedPendingChoice>>> pending_choices = 0) {
  SaveStateBuilder builder_(_fbb);
  builder_.add_pending_choices(pending_choices);
  builder_.add_call_stack(call_stack);
  builder_.add_variables(variables);
  builder_.add_pc(pc);
  builder_.add_current_node_name(current_node_name);
  builder_.add_story_version(story_version);
  builder_.add_version(version);
  builder_.add_finished(finished);
  return builder_.Finish();
}

struct SaveState::Traits {
  using type = SaveState;
  static auto constexpr Create = CreateSaveState;
};

inline ::flatbuffers::Offset<SaveState> CreateSaveStateDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    const char *story_version = nullptr,
    const char *current_node_name = nullptr,
    uint32_t pc = 0,
    bool finished = false,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVar>> *variables = nullptr,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedCallFrame>> *call_stack = nullptr,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedPendingChoice>> *pending_choices = nullptr) {
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto story_version__ = story_version ? _fbb.CreateString(story_version) : 0;
  auto current_node_name__ = current_node_name ? _fbb.CreateString(current_node_name) : 0;
  auto variables__ = variables ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVar>>(*variables) : 0;
  auto call_stack__ = call_stack ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedCallFrame>>(*call_stack) : 0;
  auto pending_choices__ = pending_choices ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedPendingChoice>>(*pending_choices) : 0;
  return ICPDev::Gyeol::Schema::CreateSaveState(
      _fbb,
      version__,
      story_version__,
      current_node_name__,
      pc,
      finished,
      variables__,
      call_stack__,
      pending_choices__);
}

::flatbuffers::Offset<SaveState> CreateSaveState(::flatbuffers::FlatBufferBuilder &_fbb, const SaveStateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StoryT : public ::flatbuffers::NativeTable {
  typedef Story TableType;
  std::string version{};
  std::vector<std::string> string_pool{};
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::SetVarT>> global_vars{};
  std::vector<std::unique_ptr<ICPDev::Gyeol::Schema::NodeT>> nodes{};
  std::string start_node_name{};
  StoryT() = default;
  StoryT(const StoryT &o);
  StoryT(StoryT&&) FLATBUFFERS_NOEXCEPT = default;
  StoryT &operator=(StoryT o) FLATBUFFERS_NOEXCEPT;
};

struct Story FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StoryT NativeTableType;
  typedef StoryBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_STRING_POOL = 6,
    VT_GLOBAL_VARS = 8,
    VT_NODES = 10,
    VT_START_NODE_NAME = 12
  };
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *string_pool() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRING_POOL);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>> *global_vars() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>> *>(VT_GLOBAL_VARS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>> *nodes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>> *>(VT_NODES);
  }
  const ::flatbuffers::String *start_node_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_START_NODE_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_STRING_POOL) &&
           verifier.VerifyVector(string_pool()) &&
           verifier.VerifyVectorOfStrings(string_pool()) &&
           VerifyOffset(verifier, VT_GLOBAL_VARS) &&
           verifier.VerifyVector(global_vars()) &&
           verifier.VerifyVectorOfTables(global_vars()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_START_NODE_NAME) &&
           verifier.VerifyString(start_node_name()) &&
           verifier.EndTable();
  }
  StoryT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StoryT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Story> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StoryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StoryBuilder {
  typedef Story Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(Story::VT_VERSION, version);
  }
  void add_string_pool(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> string_pool) {
    fbb_.AddOffset(Story::VT_STRING_POOL, string_pool);
  }
  void add_global_vars(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>>> global_vars) {
    fbb_.AddOffset(Story::VT_GLOBAL_VARS, global_vars);
  }
  void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>>> nodes) {
    fbb_.AddOffset(Story::VT_NODES, nodes);
  }
  void add_start_node_name(::flatbuffers::Offset<::flatbuffers::String> start_node_name) {
    fbb_.AddOffset(Story::VT_START_NODE_NAME, start_node_name);
  }
  explicit StoryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Story> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Story>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Story> CreateStory(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> string_pool = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>>> global_vars = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>>> nodes = 0,
    ::flatbuffers::Offset<::flatbuffers::String> start_node_name = 0) {
  StoryBuilder builder_(_fbb);
  builder_.add_start_node_name(start_node_name);
  builder_.add_nodes(nodes);
  builder_.add_global_vars(global_vars);
  builder_.add_string_pool(string_pool);
  builder_.add_version(version);
  return builder_.Finish();
}

struct Story::Traits {
  using type = Story;
  static auto constexpr Create = CreateStory;
};

inline ::flatbuffers::Offset<Story> CreateStoryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *string_pool = nullptr,
    const std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>> *global_vars = nullptr,
    std::vector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>> *nodes = nullptr,
    const char *start_node_name = nullptr) {
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto string_pool__ = string_pool ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*string_pool) : 0;
  auto global_vars__ = global_vars ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>>(*global_vars) : 0;
  auto nodes__ = nodes ? _fbb.CreateVectorOfSortedTables<ICPDev::Gyeol::Schema::Node>(nodes) : 0;
  auto start_node_name__ = start_node_name ? _fbb.CreateString(start_node_name) : 0;
  return ICPDev::Gyeol::Schema::CreateStory(
      _fbb,
      version__,
      string_pool__,
      global_vars__,
      nodes__,
      start_node_name__);
}

::flatbuffers::Offset<Story> CreateStory(::flatbuffers::FlatBufferBuilder &_fbb, const StoryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline BoolValueT *BoolValue::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<BoolValueT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void BoolValue::UnPackTo(BoolValueT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = val(); _o->val = _e; }
}

inline ::flatbuffers::Offset<BoolValue> BoolValue::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const BoolValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBoolValue(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<BoolValue> CreateBoolValue(::flatbuffers::FlatBufferBuilder &_fbb, const BoolValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const BoolValueT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _val = _o->val;
  return ICPDev::Gyeol::Schema::CreateBoolValue(
      _fbb,
      _val);
}

inline IntValueT *IntValue::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<IntValueT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void IntValue::UnPackTo(IntValueT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = val(); _o->val = _e; }
}

inline ::flatbuffers::Offset<IntValue> IntValue::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const IntValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIntValue(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<IntValue> CreateIntValue(::flatbuffers::FlatBufferBuilder &_fbb, const IntValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const IntValueT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _val = _o->val;
  return ICPDev::Gyeol::Schema::CreateIntValue(
      _fbb,
      _val);
}

inline FloatValueT *FloatValue::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FloatValueT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FloatValue::UnPackTo(FloatValueT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = val(); _o->val = _e; }
}

inline ::flatbuffers::Offset<FloatValue> FloatValue::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FloatValueT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFloatValue(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FloatValue> CreateFloatValue(::flatbuffers::FlatBufferBuilder &_fbb, const FloatValueT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FloatValueT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _val = _o->val;
  return ICPDev::Gyeol::Schema::CreateFloatValue(
      _fbb,
      _val);
}

inline StringRefT *StringRef::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<StringRefT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StringRef::UnPackTo(StringRefT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = index(); _o->index = _e; }
}

inline ::flatbuffers::Offset<StringRef> StringRef::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StringRefT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStringRef(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StringRef> CreateStringRef(::flatbuffers::FlatBufferBuilder &_fbb, const StringRefT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StringRefT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _index = _o->index;
  return ICPDev::Gyeol::Schema::CreateStringRef(
      _fbb,
      _index);
}

inline LineT *Line::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LineT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Line::UnPackTo(LineT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = character_id(); _o->character_id = _e; }
  { auto _e = text_id(); _o->text_id = _e; }
  { auto _e = voice_asset_id(); _o->voice_asset_id = _e; }
}

inline ::flatbuffers::Offset<Line> Line::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LineT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLine(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Line> CreateLine(::flatbuffers::FlatBufferBuilder &_fbb, const LineT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LineT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _character_id = _o->character_id;
  auto _text_id = _o->text_id;
  auto _voice_asset_id = _o->voice_asset_id;
  return ICPDev::Gyeol::Schema::CreateLine(
      _fbb,
      _character_id,
      _text_id,
      _voice_asset_id);
}

inline ChoiceT *Choice::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ChoiceT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Choice::UnPackTo(ChoiceT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = text_id(); _o->text_id = _e; }
  { auto _e = target_node_name_id(); _o->target_node_name_id = _e; }
  { auto _e = condition_var_id(); _o->condition_var_id = _e; }
}

inline ::flatbuffers::Offset<Choice> Choice::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ChoiceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateChoice(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Choice> CreateChoice(::flatbuffers::FlatBufferBuilder &_fbb, const ChoiceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ChoiceT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _text_id = _o->text_id;
  auto _target_node_name_id = _o->target_node_name_id;
  auto _condition_var_id = _o->condition_var_id;
  return ICPDev::Gyeol::Schema::CreateChoice(
      _fbb,
      _text_id,
      _target_node_name_id,
      _condition_var_id);
}

inline JumpT *Jump::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<JumpT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Jump::UnPackTo(JumpT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target_node_name_id(); _o->target_node_name_id = _e; }
  { auto _e = is_call(); _o->is_call = _e; }
}

inline ::flatbuffers::Offset<Jump> Jump::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const JumpT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateJump(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Jump> CreateJump(::flatbuffers::FlatBufferBuilder &_fbb, const JumpT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const JumpT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target_node_name_id = _o->target_node_name_id;
  auto _is_call = _o->is_call;
  return ICPDev::Gyeol::Schema::CreateJump(
      _fbb,
      _target_node_name_id,
      _is_call);
}

inline CommandT *Command::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CommandT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Command::UnPackTo(CommandT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type_id(); _o->type_id = _e; }
  { auto _e = params(); if (_e) { _o->params.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->params[_i] = _e->Get(_i); } } else { _o->params.resize(0); } }
}

inline ::flatbuffers::Offset<Command> Command::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCommand(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Command> CreateCommand(::flatbuffers::FlatBufferBuilder &_fbb, const CommandT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CommandT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type_id = _o->type_id;
  auto _params = _o->params.size() ? _fbb.CreateVector(_o->params) : 0;
  return ICPDev::Gyeol::Schema::CreateCommand(
      _fbb,
      _type_id,
      _params);
}

inline ExprTokenT *ExprToken::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ExprTokenT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ExprToken::UnPackTo(ExprTokenT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = op(); _o->op = _e; }
  { auto _e = literal_value_type(); _o->literal_value.type = _e; }
  { auto _e = literal_value(); if (_e) _o->literal_value.value = ICPDev::Gyeol::Schema::ValueDataUnion::UnPack(_e, literal_value_type(), _resolver); }
  { auto _e = var_name_id(); _o->var_name_id = _e; }
}

inline ::flatbuffers::Offset<ExprToken> ExprToken::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExprTokenT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExprToken(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ExprToken> CreateExprToken(::flatbuffers::FlatBufferBuilder &_fbb, const ExprTokenT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ExprTokenT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _op = _o->op;
  auto _literal_value_type = _o->literal_value.type;
  auto _literal_value = _o->literal_value.Pack(_fbb);
  auto _var_name_id = _o->var_name_id;
  return ICPDev::Gyeol::Schema::CreateExprToken(
      _fbb,
      _op,
      _literal_value_type,
      _literal_value,
      _var_name_id);
}

inline ExpressionT::ExpressionT(const ExpressionT &o) {
  tokens.reserve(o.tokens.size());
  for (const auto &tokens_ : o.tokens) { tokens.emplace_back((tokens_) ? new ICPDev::Gyeol::Schema::ExprTokenT(*tokens_) : nullptr); }
}

inline ExpressionT &ExpressionT::operator=(ExpressionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(tokens, o.tokens);
  return *this;
}

inline ExpressionT *Expression::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ExpressionT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Expression::UnPackTo(ExpressionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tokens(); if (_e) { _o->tokens.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->tokens[_i]) { _e->Get(_i)->UnPackTo(_o->tokens[_i].get(), _resolver); } else { _o->tokens[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::ExprTokenT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->tokens.resize(0); } }
}

inline ::flatbuffers::Offset<Expression> Expression::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ExpressionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExpression(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Expression> CreateExpression(::flatbuffers::FlatBufferBuilder &_fbb, const ExpressionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ExpressionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tokens = _o->tokens.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::ExprToken>> (_o->tokens.size(), [](size_t i, _VectorArgs *__va) { return CreateExprToken(*__va->__fbb, __va->__o->tokens[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ICPDev::Gyeol::Schema::CreateExpression(
      _fbb,
      _tokens);
}

inline SetVarT::SetVarT(const SetVarT &o)
      : var_name_id(o.var_name_id),
        value(o.value),
        expr((o.expr) ? new ICPDev::Gyeol::Schema::ExpressionT(*o.expr) : nullptr) {
}

inline SetVarT &SetVarT::operator=(SetVarT o) FLATBUFFERS_NOEXCEPT {
  std::swap(var_name_id, o.var_name_id);
  std::swap(value, o.value);
  std::swap(expr, o.expr);
  return *this;
}

inline SetVarT *SetVar::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SetVarT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SetVar::UnPackTo(SetVarT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = var_name_id(); _o->var_name_id = _e; }
  { auto _e = value_type(); _o->value.type = _e; }
  { auto _e = value(); if (_e) _o->value.value = ICPDev::Gyeol::Schema::ValueDataUnion::UnPack(_e, value_type(), _resolver); }
  { auto _e = expr(); if (_e) { if(_o->expr) { _e->UnPackTo(_o->expr.get(), _resolver); } else { _o->expr = std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT>(_e->UnPack(_resolver)); } } else if (_o->expr) { _o->expr.reset(); } }
}

inline ::flatbuffers::Offset<SetVar> SetVar::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SetVarT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSetVar(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SetVar> CreateSetVar(::flatbuffers::FlatBufferBuilder &_fbb, const SetVarT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SetVarT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _var_name_id = _o->var_name_id;
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  auto _expr = _o->expr ? CreateExpression(_fbb, _o->expr.get(), _rehasher) : 0;
  return ICPDev::Gyeol::Schema::CreateSetVar(
      _fbb,
      _var_name_id,
      _value_type,
      _value,
      _expr);
}

inline ConditionT::ConditionT(const ConditionT &o)
      : var_name_id(o.var_name_id),
        op(o.op),
        compare_value(o.compare_value),
        true_jump_node_id(o.true_jump_node_id),
        false_jump_node_id(o.false_jump_node_id),
        lhs_expr((o.lhs_expr) ? new ICPDev::Gyeol::Schema::ExpressionT(*o.lhs_expr) : nullptr),
        rhs_expr((o.rhs_expr) ? new ICPDev::Gyeol::Schema::ExpressionT(*o.rhs_expr) : nullptr),
        cond_expr((o.cond_expr) ? new ICPDev::Gyeol::Schema::ExpressionT(*o.cond_expr) : nullptr) {
}

inline ConditionT &ConditionT::operator=(ConditionT o) FLATBUFFERS_NOEXCEPT {
  std::swap(var_name_id, o.var_name_id);
  std::swap(op, o.op);
  std::swap(compare_value, o.compare_value);
  std::swap(true_jump_node_id, o.true_jump_node_id);
  std::swap(false_jump_node_id, o.false_jump_node_id);
  std::swap(lhs_expr, o.lhs_expr);
  std::swap(rhs_expr, o.rhs_expr);
  std::swap(cond_expr, o.cond_expr);
  return *this;
}

inline ConditionT *Condition::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<ConditionT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Condition::UnPackTo(ConditionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = var_name_id(); _o->var_name_id = _e; }
  { auto _e = op(); _o->op = _e; }
  { auto _e = compare_value_type(); _o->compare_value.type = _e; }
  { auto _e = compare_value(); if (_e) _o->compare_value.value = ICPDev::Gyeol::Schema::ValueDataUnion::UnPack(_e, compare_value_type(), _resolver); }
  { auto _e = true_jump_node_id(); _o->true_jump_node_id = _e; }
  { auto _e = false_jump_node_id(); _o->false_jump_node_id = _e; }
  { auto _e = lhs_expr(); if (_e) { if(_o->lhs_expr) { _e->UnPackTo(_o->lhs_expr.get(), _resolver); } else { _o->lhs_expr = std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT>(_e->UnPack(_resolver)); } } else if (_o->lhs_expr) { _o->lhs_expr.reset(); } }
  { auto _e = rhs_expr(); if (_e) { if(_o->rhs_expr) { _e->UnPackTo(_o->rhs_expr.get(), _resolver); } else { _o->rhs_expr = std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT>(_e->UnPack(_resolver)); } } else if (_o->rhs_expr) { _o->rhs_expr.reset(); } }
  { auto _e = cond_expr(); if (_e) { if(_o->cond_expr) { _e->UnPackTo(_o->cond_expr.get(), _resolver); } else { _o->cond_expr = std::unique_ptr<ICPDev::Gyeol::Schema::ExpressionT>(_e->UnPack(_resolver)); } } else if (_o->cond_expr) { _o->cond_expr.reset(); } }
}

inline ::flatbuffers::Offset<Condition> Condition::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ConditionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCondition(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Condition> CreateCondition(::flatbuffers::FlatBufferBuilder &_fbb, const ConditionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ConditionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _var_name_id = _o->var_name_id;
  auto _op = _o->op;
  auto _compare_value_type = _o->compare_value.type;
  auto _compare_value = _o->compare_value.Pack(_fbb);
  auto _true_jump_node_id = _o->true_jump_node_id;
  auto _false_jump_node_id = _o->false_jump_node_id;
  auto _lhs_expr = _o->lhs_expr ? CreateExpression(_fbb, _o->lhs_expr.get(), _rehasher) : 0;
  auto _rhs_expr = _o->rhs_expr ? CreateExpression(_fbb, _o->rhs_expr.get(), _rehasher) : 0;
  auto _cond_expr = _o->cond_expr ? CreateExpression(_fbb, _o->cond_expr.get(), _rehasher) : 0;
  return ICPDev::Gyeol::Schema::CreateCondition(
      _fbb,
      _var_name_id,
      _op,
      _compare_value_type,
      _compare_value,
      _true_jump_node_id,
      _false_jump_node_id,
      _lhs_expr,
      _rhs_expr,
      _cond_expr);
}

inline RandomBranchT *RandomBranch::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<RandomBranchT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RandomBranch::UnPackTo(RandomBranchT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = target_node_name_id(); _o->target_node_name_id = _e; }
  { auto _e = weight(); _o->weight = _e; }
}

inline ::flatbuffers::Offset<RandomBranch> RandomBranch::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RandomBranchT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRandomBranch(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RandomBranch> CreateRandomBranch(::flatbuffers::FlatBufferBuilder &_fbb, const RandomBranchT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RandomBranchT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _target_node_name_id = _o->target_node_name_id;
  auto _weight = _o->weight;
  return ICPDev::Gyeol::Schema::CreateRandomBranch(
      _fbb,
      _target_node_name_id,
      _weight);
}

inline RandomT::RandomT(const RandomT &o) {
  branches.reserve(o.branches.size());
  for (const auto &branches_ : o.branches) { branches.emplace_back((branches_) ? new ICPDev::Gyeol::Schema::RandomBranchT(*branches_) : nullptr); }
}

inline RandomT &RandomT::operator=(RandomT o) FLATBUFFERS_NOEXCEPT {
  std::swap(branches, o.branches);
  return *this;
}

inline RandomT *Random::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<RandomT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Random::UnPackTo(RandomT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = branches(); if (_e) { _o->branches.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->branches[_i]) { _e->Get(_i)->UnPackTo(_o->branches[_i].get(), _resolver); } else { _o->branches[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::RandomBranchT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->branches.resize(0); } }
}

inline ::flatbuffers::Offset<Random> Random::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RandomT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRandom(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Random> CreateRandom(::flatbuffers::FlatBufferBuilder &_fbb, const RandomT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RandomT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _branches = _o->branches.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::RandomBranch>> (_o->branches.size(), [](size_t i, _VectorArgs *__va) { return CreateRandomBranch(*__va->__fbb, __va->__o->branches[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ICPDev::Gyeol::Schema::CreateRandom(
      _fbb,
      _branches);
}

inline InstructionT *Instruction::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<InstructionT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Instruction::UnPackTo(InstructionT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = data_type(); _o->data.type = _e; }
  { auto _e = data(); if (_e) _o->data.value = ICPDev::Gyeol::Schema::OpDataUnion::UnPack(_e, data_type(), _resolver); }
}

inline ::flatbuffers::Offset<Instruction> Instruction::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const InstructionT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateInstruction(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Instruction> CreateInstruction(::flatbuffers::FlatBufferBuilder &_fbb, const InstructionT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const InstructionT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _data_type = _o->data.type;
  auto _data = _o->data.Pack(_fbb);
  return ICPDev::Gyeol::Schema::CreateInstruction(
      _fbb,
      _data_type,
      _data);
}

inline NodeT::NodeT(const NodeT &o)
      : name(o.name) {
  lines.reserve(o.lines.size());
  for (const auto &lines_ : o.lines) { lines.emplace_back((lines_) ? new ICPDev::Gyeol::Schema::InstructionT(*lines_) : nullptr); }
}

inline NodeT &NodeT::operator=(NodeT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(lines, o.lines);
  return *this;
}

inline NodeT *Node::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<NodeT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Node::UnPackTo(NodeT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = lines(); if (_e) { _o->lines.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->lines[_i]) { _e->Get(_i)->UnPackTo(_o->lines[_i].get(), _resolver); } else { _o->lines[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::InstructionT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->lines.resize(0); } }
}

inline ::flatbuffers::Offset<Node> Node::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNode(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Node> CreateNode(::flatbuffers::FlatBufferBuilder &_fbb, const NodeT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const NodeT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _fbb.CreateString(_o->name);
  auto _lines = _o->lines.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Instruction>> (_o->lines.size(), [](size_t i, _VectorArgs *__va) { return CreateInstruction(*__va->__fbb, __va->__o->lines[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ICPDev::Gyeol::Schema::CreateNode(
      _fbb,
      _name,
      _lines);
}

inline SavedVarT *SavedVar::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SavedVarT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SavedVar::UnPackTo(SavedVarT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = value_type(); _o->value.type = _e; }
  { auto _e = value(); if (_e) _o->value.value = ICPDev::Gyeol::Schema::ValueDataUnion::UnPack(_e, value_type(), _resolver); }
  { auto _e = string_value(); if (_e) _o->string_value = _e->str(); }
}

inline ::flatbuffers::Offset<SavedVar> SavedVar::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SavedVarT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSavedVar(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SavedVar> CreateSavedVar(::flatbuffers::FlatBufferBuilder &_fbb, const SavedVarT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SavedVarT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _value_type = _o->value.type;
  auto _value = _o->value.Pack(_fbb);
  auto _string_value = _o->string_value.empty() ? 0 : _fbb.CreateString(_o->string_value);
  return ICPDev::Gyeol::Schema::CreateSavedVar(
      _fbb,
      _name,
      _value_type,
      _value,
      _string_value);
}

inline SavedCallFrameT *SavedCallFrame::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SavedCallFrameT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SavedCallFrame::UnPackTo(SavedCallFrameT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = node_name(); if (_e) _o->node_name = _e->str(); }
  { auto _e = pc(); _o->pc = _e; }
}

inline ::flatbuffers::Offset<SavedCallFrame> SavedCallFrame::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SavedCallFrameT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSavedCallFrame(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SavedCallFrame> CreateSavedCallFrame(::flatbuffers::FlatBufferBuilder &_fbb, const SavedCallFrameT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SavedCallFrameT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _node_name = _o->node_name.empty() ? 0 : _fbb.CreateString(_o->node_name);
  auto _pc = _o->pc;
  return ICPDev::Gyeol::Schema::CreateSavedCallFrame(
      _fbb,
      _node_name,
      _pc);
}

inline SavedPendingChoiceT *SavedPendingChoice::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SavedPendingChoiceT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SavedPendingChoice::UnPackTo(SavedPendingChoiceT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = text(); if (_e) _o->text = _e->str(); }
  { auto _e = target_node_name(); if (_e) _o->target_node_name = _e->str(); }
}

inline ::flatbuffers::Offset<SavedPendingChoice> SavedPendingChoice::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SavedPendingChoiceT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSavedPendingChoice(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SavedPendingChoice> CreateSavedPendingChoice(::flatbuffers::FlatBufferBuilder &_fbb, const SavedPendingChoiceT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SavedPendingChoiceT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _text = _o->text.empty() ? 0 : _fbb.CreateString(_o->text);
  auto _target_node_name = _o->target_node_name.empty() ? 0 : _fbb.CreateString(_o->target_node_name);
  return ICPDev::Gyeol::Schema::CreateSavedPendingChoice(
      _fbb,
      _text,
      _target_node_name);
}

inline SaveStateT::SaveStateT(const SaveStateT &o)
      : version(o.version),
        story_version(o.story_version),
        current_node_name(o.current_node_name),
        pc(o.pc),
        finished(o.finished) {
  variables.reserve(o.variables.size());
  for (const auto &variables_ : o.variables) { variables.emplace_back((variables_) ? new ICPDev::Gyeol::Schema::SavedVarT(*variables_) : nullptr); }
  call_stack.reserve(o.call_stack.size());
  for (const auto &call_stack_ : o.call_stack) { call_stack.emplace_back((call_stack_) ? new ICPDev::Gyeol::Schema::SavedCallFrameT(*call_stack_) : nullptr); }
  pending_choices.reserve(o.pending_choices.size());
  for (const auto &pending_choices_ : o.pending_choices) { pending_choices.emplace_back((pending_choices_) ? new ICPDev::Gyeol::Schema::SavedPendingChoiceT(*pending_choices_) : nullptr); }
}

inline SaveStateT &SaveStateT::operator=(SaveStateT o) FLATBUFFERS_NOEXCEPT {
  std::swap(version, o.version);
  std::swap(story_version, o.story_version);
  std::swap(current_node_name, o.current_node_name);
  std::swap(pc, o.pc);
  std::swap(finished, o.finished);
  std::swap(variables, o.variables);
  std::swap(call_stack, o.call_stack);
  std::swap(pending_choices, o.pending_choices);
  return *this;
}

inline SaveStateT *SaveState::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SaveStateT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SaveState::UnPackTo(SaveStateT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); if (_e) _o->version = _e->str(); }
  { auto _e = story_version(); if (_e) _o->story_version = _e->str(); }
  { auto _e = current_node_name(); if (_e) _o->current_node_name = _e->str(); }
  { auto _e = pc(); _o->pc = _e; }
  { auto _e = finished(); _o->finished = _e; }
  { auto _e = variables(); if (_e) { _o->variables.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->variables[_i]) { _e->Get(_i)->UnPackTo(_o->variables[_i].get(), _resolver); } else { _o->variables[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::SavedVarT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->variables.resize(0); } }
  { auto _e = call_stack(); if (_e) { _o->call_stack.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->call_stack[_i]) { _e->Get(_i)->UnPackTo(_o->call_stack[_i].get(), _resolver); } else { _o->call_stack[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::SavedCallFrameT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->call_stack.resize(0); } }
  { auto _e = pending_choices(); if (_e) { _o->pending_choices.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->pending_choices[_i]) { _e->Get(_i)->UnPackTo(_o->pending_choices[_i].get(), _resolver); } else { _o->pending_choices[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::SavedPendingChoiceT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->pending_choices.resize(0); } }
}

inline ::flatbuffers::Offset<SaveState> SaveState::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SaveStateT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSaveState(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SaveState> CreateSaveState(::flatbuffers::FlatBufferBuilder &_fbb, const SaveStateT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SaveStateT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _story_version = _o->story_version.empty() ? 0 : _fbb.CreateString(_o->story_version);
  auto _current_node_name = _o->current_node_name.empty() ? 0 : _fbb.CreateString(_o->current_node_name);
  auto _pc = _o->pc;
  auto _finished = _o->finished;
  auto _variables = _o->variables.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedVar>> (_o->variables.size(), [](size_t i, _VectorArgs *__va) { return CreateSavedVar(*__va->__fbb, __va->__o->variables[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _call_stack = _o->call_stack.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedCallFrame>> (_o->call_stack.size(), [](size_t i, _VectorArgs *__va) { return CreateSavedCallFrame(*__va->__fbb, __va->__o->call_stack[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _pending_choices = _o->pending_choices.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SavedPendingChoice>> (_o->pending_choices.size(), [](size_t i, _VectorArgs *__va) { return CreateSavedPendingChoice(*__va->__fbb, __va->__o->pending_choices[i].get(), __va->__rehasher); }, &_va ) : 0;
  return ICPDev::Gyeol::Schema::CreateSaveState(
      _fbb,
      _version,
      _story_version,
      _current_node_name,
      _pc,
      _finished,
      _variables,
      _call_stack,
      _pending_choices);
}

inline StoryT::StoryT(const StoryT &o)
      : version(o.version),
        string_pool(o.string_pool),
        start_node_name(o.start_node_name) {
  global_vars.reserve(o.global_vars.size());
  for (const auto &global_vars_ : o.global_vars) { global_vars.emplace_back((global_vars_) ? new ICPDev::Gyeol::Schema::SetVarT(*global_vars_) : nullptr); }
  nodes.reserve(o.nodes.size());
  for (const auto &nodes_ : o.nodes) { nodes.emplace_back((nodes_) ? new ICPDev::Gyeol::Schema::NodeT(*nodes_) : nullptr); }
}

inline StoryT &StoryT::operator=(StoryT o) FLATBUFFERS_NOEXCEPT {
  std::swap(version, o.version);
  std::swap(string_pool, o.string_pool);
  std::swap(global_vars, o.global_vars);
  std::swap(nodes, o.nodes);
  std::swap(start_node_name, o.start_node_name);
  return *this;
}

inline StoryT *Story::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<StoryT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Story::UnPackTo(StoryT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); if (_e) _o->version = _e->str(); }
  { auto _e = string_pool(); if (_e) { _o->string_pool.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->string_pool[_i] = _e->Get(_i)->str(); } } else { _o->string_pool.resize(0); } }
  { auto _e = global_vars(); if (_e) { _o->global_vars.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->global_vars[_i]) { _e->Get(_i)->UnPackTo(_o->global_vars[_i].get(), _resolver); } else { _o->global_vars[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::SetVarT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->global_vars.resize(0); } }
  { auto _e = nodes(); if (_e) { _o->nodes.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->nodes[_i]) { _e->Get(_i)->UnPackTo(_o->nodes[_i].get(), _resolver); } else { _o->nodes[_i] = std::unique_ptr<ICPDev::Gyeol::Schema::NodeT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->nodes.resize(0); } }
  { auto _e = start_node_name(); if (_e) _o->start_node_name = _e->str(); }
}

inline ::flatbuffers::Offset<Story> Story::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StoryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStory(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Story> CreateStory(::flatbuffers::FlatBufferBuilder &_fbb, const StoryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StoryT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _string_pool = _o->string_pool.size() ? _fbb.CreateVectorOfStrings(_o->string_pool) : 0;
  auto _global_vars = _o->global_vars.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::SetVar>> (_o->global_vars.size(), [](size_t i, _VectorArgs *__va) { return CreateSetVar(*__va->__fbb, __va->__o->global_vars[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _nodes = _o->nodes.size() ? _fbb.CreateVector<::flatbuffers::Offset<ICPDev::Gyeol::Schema::Node>> (_o->nodes.size(), [](size_t i, _VectorArgs *__va) { return CreateNode(*__va->__fbb, __va->__o->nodes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _start_node_name = _o->start_node_name.empty() ? 0 : _fbb.CreateString(_o->start_node_name);
  return ICPDev::Gyeol::Schema::CreateStory(
      _fbb,
      _version,
      _string_pool,
      _global_vars,
      _nodes,
      _start_node_name);
}

inline bool VerifyValueData(::flatbuffers::Verifier &verifier, const void *obj, ValueData type) {
  switch (type) {
    case ValueData::NONE: {
      return true;
    }
    case ValueData::BoolValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::BoolValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueData::IntValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::IntValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueData::FloatValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::FloatValue *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ValueData::StringRef: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::StringRef *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyValueDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ValueData> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyValueData(
        verifier,  values->Get(i), types->GetEnum<ValueData>(i))) {
      return false;
    }
  }
  return true;
}

inline void *ValueDataUnion::UnPack(const void *obj, ValueData type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case ValueData::BoolValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::BoolValue *>(obj);
      return ptr->UnPack(resolver);
    }
    case ValueData::IntValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::IntValue *>(obj);
      return ptr->UnPack(resolver);
    }
    case ValueData::FloatValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::FloatValue *>(obj);
      return ptr->UnPack(resolver);
    }
    case ValueData::StringRef: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::StringRef *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> ValueDataUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case ValueData::BoolValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::BoolValueT *>(value);
      return CreateBoolValue(_fbb, ptr, _rehasher).Union();
    }
    case ValueData::IntValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::IntValueT *>(value);
      return CreateIntValue(_fbb, ptr, _rehasher).Union();
    }
    case ValueData::FloatValue: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::FloatValueT *>(value);
      return CreateFloatValue(_fbb, ptr, _rehasher).Union();
    }
    case ValueData::StringRef: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::StringRefT *>(value);
      return CreateStringRef(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline ValueDataUnion::ValueDataUnion(const ValueDataUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case ValueData::BoolValue: {
      value = new ICPDev::Gyeol::Schema::BoolValueT(*reinterpret_cast<ICPDev::Gyeol::Schema::BoolValueT *>(u.value));
      break;
    }
    case ValueData::IntValue: {
      value = new ICPDev::Gyeol::Schema::IntValueT(*reinterpret_cast<ICPDev::Gyeol::Schema::IntValueT *>(u.value));
      break;
    }
    case ValueData::FloatValue: {
      value = new ICPDev::Gyeol::Schema::FloatValueT(*reinterpret_cast<ICPDev::Gyeol::Schema::FloatValueT *>(u.value));
      break;
    }
    case ValueData::StringRef: {
      value = new ICPDev::Gyeol::Schema::StringRefT(*reinterpret_cast<ICPDev::Gyeol::Schema::StringRefT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void ValueDataUnion::Reset() {
  switch (type) {
    case ValueData::BoolValue: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::BoolValueT *>(value);
      delete ptr;
      break;
    }
    case ValueData::IntValue: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::IntValueT *>(value);
      delete ptr;
      break;
    }
    case ValueData::FloatValue: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::FloatValueT *>(value);
      delete ptr;
      break;
    }
    case ValueData::StringRef: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::StringRefT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = ValueData::NONE;
}

inline bool VerifyOpData(::flatbuffers::Verifier &verifier, const void *obj, OpData type) {
  switch (type) {
    case OpData::NONE: {
      return true;
    }
    case OpData::Line: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Line *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::Choice: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Choice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::Jump: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Jump *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::Command: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Command *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::SetVar: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::SetVar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::Condition: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Condition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpData::Random: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Random *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOpDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<OpData> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOpData(
        verifier,  values->Get(i), types->GetEnum<OpData>(i))) {
      return false;
    }
  }
  return true;
}

inline void *OpDataUnion::UnPack(const void *obj, OpData type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case OpData::Line: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Line *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::Choice: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Choice *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::Jump: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Jump *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::Command: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Command *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::SetVar: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::SetVar *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::Condition: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Condition *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpData::Random: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::Random *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> OpDataUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case OpData::Line: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::LineT *>(value);
      return CreateLine(_fbb, ptr, _rehasher).Union();
    }
    case OpData::Choice: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::ChoiceT *>(value);
      return CreateChoice(_fbb, ptr, _rehasher).Union();
    }
    case OpData::Jump: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::JumpT *>(value);
      return CreateJump(_fbb, ptr, _rehasher).Union();
    }
    case OpData::Command: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::CommandT *>(value);
      return CreateCommand(_fbb, ptr, _rehasher).Union();
    }
    case OpData::SetVar: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::SetVarT *>(value);
      return CreateSetVar(_fbb, ptr, _rehasher).Union();
    }
    case OpData::Condition: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::ConditionT *>(value);
      return CreateCondition(_fbb, ptr, _rehasher).Union();
    }
    case OpData::Random: {
      auto ptr = reinterpret_cast<const ICPDev::Gyeol::Schema::RandomT *>(value);
      return CreateRandom(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline OpDataUnion::OpDataUnion(const OpDataUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case OpData::Line: {
      value = new ICPDev::Gyeol::Schema::LineT(*reinterpret_cast<ICPDev::Gyeol::Schema::LineT *>(u.value));
      break;
    }
    case OpData::Choice: {
      value = new ICPDev::Gyeol::Schema::ChoiceT(*reinterpret_cast<ICPDev::Gyeol::Schema::ChoiceT *>(u.value));
      break;
    }
    case OpData::Jump: {
      value = new ICPDev::Gyeol::Schema::JumpT(*reinterpret_cast<ICPDev::Gyeol::Schema::JumpT *>(u.value));
      break;
    }
    case OpData::Command: {
      value = new ICPDev::Gyeol::Schema::CommandT(*reinterpret_cast<ICPDev::Gyeol::Schema::CommandT *>(u.value));
      break;
    }
    case OpData::SetVar: {
      value = new ICPDev::Gyeol::Schema::SetVarT(*reinterpret_cast<ICPDev::Gyeol::Schema::SetVarT *>(u.value));
      break;
    }
    case OpData::Condition: {
      value = new ICPDev::Gyeol::Schema::ConditionT(*reinterpret_cast<ICPDev::Gyeol::Schema::ConditionT *>(u.value));
      break;
    }
    case OpData::Random: {
      value = new ICPDev::Gyeol::Schema::RandomT(*reinterpret_cast<ICPDev::Gyeol::Schema::RandomT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void OpDataUnion::Reset() {
  switch (type) {
    case OpData::Line: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::LineT *>(value);
      delete ptr;
      break;
    }
    case OpData::Choice: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::ChoiceT *>(value);
      delete ptr;
      break;
    }
    case OpData::Jump: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::JumpT *>(value);
      delete ptr;
      break;
    }
    case OpData::Command: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::CommandT *>(value);
      delete ptr;
      break;
    }
    case OpData::SetVar: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::SetVarT *>(value);
      delete ptr;
      break;
    }
    case OpData::Condition: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::ConditionT *>(value);
      delete ptr;
      break;
    }
    case OpData::Random: {
      auto ptr = reinterpret_cast<ICPDev::Gyeol::Schema::RandomT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = OpData::NONE;
}

inline const ICPDev::Gyeol::Schema::Story *GetStory(const void *buf) {
  return ::flatbuffers::GetRoot<ICPDev::Gyeol::Schema::Story>(buf);
}

inline const ICPDev::Gyeol::Schema::Story *GetSizePrefixedStory(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ICPDev::Gyeol::Schema::Story>(buf);
}

inline bool VerifyStoryBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ICPDev::Gyeol::Schema::Story>(nullptr);
}

inline bool VerifySizePrefixedStoryBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ICPDev::Gyeol::Schema::Story>(nullptr);
}

inline void FinishStoryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ICPDev::Gyeol::Schema::Story> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedStoryBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ICPDev::Gyeol::Schema::Story> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<ICPDev::Gyeol::Schema::StoryT> UnPackStory(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ICPDev::Gyeol::Schema::StoryT>(GetStory(buf)->UnPack(res));
}

inline std::unique_ptr<ICPDev::Gyeol::Schema::StoryT> UnPackSizePrefixedStory(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<ICPDev::Gyeol::Schema::StoryT>(GetSizePrefixedStory(buf)->UnPack(res));
}

}  // namespace Schema
}  // namespace Gyeol
}  // namespace ICPDev

#endif  // FLATBUFFERS_GENERATED_GYEOL_ICPDEV_GYEOL_SCHEMA_H_
